本章介绍 Groovy 编程语言的语义。

# 语句

## 变量定义

可以使用变量的类型（如 String ）或使用关键字 def （或 var ）后跟变量名称来定义变量：

    String x
    def y
    var z

当您不想给出显式类型时， def 和 var 充当类型占位符，即替换类型名称。由于您在编译时不关心类型或者依赖于类型推断（具有 Groovy 的静态性质）

变量定义必须具有类型或占位符。如果省略，类型名称将被视为引用现有变量（可能是之前声明的）

对于脚本，未声明的变量被假定来自脚本绑定。在其他情况下，您将得到丢失的属性（动态 Groovy）或编译时错误（静态 Groovy）。如果您将 def 和 var 视为 Object 的别名，您立刻就会明白。

变量定义可以提供一个初始值，在这种情况下，就像将声明和赋值（我们接下来将介绍）合二为一。

变量定义类型可以通过使用泛型来细化，例如 List\<String\> names 。要了解有关泛型支持的更多信息，请阅读[generics section](core-object-orientation.xml#generics)部分。

## 变量赋值

您可以为变量赋值以供以后使用。请尝试以下操作：

    x = 1
    println x
    
    x = new java.util.Date()
    println x
    
    x = -3.1499392
    println x
    
    x = false
    println x
    
    x = "Hi"
    println x

### 多重赋值

Groovy 支持多重赋值，即可以一次赋值多个变量，例如：

    def (a, b, c) = [10, 20, 'foo']
    assert a == 10 && b == 20 && c == 'foo'

如果您愿意，您可以提供类型作为声明的一部分：

    def (int i, String j) = [10, 'foo']
    assert i == 10 && j == 'foo'

除了在声明变量时使用之外，它也适用于现有变量：

    def nums = [1, 3, 5]
    def a, b, c
    (a, b, c) = nums
    assert a == 1 && b == 3 && c == 5

该语法适用于数组和列表，以及返回其中任意一个的方法：

    def (_, month, year) = "18th June 2009".split()
    assert "In $month of $year" == 'In June of 2009'

### 上溢和下溢

如果左侧有太多变量，多余的变量将用 null 填充：

    def (a, b, c) = [1, 2]
    assert a == 1 && b == 2 && c == null

如果右侧有太多变量，则多余的变量将被忽略：

    def (a, b) = [1, 2, 3]
    assert a == 1 && b == 2

-   

## 控制结构

### 条件结构

#### if / else

Groovy 支持 Java 中常见的 if - else 语法

    def x = false
    def y = false
    
    if ( !x ) {
        x = true
    }
    
    assert x == true
    
    if ( x ) {
        x = false
    } else {
        y = true
    }
    
    assert x == y

Groovy 还支持普通的 Java"嵌套"if then else if 语法：

    if ( ... ) {
        ...
    } else if (...) {
        ...
    } else {
        ...
    }

#### switch / case

Groovy 中的 switch 语句向后兼容 Java 代码；因此有必要在每个case结束时使用 `break` 。

其中一个区别是 Groovy switch 语句可以处理任何类型的 switch 值，并且可以执行不同类型的匹配。

    def x = 1.23
    def result = ""
    
    switch (x) {
        case "foo":
            result = "found foo"
            // lets fall through
    
        case "bar":
            result += "bar"
    
        case [4, 5, 6, 'inList']:
            result = "list"
            break
    
        case 12..30:
            result = "range"
            break
    
        case Integer:
            result = "integer"
            break
    
        case Number:
            result = "number"
            break
    
        case ~/fo*/: // toString() representation of x matches the pattern?
            result = "foo regex"
            break
    
        case { it < 0 }: // or { x < 0 }
            result = "negative"
            break
    
        default:
            result = "default"
    }
    
    assert result == "number"

Switch 支持以下类型的比较：

-   Class case values match if the switch value is an instance of the class

-   Regular expression case values match if the `toString()` representation of the switch value matches the regex

-   Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)

-   Closure case values match if the calling the closure returns a result which is true according to the [Groovy truth](#the-groovy-truth)

-   If none of the above are used then the case value matches if the case value equals the switch value

When using a closure case value, the default `it` parameter is actually the switch value (in our example, variable `x`).

Groovy 还支持 switch 表达式，如以下示例所示：

    def partner = switch(person) {
        case 'Romeo'  -> 'Juliet'
        case 'Adam'   -> 'Eve'
        case 'Antony' -> 'Cleopatra'
        case 'Bonnie' -> 'Clyde'
    }

### 循环结构

#### 经典的for循环

Groovy 支持标准的 Java/C for 循环

    String message = ''
    for (int i = 0; i < 5; i++) {
        message += 'Hi '
    }
    assert message == 'Hi Hi Hi Hi Hi '

#### 增强的经典 Java 风格的 for 循环

现在支持使用逗号分隔表达式的 Java 经典 for 循环的更复杂的形式。例子：

    def facts = []
    def count = 5
    for (int fact = 1, i = 1; i <= count; i++, fact *= i) {
        facts << fact
    }
    assert facts == [1, 2, 6, 24, 120]

#### 与for循环结合的多重赋值

Groovy 从 Groovy 1.6 开始就支持多重赋值语句：

    // multi-assignment with types
    def (String x, int y) = ['foo', 42]
    assert "$x $y" == 'foo 42'

这些现在可以出现在 for 循环中：

    // multi-assignment goes loopy
    def baNums = []
    for (def (String u, int v) = ['bar', 42]; v < 45; u++, v++) {
        baNums << "$u $v"
    }
    assert baNums == ['bar 42', 'bas 43', 'bat 44']

#### for in 循环

Groovy 中的 for 循环要简单得多，并且适用于任何类型的数组、集合、Map 等。

    // iterate over a range
    def x = 0
    for ( i in 0..9 ) {
        x += i
    }
    assert x == 45
    
    // iterate over a list
    x = 0
    for ( i in [0, 1, 2, 3, 4] ) {
        x += i
    }
    assert x == 10
    
    // iterate over an array
    def array = (0..4).toArray()
    x = 0
    for ( i in array ) {
        x += i
    }
    assert x == 10
    
    // iterate over a map
    def map = ['abc':1, 'def':2, 'xyz':3]
    x = 0
    for ( e in map ) {
        x += e.value
    }
    assert x == 6
    
    // iterate over values in a map
    x = 0
    for ( v in map.values() ) {
        x += v
    }
    assert x == 6
    
    // iterate over the characters in a string
    def text = "abc"
    def list = []
    for (c in text) {
        list.add(c)
    }
    assert list == ["a", "b", "c"]

Groovy 还支持带有冒号的 Java 冒号变体： `for (char c : text) {}`

#### while 循环

Groovy 像 Java 一样支持常见的 `while {…​}` 循环：

    def x = 0
    def y = 5
    
    while ( y-- > 0 ) {
        x++
    }
    
    assert x == 5

#### do/while 循环

现在支持 Java 类 do/while 循环。例子：

    // classic Java-style do..while loop
    def count = 5
    def fact = 1
    do {
        fact *= count--
    } while(count > 1)
    assert fact == 120

### 异常处理

异常处理与Java相同。

### try / catch / finally

您可以指定 try-catch-finally 、 try-catch 或 try-finally 。

    try {
        'moo'.toLong()   // this will generate an exception
        assert false     // asserting that this point should never be reached
    } catch ( e ) {
        assert e in NumberFormatException
    }

我们可以将代码放在匹配的"try"子句后面的"finally"子句中，这样无论"try"子句中的代码是否抛出异常，finally子句中的代码都将始终执行：

    def z
    try {
        def i = 7, j = 0
        try {
            def k = i / j
            assert false        //never reached due to Exception in previous line
        } finally {
            z = 'reached here'  //always executed even if Exception thrown
        }
    } catch ( e ) {
        assert e in ArithmeticException
        assert z == 'reached here'
    }

### 多重捕获

使用多 catch 块（自 Groovy 2.0 起），我们能够定义多个要由同一 catch 块捕获和处理的异常：

    try {
        /* ... */
    } catch ( IOException | NullPointerException e ) {
        /* one block to handle 2 exceptions */
    }

### Try with resources

Groovy 通常为自动资源管理 (ARM) 提供 Java 7 的 try -with-resources 语句的更好替代方案。现在，迁移到 Groovy 但仍想使用旧样式的 Java 程序员支持该语法：

    class FromResource extends ByteArrayInputStream {
        @Override
        void close() throws IOException {
            super.close()
            println "FromResource closing"
        }
    
        FromResource(String input) {
            super(input.toLowerCase().bytes)
        }
    }
    
    class ToResource extends ByteArrayOutputStream {
        @Override
        void close() throws IOException {
            super.close()
            println "ToResource closing"
        }
    }
    
    def wrestle(s) {
        try (
                FromResource from = new FromResource(s)
                ToResource to = new ToResource()
        ) {
            to << from
            return to.toString()
        }
    }
    
    def wrestle2(s) {
        FromResource from = new FromResource(s)
        try (from; ToResource to = new ToResource()) { // Enhanced try-with-resources in Java 9+
            to << from
            return to.toString()
        }
    }
    
    assert wrestle("ARM was here!").contains('arm')
    assert wrestle2("ARM was here!").contains('arm')

产生以下输出：

    ToResource closing
    FromResource closing
    ToResource closing
    FromResource closing

## 断言

与 Groovy 与 Java 共享 assert 关键字不同，后者在 Groovy 中的行为非常不同。首先，Groovy 中的断言始终会执行，与 JVM 的 -ea 标志无关。它使其成为单元测试的一流选择。

断言分为 3 部分：

    assert [left expression] == [right expression] : (optional message)

断言的结果与 Java 中得到的结果非常不同。如果断言为真，那么什么也不会发生。如果断言为假，则它提供所断言表达式的每个子表达式的值的可视化表示。例如：

    assert 1+1 == 3

将产生：

    Caught: Assertion failed:
    
    assert 1+1 == 3
            |  |
            2  false

当表达式更复杂时，断言变得非常有趣，如下例所示：

    def x = 2
    def y = 7
    def z = 5
    def calc = { a,b -> a*b+1 }
    assert calc(x,y) == [x,z].sum()

这将打印每个子表达式的值：

    assert calc(x,y) == [x,z].sum()
           |    | |  |   | |  |
           15   2 7  |   2 5  7
                     false

如果您不想要像上面那样漂亮的打印错误消息，您可以通过更改断言的可选消息部分来回退到自定义错误消息，如下例所示：

    def x = 2
    def y = 7
    def z = 5
    def calc = { a,b -> a*b+1 }
    assert calc(x,y) == z*z : 'Incorrect computation result'

这将打印以下错误消息：

    Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = 5, z = 5

## 标签语句

任何语句都可以与标签相关联。标签不会影响代码的语义，可用于使代码更易于阅读，如下例所示：

    given:
        def x = 1
        def y = 2
    when:
        def z = x+y
    then:
        assert z == 3

尽管没有更改带标签语句的语义，但可以使用 break 指令中的标签作为跳转目标，如下例所示。然而，即使允许这样做，这种编码风格通常也被认为是一种不好的做法：

    for (int i=0;i<10;i++) {
        for (int j=0;j<i;j++) {
            println "j=$j"
            if (j == 5) {
                break exit
            }
        }
        exit: println "i=$i"
    }

需要明白的是，默认情况下标签对代码的语义没有影响，但是它们属于抽象语法树 (AST)，因此 AST 转换可以使用该信息对代码执行转换，因此导致不同的语义。 Spock 框架尤其这样做是为了使测试更容易。

# 表达式

表达式是 Groovy 程序的构建块，用于引用现有值并执行代码来创建新值。

Groovy 支持许多与 Java 相同类型的表达式，包括：

Expressions like Java

+-------------------------------------+-----------------------------------------------------+
| 表达式                              | 描述                                                |
+-------------------------------------+-----------------------------------------------------+
| `foo`                               | the name of a variable, field, parameter, ...​       |
+-------------------------------------+-----------------------------------------------------+
| `this`, `super`, `it`               | special names                                       |
+-------------------------------------+-----------------------------------------------------+
| `true`, `10`, `"bar"`               | literals                                            |
+-------------------------------------+-----------------------------------------------------+
| `String.class`                      | Class literal                                       |
+-------------------------------------+-----------------------------------------------------+
| `(` *expression* `)`                | parenthesised expressions                           |
+-------------------------------------+-----------------------------------------------------+
| `foo++`, `~bar`                     | Unary [operator](core-operators.html) expressions   |
+-------------------------------------+-----------------------------------------------------+
| `foo + bar`, `bar * baz`            | Binary [operator](core-operators.html) expressions  |
+-------------------------------------+-----------------------------------------------------+
| `foo ? bar : baz`                   | Ternary [operator](core-operators.html) expressions |
+-------------------------------------+-----------------------------------------------------+
| `(Integer x, Integer y) → x + y`    | Lambda expressions                                  |
+-------------------------------------+-----------------------------------------------------+
|     assert 'bar' == switch('foo') { | switch expressions                                  |
|       case 'foo' -> 'bar'           |                                                     |
|     }                               |                                                     |
+-------------------------------------+-----------------------------------------------------+

: Expressions like Java

Groovy 还有一些自己的特殊表达式：

Special expressions

----------------------------------- ------------------------------------------------
  Example expression(s)               Description

  `String`                            Abbreviated class literal (when not ambiguous)

  `{ x, y → x + y }`                  Closure expressions

  `[1, 3, 5]`                         literal list expressions

  `[a:2, b:4, c:6]`                   literal map expressions
----------------------------------- ------------------------------------------------

  : Special expressions

Groovy 还扩展了 Java 中用于成员访问的普通点表示法。 Groovy 通过指定某些感兴趣数据的层次结构中的路径，为访问层次结构数据结构提供特殊支持。这些 Groovy 路径表达式称为 GPath 表达式。

## GPath 表达式

GPath 是集成到 Groovy 中的路径表达式语言，它允许识别部分嵌套结构化数据。从这个意义上说，它与 XPath 对于 XML 具有相似的目标和范围。 GPath 通常用于处理 XML 的上下文中，但它实际上适用于任何对象图。 XPath 使用类似文件系统的路径表示法，即由斜杠分隔各部分的树层次结构 / ，GPath 使用点对象表示法来执行对象导航。

例如，您可以指定感兴趣的对象或元素的路径：

-   `a.b.c` → 对于 XML，获取 a 内 b 内的所有 c 元素

-   `a.b.c` → 对于 POJO，获取 a 的所有 b 属性的 c 属性（有点像 a.getB().getC() 在 JavaBean 中）

在这两种情况下，GPath 表达式都可以被视为对象视图的查询。对于 POJO，对象视图常是由通过对象实例化和组合编写的程序构建的；对于 XML 处理，对象视图是 parsing XML 文本的结果，通常使用 XmlParser 或 XmlSlurper 等类。有关在 Groovy 中使用 XML 的更多详细信息，请参阅[解析 XML](xml-userguide.xml#processing-xml)。

当查询从 XmlParser 或 XmlSlurper 生成的对象视图时，GPath 表达式可以引用使用 @ 表示法的元素上定义的属性：

-   `a["@href"]` → map-like表示法 : 所有 a 元素的 href 属性

-   `a.'@href'` → 属性表示法 : 另一种表达方式

-   `a.@href` → 直接表示法 : 另一种表达方式

### 对象导航

让我们看一个简单对象图上的 GPath 表达式的示例，该对象图是使用 java 反射获得的。假设您位于一个类的非静态方法中，该方法具有另一个名为 aMethodFoo 的方法

    void aMethodFoo() { println "This is aMethodFoo." } 

以下 GPath 表达式将获取该方法的名称：

    assert ['aMethodFoo'] == this.class.methods.name.grep(~/.*Foo/)

更准确地说，上面的 GPath 表达式生成一个 String 列表，每个字符串都是 this 上现有方法的名称，其中该名称以 Foo 结尾。

现在，考虑到该类中还定义了以下方法：

    void aMethodBar() { println "This is aMethodBar." } 
    void anotherFooMethod() { println "This is anotherFooMethod." } 
    void aSecondMethodBar() { println "This is aSecondMethodBar." } 

那么以下 GPath 表达式将获取 (1) 和 (3) 的名称，但不会获取 (2) 或 (0) 的名称：

    assert ['aMethodBar', 'aSecondMethodBar'] as Set == this.class.methods.name.grep(~/.*Bar/) as Set

### 表达式解构

我们可以分解表达式 this.class.methods.name.grep(\~/.\*Bar/) 以了解 GPath 的计算方式：

`this.class`

:   属性访问器相当于 Java 中的 this.getClass() ，生成一个 Class 对象。

`this.class.methods`

:   属性访问器，相当于 this.getClass().getMethods() ，生成 Method 对象的数组。

`this.class.methods.name`

:   对数组的每个元素应用属性访问器并生成结果列表。

`this.class.methods.name.grep(…​)`

:   对 this.class.methods.name 生成的列表的每个元素调用方法 grep 并生成结果列表。

像 this.class.methods 这样的子表达式会生成一个数组，因为这就是在 Java 中调用 this.getClass().getMethods() 会生成的结果。 GPath 表达式没有约定，其中 s 表示列表或类似内容。

GPath 表达式的一项强大功能是，将对集合的属性访问转换为对集合的每个元素的属性访问，并将结果收集到集合中。因此，表达式 this.class.methods.name 在Java中可以表达如下：

    List<String> methodNames = new ArrayList<String>();
    for (Method method : this.getClass().getMethods()) {
       methodNames.add(method.getName());
    }
    return methodNames;

数组访问表示法也可以用在存在集合的 GPath 表达式中：

    assert 'aSecondMethodBar' == this.class.methods.name.grep(~/.*Bar/).sort()[1]

GPath 表达式中的数组访问是从零开始的

### 用于 XML 导航的 GPath

下面是一个包含 XML 文档和各种形式的 GPath 表达式的示例：

    def xmlText = """
                  | <root>
                  |   <level>
                  |      <sublevel id='1'>
                  |        <keyVal>
                  |          <key>mykey</key>
                  |          <value>value 123</value>
                  |        </keyVal>
                  |      </sublevel>
                  |      <sublevel id='2'>
                  |        <keyVal>
                  |          <key>anotherKey</key>
                  |          <value>42</value>
                  |        </keyVal>
                  |        <keyVal>
                  |          <key>mykey</key>
                  |          <value>fizzbuzz</value>
                  |        </keyVal>
                  |      </sublevel>
                  |   </level>
                  | </root>
                  """
    def root = new XmlSlurper().parseText(xmlText.stripMargin())
    assert root.level.size() == 1 
    assert root.level.sublevel.size() == 2 
    assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 
    assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey' 

-   root 下有一个 level 节点

-   root/level 下有两个 sublevel 节点

-   有一个元素 sublevel 具有属性 id ，其值为 1

-   root/level 下的第二个 sublevel 元素的第一个 keyVal 元素的 key 元素的文本值为 \'anotherKey\' 有关 XML GPath 表达式的更多详细信息，请参阅 XML 用户指南[XML User Guide](xml-userguide.xml#processing-xml)。

# Promotion and coercion

## Number promotion

The rules of number promotion are specified in the section on [math operations](core-syntax.xml#_math_operations).

## Closure to type coercion

### 将闭包分配给 SAM 类型

A SAM type is a type which defines a single abstract method. This includes:

**Functional interfaces**

    interface Predicate<T> {
        boolean accept(T obj)
    }

**Abstract classes with single abstract method**

    abstract class Greeter {
        abstract String getName()
        void greet() {
            println "Hello, $name"
        }
    }

Any closure can be converted into a SAM type using the `as` operator:

    Predicate filter = { it.contains 'G' } as Predicate
    assert filter.accept('Groovy') == true
    
    Greeter greeter = { 'Groovy' } as Greeter
    greeter.greet()

However, the `as Type` expression is optional since Groovy 2.2.0. You can omit it and simply write:

    Predicate filter = { it.contains 'G' }
    assert filter.accept('Groovy') == true
    
    Greeter greeter = { 'Groovy' }
    greeter.greet()

which means you are also allowed to use method pointers, as shown in the following example:

    boolean doFilter(String s) { s.contains('G') }
    
    Predicate filter = this.&doFilter
    assert filter.accept('Groovy') == true
    
    Greeter greeter = GroovySystem.&getVersion
    greeter.greet()

### Calling a method accepting a SAM type with a closure

The second and probably more important use case for closure to SAM type coercion is calling a method which accepts a SAM type. Imagine the following method:

    public <T> List<T> filter(List<T> source, Predicate<T> predicate) {
        source.findAll { predicate.accept(it) }
    }

Then you can call it with a closure, without having to create an explicit implementation of the interface:

    assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']

But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:

    assert filter(['Java','Groovy']) { it.contains 'G'} == ['Groovy']

As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the closure outside the parenthesis, improving the readability of your code.

### Closure to arbitrary type coercion

In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let's define the following interface:

    interface FooBar {
        int foo()
        void bar()
    }

You can coerce a closure into the interface using the `as` keyword:

    def impl = { println 'ok'; 123 } as FooBar

This produces a class for which all methods are implemented using the closure:

    assert impl.foo() == 123
    impl.bar()

But it is also possible to coerce a closure to any class. For example, we can replace the `interface` that we defined with `class` without changing the assertions:

    class FooBar {
        int foo() { 1 }
        void bar() { println 'bar' }
    }
    
    def impl = { println 'ok'; 123 } as FooBar
    
    assert impl.foo() == 123
    impl.bar()

## Map to type coercion

Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are interpreted as method names, while the values are the method implementation. The following example illustrates the coercion of a map into an `Iterator`:

    def map
    map = [
      i: 10,
      hasNext: { map.i > 0 },
      next: { map.i-- },
    ]
    def iter = map as Iterator

Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods that are actually called, but if a method is called that doesn't exist in the map a `MissingMethodException` or an `UnsupportedOperationException` is thrown, depending on the arguments passed to the call, as in the following example:

    interface X {
        void f()
        void g(int n)
        void h(String s, int n)
    }
    
    x = [ f: {println "f called"} ] as X
    x.f() // method exists
    x.g() // MissingMethodException here
    x.g(5) // UnsupportedOperationException here

The type of the exception depends on the call itself:

-   `MissingMethodException` if the arguments of the call do not match those from the interface/class

-   `UnsupportedOperationException` if the arguments of the call match one of the overloaded methods of the interface/class

## String to enum coercion

Groovy allows transparent `String` (or `GString`) to enum values coercion. Imagine you define the following enum:

    enum State {
        up,
        down
    }

then you can assign a string to the enum without having to use an explicit `as` coercion:

    State st = 'up'
    assert st == State.up

It is also possible to use a `GString` as the value:

    def val = "up"
    State st = "${val}"
    assert st == State.up

However, this would throw a runtime error (`IllegalArgumentException`):

    State st = 'not an enum value'

Note that it is also possible to use implicit coercion in switch statements:

    State switchState(State st) {
        switch (st) {
            case 'up':
                return State.down // explicit constant
            case 'down':
                return 'up' // implicit coercion for return types
        }
    }

in particular, see how the `case` use string constants. But if you call a method that uses an enum with a `String` argument, you still have to use an explicit `as` coercion:

    assert switchState('up' as State) == State.down
    assert switchState(State.down) == State.up

## Custom type coercion

It is possible for a class to define custom coercion strategies by implementing the `asType` method. Custom coercion is invoked using the `as` operator and is never implicit. As an example, imagine you defined two classes, `Polar` and `Cartesian`, like in the following example:

    class Polar {
        double r
        double phi
    }
    class Cartesian {
       double x
       double y
    }

And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define the `asType` method in the `Polar` class:

    def asType(Class target) {
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }

which allows you to use the `as` coercion operator:

    def sigma = 1E-16
    def polar = new Polar(r:1.0,phi:PI/2)
    def cartesian = polar as Cartesian
    assert abs(cartesian.x-sigma) < sigma

Putting it all together, the `Polar` class looks like this:

    class Polar {
        double r
        double phi
        def asType(Class target) {
            if (Cartesian==target) {
                return new Cartesian(x: r*cos(phi), y: r*sin(phi))
            }
        }
    }

but it is also possible to define `asType` outside of the `Polar` class, which can be practical if you want to define custom coercion strategies for \"closed\" classes or classes for which you don't own the source code, for example using a metaclass:

    Polar.metaClass.asType = { Class target ->
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }

## Class literals vs variables and the as operator

Using the `as` keyword is only possible if you have a static reference to a class, like in the following code:

    interface Greeter {
        void greet()
    }
    def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter is known statically
    greeter.greet()

But what if you get the class by reflection, for example by calling `Class.forName`?

    Class clazz = Class.forName('Greeter')

Trying to use the reference to the class with the `as` keyword would fail:

    greeter = { println 'Hello, Groovy!' } as clazz
    // throws:
    // unable to resolve class clazz
    // @ line 9, column 40.
    //   greeter = { println 'Hello, Groovy!' } as clazz

It is failing because the `as` keyword only works with class literals. Instead, you need to call the `asType` method:

    greeter = { println 'Hello, Groovy!' }.asType(clazz)
    greeter.greet()

# 可省略的

## 可选的括号

如果至少有一个参数并且没有歧义，方法调用可以省略括号：

    println 'Hello World'
    def maximum = Math.max 5, 10

无参数的方法调用或不明确的方法调用需要括号：

    println()
    println(Math.max(5, 10))

## 可选的分号

在 Groovy 中，如果该行仅包含单个语句，则可以省略该行末尾的分号。

这意味着：

    assert true;

可以更惯用地写为：

    assert true

一行中的多个语句需要分号来分隔它们：

    boolean a = true; assert a

## 可选的return关键字

在 Groovy 中，返回方法或闭包主体中计算的最后一个表达式。这意味着 return 关键字是可选的。

    int add(int a, int b) {
        return a+b
    }
    assert add(1, 2) == 3

可以缩短为：

    int add(int a, int b) {
        a+b
    }
    assert add(1, 2) == 3

## 可选的public关键字

默认情况下，Groovy 类和方法是 public 。因此这个类：

    public class Server {
        public String toString() { "a server" }
    }

与此类相同：

    class Server {
        String toString() { "a server" }
    }

# 表达式的真假

Groovy 通过应用以下规则来确定表达式是真还是假。

## Boolean expressions

如果相应的布尔值为 true ，则为 True。

    assert true
    assert !false

## 集合和数组

非空集合和数组都是true。

    assert [1, 2, 3]
    assert ![]

## Matchers

如果匹配器至少有一个匹配项，则为 true。

    assert ('a' =~ /a/)
    assert !('a' =~ /b/)

## 迭代器和枚举

具有下一个元素的迭代器和枚举被强制为 true。

    assert [0].iterator()
    assert ![].iterator()
    Vector v = [0] as Vector
    Enumeration enumeration = v.elements()
    assert enumeration
    enumeration.nextElement()
    assert !enumeration

## Maps

非空map被评估为 true。

    assert ['one' : 1]
    assert ![:]

## Strings

非空字符串、GString 和 CharSequences 被强制为 true。

    assert 'a'
    assert !''
    def nonEmpty = 'a'
    assert "$nonEmpty"
    def empty = ''
    assert !"$empty"

## Numbers

非零数为真。

    assert 1
    assert 3.5
    assert !0

## Object References

非空对象引用被强制为 true。

    assert new Object()
    assert !null

## 使用 asBoolean() 方法自定义真假

为了自定义是否将对象评估为 true 还是 false, 可以实现 asBoolean() 方法：

    class Color {
        String name
    
        boolean asBoolean(){
            name == 'green' ? true : false 
        }
    }

Groovy 将调用此方法将您的对象强制为布尔值，例如：

    assert new Color(name: 'green')
    assert !new Color(name: 'red')

# 类型

## 可选类型

可选类型是指即使您没有在变量上设置显式类型，程序也可以运行。作为一种动态语言，Groovy 自然地实现了该功能，例如当您声明变量时：

    String aString = 'foo'                      
    assert aString.toUpperCase()                

-   foo 使用显式类型声明， String

-   我们可以在 String 上调用 toUpperCase 方法

Groovy 会让你这样写：

    def aString = 'foo'                         
    assert aString.toUpperCase()                

-   foo 使用 def 声明

-   我们仍然可以调用 toUpperCase 方法，因为 aString 的类型是在运行时解析的

所以在这里使用显式类型并不重要。当您将此功能与[静态类型检查](#static-type-checking)结合起来时，它特别有趣，因为类型检查器执行类型推断。

同样，Groovy 并不强制要求在方法中声明参数的类型：

    String concat(String a, String b) {
        a+b
    }
    assert concat('foo','bar') == 'foobar'

可以使用 def 作为返回类型和参数类型进行重写，以便利用鸭子类型，如下例所示：

    def concat(def a, def b) {                              
        a+b
    }
    assert concat('foo','bar') == 'foobar'                  
    assert concat(1,2) == 3                                 

-   返回类型和参数类型都使用 def

-   它使得可以使用 String 的方法

-   但也可以使用 int ，因为定义了 plus 方法

建议在适用于任何类型的方法上使用 def 关键字，但从技术上讲，我们可以使用 Object 代替，结果是相同的：**在 Groovy 中， def 严格等同于使用 Object** 。

最后, 可以从返回类型和描述符中完全删除该类型。但是，如果您想从返回类型中删除它，则需要为该方法添加显式修饰符，以便编译器可以区分方法声明和方法调用，如下例所示：

    private concat(a,b) {                                   
        a+b
    }
    assert concat('foo','bar') == 'foobar'                  
    assert concat(1,2) == 3                                 

-   如果我们想省略返回类型，则必须设置显式修饰符。

-   仍然可以使用 String 的方法

-   还有 int

在公共 API 的方法参数或方法返回类型中，省略类型通常被认为是一种不好的做法。虽然在局部变量中使用 def 并不是真正的问题，因为变量的可见性仅限于方法本身，而在方法参数上设置时， def 将转换为 \< b2\> 出现在方法签名中，使得用户很难知道参数的预期类型。这意味着您应该将此限制于明确依赖鸭子类型的情况。

## 静态类型检查

默认情况下，Groovy 在编译时执行最少的类型检查. 由于它主要是一种动态语言，因此在编译期执行常规编译器都会执行的检查是不可能的. 通过运行时元编程添加的方法可能会改变类或对象的运行时行为。让我们在下面的例子中说明原因：

    class Person {                                                          
        String firstName
        String lastName
    }
    def p = new Person(firstName: 'Raymond', lastName: 'Devos')             
    assert p.formattedName == 'Raymond Devos'                               

-   Person 类仅定义两个属性， firstName 和 lastName

-   我们可以创建一个 Person 的实例

-   并调用名为 formattedName 的方法

在动态语言中，像上面的示例这样的代码不抛出任何错误是很常见的。怎么会这样？在 Java 中，这通常会在编译时失败。然而，在 Groovy 中，它不会在编译时失败，也不会在运行时失败。事实上，要使其在运行时工作，一种可能性是依赖运行时元编程。因此，只需在 Person 类的声明之后添加这一行就足够了：

    Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }

这意味着一般来说，在 Groovy 中，您不能对对象的声明类型之外的类型做出任何假设，即使您知道它，您也无法在编译时确定将调用哪个方法。从编写 DSL 到测试，它引起了很多兴趣，这将在本手册的其他部分中讨论。

然而，如果您的程序不依赖于动态功能，并且您来自静态世界（特别是来自 Java 思维方式），那么在编译时没有捕获此类"错误"可能会令人惊讶。正如我们在前面的示例中所看到的，编译器无法确定这是一个错误。为了让它意识到这一点，您必须显式指示编译器您正在切换到类型检查模式。这可以通过使用 \@groovy.transform.TypeChecked 注释类或方法来完成。

当类型检查被激活时，编译器会执行更多的工作：

-   类型推断被激活，这意味着即使您在局部变量上使用 def ，类型检查器也将能够从赋值中推断变量的类型

-   方法调用在编译时解析，这意味着如果未在类上声明方法，编译器将抛出错误

-   一般来说，你习惯在静态语言中查找的所有编译时错误都会出现：找不到方法、找不到属性、方法调用的类型不兼容、数字精度错误......

在本节中，我们将描述类型检查器在各种情况下的行为，并描述 \@TypeChecked 的限制。

### \@TypeChecked 注释

#### 在编译时激活类型检查

groovy.transform.TypeChecked 注释启用类型检查。它可以放在一个类中：

    @groovy.transform.TypeChecked
    class Calculator {
        int sum(int x, int y) { x+y }
    }

或者在一个方法上：

    class Calculator {
        @groovy.transform.TypeChecked
        int sum(int x, int y) { x+y }
    }

在第一种情况下，注释类的所有方法、属性、字段、内部类等都将进行类型检查，而在第二种情况下，只有方法和它包含的潜在闭包或匿名内部类将进行类型检查。

#### 跳过类型检查

类型检查的范围可以受到限制。例如，如果一个类经过类型检查，您可以通过使用 \@TypeChecked(TypeCheckingMode.SKIP) 注释来指示类型检查器跳过该方法：

    import groovy.transform.TypeChecked
    import groovy.transform.TypeCheckingMode
    
    @TypeChecked                                        
    class GreetingService {
        String greeting() {                             
            doGreet()
        }
    
        @TypeChecked(TypeCheckingMode.SKIP)             
        private String doGreet() {
            def b = new SentenceBuilder()
            b.Hello.my.name.is.John                     
            b
        }
    }
    def s = new GreetingService()
    assert s.greeting() == 'Hello my name is John'

-   GreetingService 类被标记为类型检查

-   所以 greeting 方法会自动进行类型检查

-   但 doGreet 被标记为 SKIP

-   类型检查器不会抱怨这里缺少属性

在前面的示例中， SentenceBuilder 依赖于动态代码。没有真正的 Hello 方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法标记有 TypeCheckingMode.SKIP ，因此会跳过此方法的类型检查，因此即使类的其余部分经过类型检查，代码也会编译。

以下部分描述了 Groovy 中类型检查的语义。

### 类型检查赋值

当且仅当满足以下条件时， A 类型的对象 o 才可以分配给 T 类型的变量：

-   `T` equals `A`

```{=html}
<!-- -->
```
-   Date now = new Date()

```{=html}
<!-- -->
```
-   或 T 是 String 、 boolean 、 Boolean 或 Class 之一

```{=html}
<!-- -->
```
-   String s = new Date() // implicit call to toString
        Boolean boxed = 'some string'       // Groovy truth
        boolean prim = 'some string'        // Groovy truth
        Class clazz = 'java.lang.String'    // class coercion

\*或 o 为 null 并且 T 是引用类型

\+

    String s = null         // passes
    int i = null            // fails

-   或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型

```{=html}
<!-- -->
```
-   int[] i = new int[4]        // passes
        int[] i = new String[4]     // fails

```{=html}
<!-- -->
```
-   或 T 是一个数组， A 是一个collection或stream，并且 A 的元素类型可分配给 T 的元素类型

```{=html}
<!-- -->
```
-   int[] i = [1,2,3]               // passes
        int[] i = [1,2, new Date()]     // fails
        Set set = [1,2,3]
        Number[] na = set               // passes
        def stream = Arrays.stream(1,2,3)
        int[] i = stream                // passes

```{=html}
<!-- -->
```
-   或者 T 是 A 的父类

```{=html}
<!-- -->
```
-   AbstractList list = new ArrayList()     // passes
        LinkedList list = new ArrayList()       // fails

```{=html}
<!-- -->
```
-   或者 T 是 A 实现的接口

```{=html}
<!-- -->
```
-   List list = new ArrayList()             // passes
        RandomAccess list = new LinkedList()    // fails

```{=html}
<!-- -->
```
-   或 T 或 A 是原始类型，它们的装箱类型是可分配的

```{=html}
<!-- -->
```
-   int i = 0
        Integer bi = 1
        int x = Integer.valueOf(123)
        double d = Float.valueOf(5f)

```{=html}
<!-- -->
```
-   或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）

```{=html}
<!-- -->
```
-   Runnable r = { println 'Hello' }
        interface SAMType {
            int doSomething()
        }
        SAMType sam = { 123 }
        assert sam.doSomething() == 123
        abstract class AbstractSAM {
            int calc() { 2* value() }
            abstract int value()
        }
        AbstractSAM c = { 123 }
        assert c.calc() == 246

```{=html}
<!-- -->
```
-   或 T 和 A 派生自 java.lang.Number 并符合下表

Number types (java.lang.XXX)

+-----------------+---------------------------------------------------------------------+-----------------------------------+
| T               | A                                                                   | Examples                          |
+=================+=====================================================================+===================================+
| Double          | Any but BigDecimal or BigInteger                                    |     Double d1 = 4d                |
|                 |                                                                     |     Double d2 = 4f                |
|                 |                                                                     |     Double d3 = 4l                |
|                 |                                                                     |     Double d4 = 4i                |
|                 |                                                                     |     Double d5 = (short) 4         |
|                 |                                                                     |     Double d6 = (byte) 4          |
+-----------------+---------------------------------------------------------------------+-----------------------------------+
| Float           | Any type but BigDecimal, BigInteger or Double                       |     Float f1 = 4f                 |
|                 |                                                                     |     Float f2 = 4l                 |
|                 |                                                                     |     Float f3 = 4i                 |
|                 |                                                                     |     Float f4 = (short) 4          |
|                 |                                                                     |     Float f5 = (byte) 4           |
+-----------------+---------------------------------------------------------------------+-----------------------------------+
| Long            | Any type but BigDecimal, BigInteger, Double or Float                |     Long l1 = 4l                  |
|                 |                                                                     |     Long l2 = 4i                  |
|                 |                                                                     |     Long l3 = (short) 4           |
|                 |                                                                     |     Long l4 = (byte) 4            |
+-----------------+---------------------------------------------------------------------+-----------------------------------+
| Integer         | Any type but BigDecimal, BigInteger, Double, Float or Long          |     Integer i1 = 4i               |
|                 |                                                                     |     Integer i2 = (short) 4        |
|                 |                                                                     |     Integer i3 = (byte) 4         |
+-----------------+---------------------------------------------------------------------+-----------------------------------+
| Short           | Any type but BigDecimal, BigInteger, Double, Float, Long or Integer |     Short s1 = (short) 4          |
|                 |                                                                     |     Short s2 = (byte) 4           |
+-----------------+---------------------------------------------------------------------+-----------------------------------+
| Byte            | Byte                                                                |     Byte b1 = (byte) 4            |
+-----------------+---------------------------------------------------------------------+-----------------------------------+

: Number types (java.lang.XXX)

### List 和 map 构造器

可以将List字面量或Map字面量 A 赋值给 T 类型的变量，前提是：

-   A 是一个List字面量， T 有一个构造函数，其参数与List字面量中元素的类型匹配

-   A 是一个Map字面量， T 有一个无参数构造函数, 并且对于 `Map` 中的每个key, 都有一个与之对应的属性

例如，如下：

    @groovy.transform.TupleConstructor
    class Person {
        String firstName
        String lastName
    }
    Person classic = new Person('Ada','Lovelace')

您可以使用 "list constructor" ：

    Person list = ['Ada','Lovelace']

或者 \"map constructor\":

    Person map = [firstName:'Ada', lastName:'Lovelace']

如果您使用 map 构造函数，则会对map的键进行额外检查，以检查是否定义了同名的属性。例如，以下内容将在编译时失败：

    @groovy.transform.TupleConstructor
    class Person {
        String firstName
        String lastName
    }
    Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]     

-   类型检查器将在编译时抛出错误 No such property: age for class: Person

### 方法检查

在类型检查模式下，方法在编译时解析。解析通过名称和参数进行。返回类型与方法选择无关。入参和出参按照以下规则进行匹配：

当且仅当满足以下条件时， A 类型的实参 o 才可用于 T 类型的形参：

-   `T` equals `A`

```{=html}
<!-- -->
```
-   int sum(int x, int y) {
            x+y
        }
        assert sum(3,4) == 7

```{=html}
<!-- -->
```
-   或 T 是 String ， A 是 GString

```{=html}
<!-- -->
```
-   String format(String str) {
            "Result: $str"
        }
        assert format("${3+4}") == "Result: 7"

```{=html}
<!-- -->
```
-   或 o 为 null 并且 T 是引用类型

```{=html}
<!-- -->
```
-   String format(int value) {
            "Result: $value"
        }
        assert format(7) == "Result: 7"
        format(null)           // fails

```{=html}
<!-- -->
```
-   或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型

```{=html}
<!-- -->
```
-   String format(String[] values) {
            "Result: ${values.join(' ')}"
        }
        assert format(['a','b'] as String[]) == "Result: a b"
        format([1,2] as int[])              // fails

```{=html}
<!-- -->
```
-   或者 T 是 A 的父类

```{=html}
<!-- -->
```
-   String format(AbstractList list) {
            list.join(',')
        }
        format(new ArrayList())              // passes
        String format(LinkedList list) {
            list.join(',')
        }
        format(new ArrayList())              // fails

```{=html}
<!-- -->
```
-   或者 T 是 A 实现的接口

```{=html}
<!-- -->
```
-   String format(List list) {
            list.join(',')
        }
        format(new ArrayList())                  // passes
        String format(RandomAccess list) {
            'foo'
        }
        format(new LinkedList())                 // fails

```{=html}
<!-- -->
```
-   或 T 或 A 是原始类型，它们的包装类型是可分配的

```{=html}
<!-- -->
```
-   int sum(int x, Integer y) {
            x+y
        }
        assert sum(3, new Integer(4)) == 7
        assert sum(new Integer(3), 4) == 7
        assert sum(new Integer(3), new Integer(4)) == 7
        assert sum(new Integer(3), 4) == 7

```{=html}
<!-- -->
```
-   或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）

```{=html}
<!-- -->
```
-   interface SAMType {
            int doSomething()
        }
        int twice(SAMType sam) { 2*sam.doSomething() }
        assert twice { 123 } == 246
        abstract class AbstractSAM {
            int calc() { 2* value() }
            abstract int value()
        }
        int eightTimes(AbstractSAM sam) { 4*sam.calc() }
        assert eightTimes { 123 } == 984

```{=html}
<!-- -->
```
-   或 T 和 A 派生自 java.lang.Number 并符合与[数字赋值](#number-assignment)相同的规则

如果在编译时未找到具有适当名称和参数的方法，则会引发错误。以下示例说明了与"正常"Groovy 的区别：

    class MyService {
        void doSomething() {
            printLine 'Do something'            
        }
    }

-   printLine 是一个错误，但由于我们处于动态模式，因此在编译时不会捕获该错误

上面的示例Groovy能够正常编译。但是，如果您尝试创建 MyService 的实例并调用 doSomething 方法，那么它将在运行时失败，因为 printLine 不存在。当然，我们已经展示了 Groovy 如何使其成为完全有效的调用，例如通过捕获 MethodMissingException 或实现自定义元类，但如果您知道自己不属于这种情况， 可以使用 \@TypeChecked 来开启检查

    @groovy.transform.TypeChecked
    class MyService {
        void doSomething() {
            printLine 'Do something'            
        }
    }

-   printLine 这次是编译时错误

只需添加 \@TypeChecked 将触发编译时方法解析。类型检查器将尝试在 MyService 类上查找接受 String 的方法 printLine ，但找不到。编译将失败并显示以下消息：

`Cannot find matching method MyService#printLine(java.lang.String)`

了解类型检查器背后的逻辑很重要：它是编译时检查，因此根据定义，类型检查器不知道您所做的任何类型的运行时元编程。这意味着如果您激活类型检查，任何在关闭类型检查时正常编译的代码都可能编译失败。如果您想到鸭子类型，则尤其如此：

    class Duck {
        void quack() {              
            println 'Quack!'
        }
    }
    class QuackingBird {
        void quack() {              
            println 'Quack!'
        }
    }
    @groovy.transform.TypeChecked
    void accept(quacker) {
        quacker.quack()             
    }
    accept(new Duck())              

-   我们定义一个 Duck 类，它定义一个 quack 方法

-   我们定义了另一个 QuackingBird 类，它也定义了 quack 方法

-   quacker 是松散类型的，由于该方法是 \@TypeChecked ，我们将获得编译时错误

-   但在没有类型检查的Groovy中, 这会通过

有可能的解决方法，例如引入接口，但基本上，通过激活类型检查，您可以获得类型安全，但会失去该语言的一些功能。幸运的是 Groovy 引入一些功能，例如流类型，以缩小类型检查和非类型检查 Groovy 之间的差距。

### 类型推断

#### 原则

当代码用 \@TypeChecked 注释时，编译器会执行类型推断。它不仅仅依赖于静态类型，还使用各种技术来推断变量的类型、返回类型、字面量......，以便即使您激活类型检查器，代码也尽可能保持干净。

最简单的例子是推断变量的类型：

    def message = 'Welcome to Groovy!'              
    println message.toUpperCase()                   
    println message.upper() // compile time error   

-   使用 def 关键字声明变量

-   类型检查器允许调用 toUpperCase

-   调用 upper 将在编译时失败

对 toUpperCase 的调用有效的原因是 message 的类型被推断为 String 。

#### 类型推断中的变量和字段

值得注意的是，虽然编译器对局部变量执行类型推断，但它不会对字段执行任何类型的推断，总是回退到字段的声明类型。为了说明这一点，让我们看一下这个例子：

    class SomeClass {
        def someUntypedField                                                                
        String someTypedField                                                               
    
        void someMethod() {
            someUntypedField = '123'                                                        
            someUntypedField = someUntypedField.toUpperCase()  // compile-time error        
        }
    
        void someSafeMethod() {
            someTypedField = '123'                                                          
            someTypedField = someTypedField.toUpperCase()                                   
        }
    
        void someMethodUsingLocalVariable() {
            def localVariable = '123'                                                       
            someUntypedField = localVariable.toUpperCase()                                  
        }
    }

-   someUntypedField 使用 def 作为声明类型

-   someTypedField 使用 String 作为声明类型

-   我们可以将任何内容分配给 someUntypedField

-   但调用 toUpperCase 在编译时失败，因为该字段没有类型

-   我们可以将 String 分配给 String 类型的字段

-   这次允许 toUpperCase

-   如果我们将 String 分配给局部变量

-   允许在局部变量上调用 toUpperCase(因为会类型推断)

为什么会有这样的差异？原因是线程安全。在编译时，我们无法对字段的类型做出任何保证。任何线程都可以随时访问任何字段，并且在方法中为字段分配某种类型的变量的那一刻和之后使用该行的时间之间，另一个线程可能已经更改了该字段的内容。局部变量的情况并非如此：我们知道它们是否"转义"，因此我们可以确保变量的类型随着时间的推移保持不变（或不变）。请注意，即使字段是最终字段，JVM 也不对其做出保证，因此无论字段是否为最终字段，类型检查器的行为都不会有所不同。

这就是我们建议使用类型化字段的原因之一。虽然由于类型推断，对局部变量使用 def 是完全没问题的，但字段的情况并非如此，字段也属于类的公共 API，因此类型很重要。

#### 集合字面量类型推断

Groovy 提供了各种类型字面量的语法。 Groovy 中有集合字面量：

-   lists, using the `[]` literal

-   maps, using the `[:]` literal

-   range，使用 from..to （包含）、 from..\<to （右排除）、 from\<..to （左排除）和 from\<..\<to （完全排除）

字面量的推断类型取决于字面量的元素，如下表所示：

+-------------------------------------------+----------------------------------------------------------------------------------------------------+
| Literal                                   | Inferred type                                                                                      |
+===========================================+====================================================================================================+
|     def list = []                         | `java.util.List`                                                                                   |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def list = ['foo','bar']              | `java.util.List<String>`                                                                           |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def list = ["${foo}","${bar}"]        | `java.util.List<GString>` be careful, a `GString` is **not** a `String`!                           |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def map = [:]                         | `java.util.LinkedHashMap`                                                                          |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def map1 = [someKey: 'someValue']     | `java.util.LinkedHashMap<String,String>`                                                           |
|     def map2 = ['someKey': 'someValue']   |                                                                                                    |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def map = ["${someKey}": 'someValue'] | `java.util.LinkedHashMap<GString,String>` be careful, the key is a `GString`!                      |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def intRange = (0..10)                | `groovy.lang.IntRange`                                                                             |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+
|     def charRange = ('a'..'z')            | `groovy.lang.Range<String>` : uses the type of the bounds to infer the component type of the range |
+-------------------------------------------+----------------------------------------------------------------------------------------------------+

正如您所看到的，除了 IntRange 明显的例外，推断类型使用泛型来描述集合的内容。如果集合包含不同类型的元素，类型检查器仍然执行元素的类型推断，但使用[最小上限](#section-lub)的概念。

#### 最小上限

在 Groovy 中， A 和 B 两种类型的最小上限被定义为以下类型：

-   A 和 B 的公共超类

-   A 和 B 实现的共同接口

-   如果 A 或 B 是原始类型并且 A 不等于 B ，则 A 和 B 是其包装类型的最小上限

如果 A 和 B 只有一 (1) 个公共接口，并且它们的公共超类是 Object ，那么两者的 LUB 就是公共接口。

最小上限表示可以分配 A 和 B 的最小类型。例如，如果 A 和 B 都是 String ，那么两者的 LUB（最小上限）也是 String 。

    class Top {}
    class Bottom1 extends Top {}
    class Bottom2 extends Top {}
    
    assert leastUpperBound(String, String) == String                    
    assert leastUpperBound(ArrayList, LinkedList) == AbstractList       
    assert leastUpperBound(ArrayList, List) == List                     
    assert leastUpperBound(List, List) == List                          
    assert leastUpperBound(Bottom1, Bottom2) == Top                     
    assert leastUpperBound(List, Serializable) == Object                

-   String 和 String 的LUB是 String

-   ArrayList 和 LinkedList 的 LUB 是它们共同的超类型， AbstractList

-   ArrayList 和 List 的LUB是它们唯一的公共接口， List

-   两个相同接口的LUB就是接口本身

-   Bottom1 和 Bottom2 的 LUB 是它们的超类 Top

-   两种没有共同点的类型的LUB是 Object

在这些示例中，LUB 始终可表示为普通的、JVM 支持的类型。但 Groovy 在内部将 LUB 表示为一种可能更复杂的类型，并且您无法使用它来定义变量。为了说明这一点，让我们继续这个例子：

    interface Foo {}
    class Top {}
    class Bottom extends Top implements Serializable, Foo {}
    class SerializableFooImpl implements Serializable, Foo {}

Bottom 和 SerializableFooImpl 的最小上限是多少？它们没有共同的超类（除了 Object ），但它们共享 2 个接口（ Serializable 和 Foo ），因此它们的最小上限是表示两个接口（ Serializable 和 Foo ）的联合的类型。这种类型无法在源代码中定义，但 Groovy 知道它。

在集合类型推断（以及一般的泛型类型推断）的上下文中，这变得很方便，因为组件的类型被推断为最小上限。我们可以在以下示例中说明为什么这很重要：

    interface Greeter { void greet() }                  
    interface Salute { void salute() }                  
    
    class A implements Greeter, Salute {                
        void greet() { println "Hello, I'm A!" }
        void salute() { println "Bye from A!" }
    }
    class B implements Greeter, Salute {                
        void greet() { println "Hello, I'm B!" }
        void salute() { println "Bye from B!" }
        void exit() { println 'No way!' }               
    }
    def list = [new A(), new B()]                       
    list.each {
        it.greet()                                      
        it.salute()                                     
        it.exit()                                       
    }

-   Greeter 接口定义了一个方法， greet

-   Salute 接口定义了一个方法， salute

-   类 A 实现了 Greeter 和 Salute

-   与 B 相同

-   但 B 定义了一个额外的 exit 方法

-   list 的类型被推断为" A 和 `B` 的 LUB 列表"

-   因此可以通过 Greeter 接口调用 A 和 B 上定义的 greet

-   并且可以通过 Salute 接口调用 A 和 B 上定义的 salute

-   然而调用 exit 是一个编译时错误，因为它不属于 A 和 B 的LUB（仅在 B 中定义） ）

错误消息将如下所示：

    [Static type checking] - Cannot find matching method Greeter or Salute#exit()

这表明 exit 方法既没有定义在 Greeter 上，也没有定义在 Salute 上，这两个接口定义在 A 和 B 。

#### instanceof

在正常的、非类型检查的 Groovy 中，您可以编写如下内容：

    class Greeter {
        String greeting() { 'Hello' }
    }
    
    void doSomething(def o) {
        if (o instanceof Greeter) {     
            println o.greeting()        
        }
    }
    
    doSomething(new Greeter())

-   使用 instanceof 来保护方法调用

-   调用

该方法调用之所以有效，是因为动态调度（该方法是在运行时选择的）。 Java 中的等效代码需要在调用 greeting 方法之前将 o 转换为 Greeter ，因为方法是在编译时选择的：

    if (o instanceof Greeter) {
        System.out.println(((Greeter)o).greeting());
    }

然而，在 Groovy 中，即使您在 doSomething 方法上添加 \@TypeChecked （从而激活类型检查），也不需要强制转换。编译器嵌入了instanceof 推理，使强制转换成为可选的。

#### 流类型

流类型是 Groovy 类型检查模式中的一个重要概念，也是类型推断的扩展。这个想法是编译器能够推断代码流中变量的类型，而不仅仅是在初始化时：

    @groovy.transform.TypeChecked
    void flowTyping() {
        def o = 'foo'                       
        o = o.toUpperCase()                 
        o = 9d                              
        o = Math.sqrt(o)                    
    }

-   首先，使用 def 声明 o 并分配一个 String

-   编译器推断 o 是 String ，因此允许调用 toUpperCase

-   o 被重新分配为 double

-   调用 Math.sqrt 通过编译，因为编译器知道此时 o 是 double

因此类型检查器知道变量的具体类型随着时间的推移而变化。特别是，如果您将最后一个分配替换为：

    o = 9d
    o = o.toUpperCase()

现在，类型检查器将在编译时失败，因为当调用 toUpperCase 时，它知道 o 是 double ，因此这是一个类型错误。

It is important to understand that it is not the fact of declaring a variable with `def` that triggers type inference. 流类型适用于任何类型的任何变量。使用显式类型声明变量只会限制可以分配给该变量的内容：

    @groovy.transform.TypeChecked
    void flowTypingWithExplicitType() {
        List list = ['a','b','c']           
        list = list*.toUpperCase()          
        list = 'foo'                        
    }

-   list 被声明为未经检查的 List 并分配了一个"String"列表文字

-   由于流类型，该行通过了编译：类型检查器知道 list 此时是 List\<String\>

-   但你不能将 String 分配给 List 所以这是一个类型检查错误

您还可以注意到，即使声明变量时没有泛型信息，类型检查器也知道组件类型是什么。因此，这样的代码将编译失败：

    @groovy.transform.TypeChecked
    void flowTypingWithExplicitType() {
        List list = ['a','b','c']           
        list.add(1)                         
    }

-   list 被推断为 List\<String\>

-   因此将 int 添加到 List\<String\> 是一个编译时错误

修复此问题需要在声明中添加显式泛型类型：

    @groovy.transform.TypeChecked
    void flowTypingWithExplicitType() {
        List<? extends Serializable> list = []                      
        list.addAll(['a','b','c'])                                  
        list.add(1)                                                 
    }

-   list 声明为 List\<? extends Serializable\> 并用空列表初始化

-   添加到列表中的元素符合列表的声明类型

-   因此允许将 int 添加到 List\<? extends Serializable\>

引入流类型是为了减少经典 Groovy 和静态 Groovy 之间的语义差异。特别是考虑一下 Java 中这段代码的行为：

    public Integer compute(String str) {
        return str.length();
    }
    public String compute(Object o) {
        return "Nope";
    }
    // ...
    Object string = "Some string";          
    Object result = compute(string);        
    System.out.println(result);             

-   o 被声明为 Object 并分配了 String

-   我们用 o 调用 compute 方法

-   并打印结果

在 Java 中，此代码将输出 Nope ，因为方法选择是在编译时基于声明的类型完成的。因此，即使 o 在运行时是 String ，它仍然是调用的 Object 版本，因为 o 已被声明为一个 Object 。简而言之，在Java中，声明类型是最重要的，无论是变量类型、参数类型还是返回类型。

在 Groovy 中，我们可以这样写：

    int compute(String string) { string.length() }
    String compute(Object o) { "Nope" }
    Object o = 'string'
    def result = compute(o)
    println result

但这一次，它将返回 6 ，因为该方法是在运行时根据实际参数类型选择的。因此在运行时， o 是 String ，因此使用 String 变体。请注意，此行为与类型检查无关，这是 Groovy 一般的工作方式：动态调度。

In type checked Groovy, we want to make sure the type checker selects the same method **at compile time**, that the runtime would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow typing. With flow typing, `o` is *inferred* as a `String` when the `compute` method is called, so the version which takes a `String` and returns an `int` is chosen. This means that we can infer the return type of the method to be an `int`, and not a `String`. This is important for subsequent calls and type safety.

So in type checked Groovy, flow typing is a very important concept, which also implies that if `@TypeChecked` is applied, methods are selected based on the *inferred types* of the arguments, not on the declared types. This doesn't ensure 100% type safety, because the type checker *may* select a wrong method, but it ensures the closest semantics to dynamic Groovy.

#### 高级类型推断

使用[流类型](#section-flow-typing)和[最小上限推断](#section-lub)的组合来执行高级类型推理并确保多种情况下的类型安全。特别是，程序控制结构可能会改变变量的推断类型：

    class Top {
       void methodFromTop() {}
    }
    class Bottom extends Top {
       void methodFromBottom() {}
    }
    def o
    if (someCondition) {
        o = new Top()                               
    } else {
        o = new Bottom()                            
    }
    o.methodFromTop()                               
    o.methodFromBottom()  // compilation error      

-   如果 someCondition 为 true，则为 o 分配 Top

-   如果 someCondition 为 false，则为 o 分配 Bottom

-   调用 methodFromTop 是安全的

-   但调用 methodFromBottom 则不然，所以这是一个编译时错误

When the type checker visits an `if/else` control structure, it checks all variables which are assigned in `if/else` branches and computes the [least upper bound](#section-lub) of all assignments. This type is the type of the inferred variable after the `if/else` block, so in this example, `o` is assigned a `Top` in the `if` branch and a `Bottom` in the `else` branch. The [LUB](#section-lub) of those is a `Top`, so after the conditional branches, the compiler infers `o` as being a `Top`. Calling `methodFromTop` will therefore be allowed, but not `methodFromBottom`.

The same reasoning exists with closures and in particular closure shared variables. A closure shared variable is a variable which is defined outside of a closure, but used inside a closure, as in this example:

    def text = 'Hello, world!'                          
    def closure = {
        println text                                    
    }

-   a variable named `text` is declared

-   `text` is used from inside a closure. It is a *closure shared variable*.

Groovy allows developers to use those variables without requiring them to be final. This means that a closure shared variable can be reassigned inside a closure:

    String result
    doSomething { String it ->
        result = "Result: $it"
    }
    result = result?.toUpperCase()

The problem is that a closure is an independent block of code that can be executed (or not) at **any** time. In particular, `doSomething` may be asynchronous, for example. This means that the body of a closure doesn't belong to the main control flow. For that reason, the type checker also computes, for each closure shared variable, the [LUB](#section-lub) of all assignments of the variable, and will use that `LUB` as the inferred type outside of the scope of the closure, like in this example:

    class Top {
       void methodFromTop() {}
    }
    class Bottom extends Top {
       void methodFromBottom() {}
    }
    def o = new Top()                               
    Thread.start {
        o = new Bottom()                            
    }
    o.methodFromTop()                               
    o.methodFromBottom()  // compilation error      

-   a closure-shared variable is first assigned a `Top`

-   inside the closure, it is assigned a `Bottom`

-   `methodFromTop` is allowed

-   `methodFromBottom` is a compilation error

Here, it is clear that when `methodFromBottom` is called, there's no guarantee, at compile-time or runtime that the type of `o` will *effectively* be a `Bottom`. There are chances that it will be, but we can't make sure, because it's asynchronous. So the type checker will only allow calls on the [least upper bound](#section-lub), which is here a `Top`.

### Closures and type inference

The type checker performs special inference on closures, resulting on additional checks on one side and improved fluency on the other side.

#### Return type inference

The first thing that the type checker is capable of doing is inferring the *return type* of a closure. This is simply illustrated in the following example:

    @groovy.transform.TypeChecked
    int testClosureReturnTypeInference(String arg) {
        def cl = { "Arg: $arg" }                                
        def val = cl()                                          
    
        val.length()                                            
    }

-   a closure is defined, and it returns a string (more precisely a `GString`)

-   we call the closure and assign the result to a variable

-   the type checker inferred that the closure would return a string, so calling `length()` is allowed

As you can see, unlike a method which declares its return type explicitly, there's no need to declare the return type of a closure: its type is inferred from the body of the closure.

It's worth noting that return type inference is only applicable to closures. While the type checker could do the same on a method, it is in practice not desirable: *in general*, methods can be overridden and it is not statically possible to make sure that the method which is called is not an overridden version. So flow typing would actually think that a method returns something, while in reality, it could return something else, like illustrated in the following example:

    @TypeChecked
    class A {
        def compute() { 'some string' }             
        def computeFully() {
            compute().toUpperCase()                 
        }
    }
    @TypeChecked
    class B extends A {
        def compute() { 123 }                       
    }

-   class `A` defines a method `compute` which effectively returns a `String`

-   this will fail compilation because the return type of `compute` is `def`(aka `Object`)

-   class `B` extends `A` and redefines `compute`, this type returning an `int`

As you can see, if the type checker relied on the inferred return type of a method, with [flow typing](#section-flow-typing), the type checker could determine that it is ok to call `toUpperCase`. It is in fact an **error**, because a subclass can override `compute` and return a different object. Here, `B#compute` returns an `int`, so someone calling `computeFully` on an instance of `B` would see a runtime error. The compiler prevents this from happening by using the declared return type of methods instead of the inferred return type.

For consistency, this behavior is the same for **every** method, even if they are static or final.

#### Parameter type inference

In addition to the return type, it is possible for a closure to infer its parameter types from the context. There are two ways for the compiler to infer the parameter types:

-   through *implicit SAM type coercion*

-   through API metadata

To illustrate this, lets start with an example that will fail compilation due to the inability for the type checker to infer the parameter types:

    class Person {
        String name
        int age
    }
    
    void inviteIf(Person p, Closure<Boolean> predicate) {           
        if (predicate.call(p)) {
            // send invite
            // ...
        }
    }
    
    @groovy.transform.TypeChecked
    void failCompilation() {
        Person p = new Person(name: 'Gerard', age: 55)
        inviteIf(p) {                                               
            it.age >= 18 // No such property: age                   
        }
    }

-   the `inviteIf` method accepts a `Person` and a `Closure`

-   we call it with a `Person` and a `Closure`

-   yet `it` is not statically known as being a `Person` and compilation fails

In this example, the closure body contains `it.age`. With dynamic, not type checked code, this would work, because the type of `it` would be a `Person` at runtime. Unfortunately, at compile-time, there's no way to know what is the type of `it`, just by reading the signature of `inviteIf`.

##### Explicit closure parameters

To be short, the type checker doesn't have enough contextual information on the `inviteIf` method to determine statically the type of `it`. This means that the method call needs to be rewritten like this:

    inviteIf(p) { Person it ->                                  
        it.age >= 18
    }

-   the type of `it` needs to be declared explicitly

By explicitly declaring the type of the `it` variable, you can work around the problem and make this code statically checked.

##### Parameters inferred from single-abstract method types

For an API or framework designer, there are two ways to make this more elegant for users, so that they don't have to declare an explicit type for the closure parameters. The first one, and easiest, is to replace the closure with a SAM type:

    interface Predicate<On> { boolean apply(On e) }                 
    
    void inviteIf(Person p, Predicate<Person> predicate) {          
        if (predicate.apply(p)) {
            // send invite
            // ...
        }
    }
    
    @groovy.transform.TypeChecked
    void passesCompilation() {
        Person p = new Person(name: 'Gerard', age: 55)
    
        inviteIf(p) {                                               
            it.age >= 18                                            
        }
    }

-   declare a `SAM` interface with an `apply` method

-   `inviteIf` now uses a `Predicate<Person>` instead of a `Closure<Boolean>`

-   there's no need to declare the type of the `it` variable anymore

-   `it.age` compiles properly, the type of `it` is inferred from the `Predicate#apply` method signature

By using this technique, we leverage the *automatic coercion of closures to SAM types* feature of Groovy. Whether you should use a *SAM type* or a *Closure* really depends on what you need to do. In a lot of cases, using a SAM interface is enough, especially if you consider functional interfaces as they are found in Java 8. However, closures provide features that are not accessible to functional interfaces. In particular, closures can have a delegate, and owner and can be manipulated as objects (for example, cloned, serialized, curried, ...​) before being called. They can also support multiple signatures (polymorphism). So if you need that kind of manipulation, it is preferable to switch to the most advanced type inference annotations which are described below.

The original issue that needs to be solved when it comes to closure parameter type inference, that is to say, statically determining the types of the arguments of a closure *without* having to have them explicitly declared, is that the Groovy type system inherits the Java type system, which is insufficient to describe the types of the arguments.

##### The `@ClosureParams` annotation

Groovy provides an annotation, `@ClosureParams` which is aimed at completing type information. This annotation is primarily aimed at framework and API developers who want to extend the capabilities of the type checker by providing type inference metadata. This is important if your library makes use of closures and that you want the maximum level of tooling support too.

Let's illustrate this by fixing the original example, introducing the `@ClosureParams` annotation:

    import groovy.transform.stc.ClosureParams
    import groovy.transform.stc.FirstParam
    void inviteIf(Person p, @ClosureParams(FirstParam) Closure<Boolean> predicate) {        
        if (predicate.call(p)) {
            // send invite
            // ...
        }
    }
    inviteIf(p) {                                                                       
        it.age >= 18
    }

-   the closure parameter is annotated with `@ClosureParams`

-   it's not necessary to use an explicit type for `it`, which is inferred

The `@ClosureParams` annotation minimally accepts one argument, which is named a *type hint*. A type hint is a class which is responsible for completing type information at compile time for the closure. In this example, the type hint being used is `groovy.transform.stc.FirstParam` which indicated to the type checker that the closure will accept one parameter whose type is the type of the first parameter of the method. In this case, the first parameter of the method is `Person`, so it indicates to the type checker that the first parameter of the closure is in fact a `Person`.

A second optional argument is named *options*. Its semantics depend on the *type hint* class. Groovy comes with various bundled type hints, illustrated in the table below:

Predefined type hints

+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Type hint                       | Polymorphic? | Description and examples                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
+=================================+==============+=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+
| `FirstParam`\                   | No           | The first (resp. second, third) parameter type of the method                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `SecondParam`\                  |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `ThirdParam`                    |              |     import groovy.transform.stc.FirstParam                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     void doSomething(String str, @ClosureParams(FirstParam) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         c(str)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething('foo') { println it.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                 |              |     import groovy.transform.stc.SecondParam                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                 |              |     void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                 |              |         c(31*str.hashCode()+seed)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     withHash('foo', (int)System.currentTimeMillis()) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                 |              |         int mod = it%2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     import groovy.transform.stc.ThirdParam                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |         "$prefix${c(o)}$postfix"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     assert format('foo', 'bar', 'baz') {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         it.toUpperCase()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |     } == 'fooBAZbar'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `FirstParam.FirstGenericType`\  | No           | The first generic type of the first (resp. second, third) parameter of the method                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `SecondParam.FirstGenericType`\ |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `ThirdParam.FirstGenericType`   |              |     import groovy.transform.stc.FirstParam                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     public <T> void doSomething(List<T> strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                 |              |         strings.each {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                 |              |             c(it)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                 |              |         }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething(['foo','bar']) { println it.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                 |              |     doSomething([1,2,3]) { println(2*it) }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | Variants for `SecondGenericType` and `ThirdGenericType` exist for all `FirstParam`, `SecondParam` and `ThirdParam` type hints.                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `SimpleType`                    | No           | A type hint for which the type of closure parameters comes from the options string.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.SimpleType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                 |              |         c('foo',3)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething { str, len ->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                 |              |         assert str.length() == len                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | This type hint supports a **single** signature and each of the parameter is specified as a value of the *options* array using a fully-qualified type name or a primitive type.                                                                                                                                                                                                                                                                                                                                                                                                              |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `MapEntryOrKeyValue`            | Yes          | A dedicated type hint for closures that either work on a `Map.Entry` single parameter, or two parameters corresponding to the key and the value.                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.MapEntryOrKeyValue                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |     public <K,V> void doSomething(Map<K,V> map, @ClosureParams(MapEntryOrKeyValue) Closure c) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |         // ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething([a: 'A']) { k,v ->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |         assert k.toUpperCase() == v.toUpperCase()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething([abc: 3]) { e ->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                 |              |         assert e.key.length() == e.value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | This type hint **requires** that the first argument is a `Map` type, and infers the closure parameter types from the map actual key/value types.                                                                                                                                                                                                                                                                                                                                                                                                                                            |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `FromAbstractTypeMethods`       | Yes          | Infers closure parameter types from the abstract method of some type. A signature is inferred for **each** abstract method.                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.FromAbstractTypeMethods                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                 |              |     abstract class Foo {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         abstract void firstSignature(int x, int y)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|                                 |              |         abstract void secondSignature(String str)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                                 |              |         // ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething { a, b -> a+b }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     doSomething { s -> s.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | If there are multiple signatures like in the example above, the type checker will **only** be able to infer the types of the arguments if the arity of each method is different. In the example above, `firstSignature` takes 2 arguments and `secondSignature` takes 1 argument, so the type checker can infer the argument types based on the number of arguments. But see the optional resolver class attribute discussed next.                                                                                                                                                          |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `FromString`                    | Yes          | Infers the closure parameter types from the `options` argument. The `options` argument consists of an array of comma-separated non-primitive types. Each element of the array corresponds to a single signature, and each comma in an element separate parameters of the signature. In short, this is the most generic type hint, and each string of the `options` map is **parsed** as if it was a signature literal. While being very powerful, this type hint must be avoided if you can because it increases the compilation times due to the necessity of parsing the type signatures. |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | A single signature for a closure accepting a `String`:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.FromString                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         // ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething { s -> s.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |     doSomething { s,i -> s.toUpperCase()*i }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | A polymorphic closure, accepting either a `String` or a `String, Integer`:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.FromString                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         // ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething { s -> s.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |     doSomething { s,i -> s.toUpperCase()*i }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              | A polymorphic closure, accepting either a `T` or a pair `T,T`:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     import groovy.transform.stc.FromString                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                 |              |     public <T> void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                 |              |         // ...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                 |              |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                 |              |     doSomething('foo') { s -> s.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                 |              |     doSomething('foo') { s1,s2 -> assert s1.toUpperCase() == s2.toUpperCase() }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
+---------------------------------+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: Predefined type hints

Even though you use `FirstParam`, `SecondParam` or `ThirdParam` as a type hint, it doesn't strictly mean that the argument which will be passed to the closure **will** be the first (resp. second, third) argument of the method call. It only means that the **type** of the parameter of the closure will be the **same** as the type of the first (resp. second, third) argument of the method call.

In short, the lack of the `@ClosureParams` annotation on a method accepting a `Closure` will **not** fail compilation. If present (and it can be present in Java sources as well as Groovy sources), then the type checker has **more** information and can perform additional type inference. This makes this feature particularly interesting for framework developers.

A third optional argument is named *conflictResolutionStrategy*. It can reference a class (extending from `ClosureSignatureConflictResolver`) that can perform additional resolution of parameter types if more than one are found after initial inference calculations are complete. Groovy comes with a default type resolver which does nothing, and another which selects the first signature if multiple are found. The resolver is only invoked if more than one signature is found and is by design a post processor. Any statements which need injected typing information must pass one of the parameter signatures determined through type hints. The resolver then picks among the returned candidate signatures.

#### `@DelegatesTo`

The `@DelegatesTo` annotation is used by the type checker to infer the type of the delegate. It allows the API designer to instruct the compiler what is the type of the delegate and the delegation strategy. The `@DelegatesTo` annotation is discussed in a [specific section](core-domain-specific-languages.html#section-delegatesto).

## Static compilation

### Dynamic vs static

In the [type checking section](#static-type-checking), we have seen that Groovy provides optional type checking thanks to the `@TypeChecked` annotation. The type checker runs at compile time and performs a static analysis of dynamic code. The program will behave exactly the same whether type checking has been enabled or not. This means that the `@TypeChecked` annotation is neutral in regard to the semantics of a program. Even though it may be necessary to add type information in the sources so that the program is considered type safe, in the end, the semantics of the program are the same.

While this may sound fine, there is actually one issue with this: type checking of dynamic code, done at compile time, is by definition only correct if no runtime specific behavior occurs. For example, the following program passes type checking:

    class Computer {
        int compute(String str) {
            str.length()
        }
        String compute(int x) {
            String.valueOf(x)
        }
    }
    
    @groovy.transform.TypeChecked
    void test() {
        def computer = new Computer()
        computer.with {
            assert compute(compute('foobar')) =='6'
        }
    }

There are two `compute` methods. One accepts a `String` and returns an `int`, the other accepts an `int` and returns a `String`. If you compile this, it is considered type safe: the inner `compute('foobar')` call will return an `int`, and calling `compute` on this `int` will in turn return a `String`.

Now, before calling `test()`, consider adding the following line:

    Computer.metaClass.compute = { String str -> new Date() }

Using runtime metaprogramming, we're actually modifying the behavior of the `compute(String)` method, so that instead of returning the length of the provided argument, it will return a `Date`. If you execute the program, it will fail at runtime. Since this line can be added from anywhere, in any thread, there's absolutely no way for the type checker to statically make sure that no such thing happens. In short, the type checker is vulnerable to monkey patching. This is just one example, but this illustrates the concept that doing static analysis of a dynamic program is inherently wrong.

The Groovy language provides an alternative annotation to `@TypeChecked` which will actually make sure that the methods which are inferred as being called **will** effectively be called at runtime. This annotation turns the Groovy compiler into a **static compiler**, where all method calls are resolved at compile time **and** the generated bytecode makes sure that this happens: the annotation is `@groovy.transform.CompileStatic`.

### The `@CompileStatic` annotation

The `@CompileStatic` annotation can be added anywhere the `@TypeChecked` annotation can be used, that is to say on a class or a method. It is not necessary to add both `@TypeChecked` and `@CompileStatic`, as `@CompileStatic` performs everything `@TypeChecked` does, but in addition triggers static compilation.

Let's take the [example which failed](#typechecked-defeated), but this time let's replace the `@TypeChecked` annotation with `@CompileStatic`:

    class Computer {
        int compute(String str) {
            str.length()
        }
        String compute(int x) {
            String.valueOf(x)
        }
    }
    
    @groovy.transform.CompileStatic
    void test() {
        def computer = new Computer()
        computer.with {
            assert compute(compute('foobar')) =='6'
        }
    }
    Computer.metaClass.compute = { String str -> new Date() }
    test()

This is the **only** difference. If we execute this program, this time, there is no runtime error. The `test` method became immune to monkey patching, because the `compute` methods which are called in its body are linked at compile time, so even if the metaclass of `Computer` changes, the program still behaves **as expected by the type checker**.

### Key benefits

There are several benefits of using `@CompileStatic` on your code:

-   type safety

-   immunity to [monkey patching](#compilestatic-annotation)

-   performance improvements

The performance improvements depend on the kind of program you are executing. If it is I/O bound, the difference between statically compiled code and dynamic code is barely noticeable. On highly CPU intensive code, since the bytecode which is generated is very close, if not equal, to the one that Java would produce for an equivalent program, the performance is greatly improved.

Using the *invokedynamic* version of Groovy, which is accessible to people using JDK 7 and above, the performance of the dynamic code should be very close to the performance of statically compiled code. Sometimes, it can even be faster! There is only one way to determine which version you should choose: measuring. The reason is that depending on your program **and** the JVM that you use, the performance can be significantly different. In particular, the *invokedynamic* version of Groovy is very sensitive to the JVM version in use.

# 类型检查扩展

## 编写类型检查扩展

### 更智能的类型检查器

尽管 Groovy 是一种动态语言，但它可以在编译时与[静态类型检查器](#static-type-checking)一起使用，并使用 \@TypeChecked 注释启用。在这种模式下，编译器会变得更加冗长，并会抛出错误，例如拼写错误、不存在的方法等。不过，这也有一些限制，其中大部分来自 Groovy 本质上仍然是一种动态语言。例如，您将无法对使用标记生成器的代码进行类型检查：

    def builder = new MarkupBuilder(out)
    builder.html {
        head {
            // ...
        }
        body {
            p 'Hello, world!'
        }
    }

在前面的示例中， html 、 head 、 body 或 p 方法都不存在。但是，如果您执行该代码，它就会起作用，因为 Groovy 使用动态调度并在运行时转换这些方法调用。在此builder中，您可以使用的标签数量和属性都没有限制，这意味着类型检查器没有机会在编译时了解所有可能的方法（标签），除非您创建一个build专用于 HTML。

Groovy 是实现内部 DSL 的首选平台。灵活的语法与运行时和编译时元编程功能相结合，使 Groovy 成为一个有趣的选择，因为它允许程序员专注于 DSL 而不是工具或实现。由于 Groovy DSL 是 Groovy 代码，因此很容易获得 IDE 支持，而无需编写专用插件等。

In a lot of cases, DSL engines are written in Groovy (or Java) then user code is executed as scripts, meaning that you have some kind of wrapper on top of user logic. The wrapper may consist, for example, in a `GroovyShell` or `GroovyScriptEngine` that performs some tasks transparently before running the script (adding imports, applying AST transforms, extending a base script,...). Often, user written scripts come to production without testing because the DSL logic comes to a point where **any** user may write code using the DSL syntax. In the end, a user may just ignore that what they write is actually **code**. This adds some challenges for the DSL implementer, such as securing execution of user code or, in this case, early reporting of errors.

For example, imagine a DSL which goal is to drive a rover on Mars remotely. Sending a message to the rover takes around 15 minutes. If the rover executes the script and fails with an error (say a typo), you have two problems:

-   first, feedback comes only after 30 minutes (the time needed for the rover to get the script and the time needed to receive the error)

-   second, some portion of the script has been executed and you may have to change the fixed script significantly (implying that you need to know the current state of the rover...)

类型检查扩展机制，允许 DSL 引擎的开发人员通过应用在常规Groovy类上进行的静态类型来使这些脚本更安全。

这里的原则是尽早失败，也就是说尽快使脚本编译失败，并且如果可能的话向用户提供反馈（包括好的错误消息）。

简而言之，类型检查扩展背后的想法是让编译器了解 DSL 使用的所有运行时元编程技巧，以便脚本可以受益于与详细静态编译代码相同级别的编译时检查。我们将看到您可以通过执行普通类型检查器无法执行的检查来更进一步，为您的用户提供强大的编译时检查。

### `extensions` 属性

\@TypeChecked 注释支持名为 extensions 的属性。该参数是类型检查扩展脚本的字符串数组。

这些脚本是在编译时在类路径中找到的。例如，您可以写：

    @TypeChecked(extensions='/path/to/myextension.groovy')
    void foo() { ...}

在这种情况下，将使用 myextension.groovy 脚本中找到的正常类型检查器的规则对 foo 方法进行类型检查。请注意，虽然类型检查器内部支持多种机制来实现类型检查扩展（包括普通的旧 java 代码），但推荐的方法是使用这些类型检查扩展脚本。

### 应用于类型检查的DSL

类型检查扩展背后的想法是使用 DSL 来扩展类型检查器功能。该 DSL 允许您使用"事件驱动"API 挂钩编译过程，更具体地说是类型检查阶段。例如，当类型检查器进入方法主体时，它会引发扩展的 `beforeVisitMethod` 事件：

    beforeVisitMethod { methodNode ->
     println "Entering ${methodNode.name}"
    }

Imagine that you have this rover DSL at hand. A user would write:

    robot.move 100

If you have a class defined as such:

    class Robot {
        Robot move(int qt) { this }
    }

The script can be type checked before being executed using the following script:

    def config = new CompilerConfiguration()
    config.addCompilationCustomizers(
        new ASTTransformationCustomizer(TypeChecked)            
    )
    def shell = new GroovyShell(config)                         
    def robot = new Robot()
    shell.setVariable('robot', robot)
    shell.evaluate(script)                                      

-   a compiler configuration adds the `@TypeChecked` annotation to all classes

-   use the configuration in a `GroovyShell`

-   so that scripts compiled using the shell are compiled with `@TypeChecked` without the user having to add it explicitly

Using the compiler configuration above, we can apply *\@TypeChecked* transparently to the script. In that case, it will fail at compile time:

    [Static type checking] - The variable [robot] is undeclared.

Now, we will slightly update the configuration to include the \`\`extensions\'\' parameter:

    config.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            TypeChecked,
            extensions:['robotextension.groovy'])
    )

Then add the following to your classpath:

**robotextension.groovy**

    unresolvedVariable { var ->
        if ('robot'==var.name) {
            storeType(var, classNodeFor(Robot))
            handled = true
        }
    }

Here, we're telling the compiler that if an *unresolved variable* is found and that the name of the variable is *robot*, then we can make sure that the type of this variable is `Robot`.

### Type checking extensions API

#### AST

The type checking API is a low level API, dealing with the Abstract Syntax Tree. You will have to know your AST well to develop extensions, even if the DSL makes it much easier than just dealing with AST code from plain Java or Groovy.

#### Events

The type checker sends the following events, to which an extension script can react:

+-----------------+-------------------------------------------------------+
| **Event name**  | setup                                                 |
+-----------------+-------------------------------------------------------+
| **Called When** | Called after the type checker finished initialization |
+-----------------+-------------------------------------------------------+
| **Arguments**   | none                                                  |
+-----------------+-------------------------------------------------------+
| **Usage**       |     setup {                                           |
|                 |         // this is called before anything else        |
|                 |     }                                                 |
|                 |                                                       |
|                 | Can be used to perform setup of your extension        |
+-----------------+-------------------------------------------------------+

+-----------------+---------------------------------------------------------------------------------------+
| **Event name**  | finish                                                                                |
+-----------------+---------------------------------------------------------------------------------------+
| **Called When** | Called after the type checker completed type checking                                 |
+-----------------+---------------------------------------------------------------------------------------+
| **Arguments**   | none                                                                                  |
+-----------------+---------------------------------------------------------------------------------------+
| **Usage**       |     finish {                                                                          |
|                 |         // this is after completion                                                   |
|                 |         // of all type checking                                                       |
|                 |     }                                                                                 |
|                 |                                                                                       |
|                 | Can be used to perform additional checks after the type checker has finished its job. |
+-----------------+---------------------------------------------------------------------------------------+

+-----------------+-----------------------------------------------------------------------------+
| **Event name**  | unresolvedVariable                                                          |
+-----------------+-----------------------------------------------------------------------------+
| **Called When** | Called when the type checker finds an unresolved variable                   |
+-----------------+-----------------------------------------------------------------------------+
| **Arguments**   | VariableExpression vexp                                                     |
+-----------------+-----------------------------------------------------------------------------+
| **Usage**       |     unresolvedVariable { VariableExpression vexp ->                         |
|                 |         if (vexp.name == 'people') {                                        |
|                 |             storeType(vexp, LIST_TYPE)                                      |
|                 |             handled = true                                                  |
|                 |         }                                                                   |
|                 |     }                                                                       |
|                 |                                                                             |
|                 | Allows the developer to help the type checker with user-injected variables. |
+-----------------+-----------------------------------------------------------------------------+

+-----------------+---------------------------------------------------------------------+
| **Event name**  | unresolvedProperty                                                  |
+-----------------+---------------------------------------------------------------------+
| **Called When** | Called when the type checker cannot find a property on the receiver |
+-----------------+---------------------------------------------------------------------+
| **Arguments**   | PropertyExpression pexp                                             |
+-----------------+---------------------------------------------------------------------+
| **Usage**       |     unresolvedProperty { PropertyExpression pexp ->                 |
|                 |         if (pexp.propertyAsString == 'longueur' &&                  |
|                 |                 getType(pexp.objectExpression) == STRING_TYPE) {    |
|                 |             storeType(pexp, int_TYPE)                               |
|                 |             handled = true                                          |
|                 |         }                                                           |
|                 |     }                                                               |
|                 |                                                                     |
|                 | Allows the developer to handle \"dynamic\" properties               |
+-----------------+---------------------------------------------------------------------+

+-----------------+-----------------------------------------------------------------------+
| **Event name**  | unresolvedAttribute                                                   |
+-----------------+-----------------------------------------------------------------------+
| **Called When** | Called when the type checker cannot find an attribute on the receiver |
+-----------------+-----------------------------------------------------------------------+
| **Arguments**   | AttributeExpression aexp                                              |
+-----------------+-----------------------------------------------------------------------+
| **Usage**       |     unresolvedAttribute { AttributeExpression aexp ->                 |
|                 |         if (getType(aexp.objectExpression) == STRING_TYPE) {          |
|                 |             storeType(aexp, STRING_TYPE)                              |
|                 |             handled = true                                            |
|                 |         }                                                             |
|                 |     }                                                                 |
|                 |                                                                       |
|                 | Allows the developer to handle missing attributes                     |
+-----------------+-----------------------------------------------------------------------+

+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | beforeMethodCall                                                                                                                                                                                                                                                                                 |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called before the type checker starts type checking a method call                                                                                                                                                                                                                                |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | MethodCall call                                                                                                                                                                                                                                                                                  |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     beforeMethodCall { call ->                                                                                                                                                                                                                                                                   |
|                 |         if (isMethodCallExpression(call)                                                                                                                                                                                                                                                         |
|                 |                 && call.methodAsString=='toUpperCase') {                                                                                                                                                                                                                                         |
|                 |             addStaticTypeError('Not allowed',call)                                                                                                                                                                                                                                               |
|                 |             handled = true                                                                                                                                                                                                                                                                       |
|                 |         }                                                                                                                                                                                                                                                                                        |
|                 |     }                                                                                                                                                                                                                                                                                            |
|                 |                                                                                                                                                                                                                                                                                                  |
|                 | Allows you to intercept method calls before the type checker performs its own checks. This is useful if you want to replace the default type checking with a custom one for a limited scope. In that case, you must set the handled flag to true, so that the type checker skips its own checks. |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | afterMethodCall                                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called once the type checker has finished type checking a method call                                                                                                                                                                                                                                                                                                                        |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | MethodCall call                                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     afterMethodCall { call ->                                                                                                                                                                                                                                                                                                                                                                |
|                 |         if (getTargetMethod(call).name=='toUpperCase') {                                                                                                                                                                                                                                                                                                                                     |
|                 |             addStaticTypeError('Not allowed',call)                                                                                                                                                                                                                                                                                                                                           |
|                 |             handled = true                                                                                                                                                                                                                                                                                                                                                                   |
|                 |         }                                                                                                                                                                                                                                                                                                                                                                                    |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                        |
|                 |                                                                                                                                                                                                                                                                                                                                                                                              |
|                 | Allow you to perform additional checks after the type checker has done its own checks. This is in particular useful if you want to perform the standard type checking tests but also want to ensure additional type safety, for example checking the arguments against each other.Note that `afterMethodCall` is called even if you did `beforeMethodCall` and set the handled flag to true. |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | onMethodSelection                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker when it finds a method appropriate for a method call                                                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | Expression expr, MethodNode node                                                                                                                                                                                                                                                                                                                                                                                                                                             |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     onMethodSelection { expr, node ->                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                 |         if (node.declaringClass.name == 'java.lang.String') {                                                                                                                                                                                                                                                                                                                                                                                                                |
|                 |             // calling a method on 'String'                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                 |             // let’s perform additional checks!                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                 |             if (++count>2) {                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                 |                 addStaticTypeError("You can use only 2 calls on String in your source code",expr)                                                                                                                                                                                                                                                                                                                                                                            |
|                 |             }                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                 |         }                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                 | The type checker works by inferring argument types of a method call, then chooses a target method. If it finds one that corresponds, then it triggers this event. It is for example interesting if you want to react on a specific method call, such as entering the scope of a method that takes a closure as argument (as in builders).Please note that this event may be thrown for various types of expressions, not only method calls (binary expressions for example). |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | methodNotFound                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker when it fails to find an appropriate method for a method call                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | ClassNode receiver, String name, ArgumentListExpression argList, ClassNode\[\] argTypes,MethodCall call                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     methodNotFound { receiver, name, argList, argTypes, call ->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                 |         // receiver is the inferred type of the receiver                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                 |         // name is the name of the called method                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                 |         // argList is the list of arguments the method was called with                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                 |         // argTypes is the array of inferred types for each argument                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                 |         // call is the method call for which we couldn’t find a target method                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                 |         if (receiver==classNodeFor(String)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                 |                 && name=='longueur'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                 |                 && argList.size()==0) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                 |             handled = true                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                 |             return newMethod('longueur', classNodeFor(String))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                 |         }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                 | Unlike `onMethodSelection`, this event is sent when the type checker cannot find a target method for a method call (instance or static). It gives you the chance to intercept the error before it is sent to the user, but also set the target method.For this, you need to return a list of `MethodNode`. In most situations, you would either return: an empty list, meaning that you didn't find a corresponding method, a list with exactly one element, saying that there's no doubt about the target methodIf you return more than one MethodNode, then the compiler would throw an error to the user stating that the method call is ambiguous, listing the possible methods.For convenience, if you want to return only one method, you are allowed to return it directly instead of wrapping it into a list. |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | beforeVisitMethod                                                                                                                                                                                                                                                                                                                                                            |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker before type checking a method body                                                                                                                                                                                                                                                                                                                |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | MethodNode node                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     beforeVisitMethod { methodNode ->                                                                                                                                                                                                                                                                                                                                        |
|                 |         // tell the type checker we will handle the body by ourselves                                                                                                                                                                                                                                                                                                        |
|                 |         handled = methodNode.name.startsWith('skip')                                                                                                                                                                                                                                                                                                                         |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                        |
|                 |                                                                                                                                                                                                                                                                                                                                                                              |
|                 | The type checker will call this method before starting to type check a method body. If you want, for example, to perform type checking by yourself instead of letting the type checker do it, you have to set the handled flag to true. This event can also be used to help define the scope of your extension (for example, applying it only if you are inside method foo). |
+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | afterVisitMethod                                                                                                                                                                                                                             |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker after type checking a method body                                                                                                                                                                                 |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | MethodNode node                                                                                                                                                                                                                              |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     afterVisitMethod { methodNode ->                                                                                                                                                                                                         |
|                 |         scopeExit {                                                                                                                                                                                                                          |
|                 |             if (methods>2) {                                                                                                                                                                                                                 |
|                 |                 addStaticTypeError("Method ${methodNode.name} contains more than 2 method calls", methodNode)                                                                                                                                |
|                 |             }                                                                                                                                                                                                                                |
|                 |         }                                                                                                                                                                                                                                    |
|                 |     }                                                                                                                                                                                                                                        |
|                 |                                                                                                                                                                                                                                              |
|                 | Gives you the opportunity to perform additional checks after a method body is visited by the type checker. This is useful if you collect information, for example, and want to perform additional checks once everything has been collected. |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | beforeVisitClass                                                                                                                                                                                                                                                                                                                                                                                              |
+-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker before type checking a class                                                                                                                                                                                                                                                                                                                                                       |
+-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | ClassNode node                                                                                                                                                                                                                                                                                                                                                                                                |
+-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     beforeVisitClass { ClassNode classNode ->                                                                                                                                                                                                                                                                                                                                                                 |
|                 |         def name = classNode.nameWithoutPackage                                                                                                                                                                                                                                                                                                                                                               |
|                 |         if (!(name[0] in 'A'..'Z')) {                                                                                                                                                                                                                                                                                                                                                                         |
|                 |             addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)                                                                                                                                                                                                                                                                                                            |
|                 |         }                                                                                                                                                                                                                                                                                                                                                                                                     |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                                         |
|                 |                                                                                                                                                                                                                                                                                                                                                                                                               |
|                 | If a class is type checked, then before visiting the class, this event will be sent. It is also the case for inner classes defined inside a class annotated with `@TypeChecked`. It can help you define the scope of your extension, or you can even totally replace the visit of the type checker with a custom type checking implementation. For that, you would have to set the `handled` flag to `true`.  |
+-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | afterVisitClass                                                                                                                                                                                                      |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called by the type checker after having finished the visit of a type checked class                                                                                                                                   |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | ClassNode node                                                                                                                                                                                                       |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     afterVisitClass { ClassNode classNode ->                                                                                                                                                                         |
|                 |         def name = classNode.nameWithoutPackage                                                                                                                                                                      |
|                 |         if (!(name[0] in 'A'..'Z')) {                                                                                                                                                                                |
|                 |             addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)                                                                                                                   |
|                 |         }                                                                                                                                                                                                            |
|                 |     }                                                                                                                                                                                                                |
|                 |                                                                                                                                                                                                                      |
|                 | Called for every class being type checked after the type checker finished its work. This includes classes annotated with `@TypeChecked` and any inner/anonymous class defined in the same class with is not skipped. |
+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | incompatibleAssignment                                                                                                                                                                                                                                                                                                                                                                                          |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called when the type checker thinks that an assignment is incorrect, meaning that the right-hand side of an assignment is incompatible with the left-hand side                                                                                                                                                                                                                                                  |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | ClassNode lhsType, ClassNode rhsType, Expression assignment                                                                                                                                                                                                                                                                                                                                                     |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     incompatibleAssignment { lhsType, rhsType, expr ->                                                                                                                                                                                                                                                                                                                                                          |
|                 |         if (isBinaryExpression(expr) && isAssignment(expr.operation.type)) {                                                                                                                                                                                                                                                                                                                                    |
|                 |             if (lhsType==classNodeFor(int) && rhsType==classNodeFor(Closure)) {                                                                                                                                                                                                                                                                                                                                 |
|                 |                 handled = true                                                                                                                                                                                                                                                                                                                                                                                  |
|                 |             }                                                                                                                                                                                                                                                                                                                                                                                                   |
|                 |         }                                                                                                                                                                                                                                                                                                                                                                                                       |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                                           |
|                 |                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                 | Gives the developer the ability to handle incorrect assignments. This is for example useful if a class overrides `setProperty`, because in that case it is possible that assigning a variable of one type to a property of another type is handled through that runtime mechanism. In that case, you can help the type checker just by telling it that the assignment is valid (using `handled` set to `true`). |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | incompatibleReturnType                                                                                                                                                                                                                                                                                                                                       |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called when the type checker thinks that a return value is incompatibe with the return type of the enclosing closure or method                                                                                                                                                                                                                               |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | ReturnStatement statement, ClassNode valueType                                                                                                                                                                                                                                                                                                               |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     incompatibleReturnType { stmt, type ->                                                                                                                                                                                                                                                                                                                   |
|                 |         if (type == STRING_TYPE) {                                                                                                                                                                                                                                                                                                                           |
|                 |             handled = true                                                                                                                                                                                                                                                                                                                                   |
|                 |         }                                                                                                                                                                                                                                                                                                                                                    |
|                 |     }                                                                                                                                                                                                                                                                                                                                                        |
|                 |                                                                                                                                                                                                                                                                                                                                                              |
|                 | Gives the developer the ability to handle incorrect return values. This is for example useful when the return value will undergo implicit conversion or the enclosing closure's target type is difficult to infer properly. In that case, you can help the type checker just by telling it that the assignment is valid (by setting the `handled` property). |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Event name**  | ambiguousMethods                                                                                                                                                                                                                                                                                                                                                                                                |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Called When** | Called when the type checker cannot choose between several candidate methods                                                                                                                                                                                                                                                                                                                                    |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Arguments**   | List\<MethodNode\> methods,  Expression origin                                                                                                                                                                                                                                                                                                                                                                  |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Usage**       |     ambiguousMethods { methods, origin ->                                                                                                                                                                                                                                                                                                                                                                       |
|                 |         // choose the method which has an Integer as parameter type                                                                                                                                                                                                                                                                                                                                             |
|                 |         methods.find { it.parameters.any { it.type == classNodeFor(Integer) } }                                                                                                                                                                                                                                                                                                                                 |
|                 |     }                                                                                                                                                                                                                                                                                                                                                                                                           |
|                 |                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                 | Gives the developer the ability to handle incorrect assignments. This is for example useful if a class overrides `setProperty`, because in that case it is possible that assigning a variable of one type to a property of another type is handled through that runtime mechanism. In that case, you can help the type checker just by telling it that the assignment is valid (using `handled` set to `true`). |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Of course, an extension script may consist of several blocks, and you can have multiple blocks responding to the same event. This makes the DSL look nicer and easier to write. However, reacting to events is far from sufficient. If you know you can react to events, you also need to deal with the errors, which implies several *helper* methods that will make things easier.

### Working with extensions

#### Support classes

The DSL relies on a support class called gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport\[\] . This class itself extends gapi:org.codehaus.groovy.transform.stc.TypeCheckingExtension\[\] . Those two classes define a number of *helper* methods that will make working with the AST easier, especially regarding type checking. One interesting thing to know is that you **have access to the type checker**. This means that you can programmatically call methods of the type checker, including those that allow you to **throw compilation errors**.

The extension script delegates to the gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport\[\] class, meaning that you have direct access to the following variables:

-   *context*: the type checker context, of type gapi:org.codehaus.groovy.transform.stc.TypeCheckingContext\[\]

-   *typeCheckingVisitor*: the type checker itself, a gapi:org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor\[\] instance

-   *generatedMethods*: a list of \"generated methods\", which is in fact the list of \"dummy\" methods that you can create inside a type checking extension using the `newMethod` calls

The type checking context contains a lot of information that is useful in context for the type checker. For example, the current stack of enclosing method calls, binary expressions, closures, ... This information is in particular important if you have to know *where* you are when an error occurs and that you want to handle it.

In addition to facilities provided by `GroovyTypeCheckingExtensionSupport` and `StaticTypeCheckingVisitor`, a type-checking DSL script imports static members from gapi:org.codehaus.groovy.ast.ClassHelper\[\] and gapi:org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport\[\] granting access to common types via `OBJECT_TYPE`, `STRING_TYPE`, `THROWABLE_TYPE`, etc. and checks like `missesGenericsTypes(ClassNode)`, `isClassClassNodeWrappingConcreteType(ClassNode)` and so on.

#### Class nodes

Handling class nodes is something that needs particular attention when you work with a type checking extension. Compilation works with an abstract syntax tree (AST) and the tree may not be complete when you are type checking a class. This also means that when you refer to types, you must not use class literals such as `String` or `HashSet`, but to class nodes representing those types. This requires a certain level of abstraction and understanding how Groovy deals with class nodes. To make things easier, Groovy supplies several helper methods to deal with class nodes. For example, if you want to say \"the type for String\", you can write:

    assert classNodeFor(String) instanceof ClassNode

You would also note that there is a variant of *classNodeFor* that takes a `String` as an argument, instead of a `Class`. In general, you should **not** use that one, because it would create a class node for which the name is `String`, but without any method, any property, ... defined on it. The first version returns a class node that is *resolved* but the second one returns one that is *not*. So the latter should be reserved for very special cases.

The second problem that you might encounter is referencing a type which is not yet compiled. This may happen more often than you think. For example, when you compile a set of files together. In that case, if you want to say \"that variable is of type Foo\" but `Foo` is not yet compiled, you can still refer to the `Foo` class node using `lookupClassNodeFor`:

    assert lookupClassNodeFor('Foo') instanceof ClassNode

#### Helping the type checker

Say that you know that variable `foo` is of type `Foo` and you want to tell the type checker about it. Then you can use the `storeType` method, which takes two arguments: the first one is the node for which you want to store the type and the second one is the type of the node. If you look at the implementation of `storeType`, you would see that it delegates to the type checker equivalent method, which itself does a lot of work to store node metadata. You would also see that storing the type is not limited to variables: you can set the type of any expression.

Likewise, getting the type of an AST node is just a matter of calling `getType` on that node. This would in general be what you want, but there's something that you must understand:

-   `getType` returns the **inferred type** of an expression. This means that it will not return, for a variable declared of type `Object` the class node for `Object`, but the inferred type of this variable **at this point of the code** (flow typing)

-   if you want to access the origin type of a variable (or field/parameter), then you must call the appropriate method on the AST node

#### Throwing an error

To throw a type checking error, you only have to call the `addStaticTypeError` method which takes two arguments:

-   a *message* which is a string that will be displayed to the end user

-   an *AST node* responsible for the error. It's better to provide the best suiting AST node because it will be used to retrieve the line and column numbers

#### isXXXExpression

It is often required to know the type of an AST node. For readability, the DSL provides a special isXXXExpression method that will delegate to `x instance of XXXExpression`. For example, instead of writing:

    if (node instanceof BinaryExpression) {
       ...
    }

you can just write:

    if (isBinaryExpression(node)) {
       ...
    }

#### Virtual methods

When you perform type checking of dynamic code, you may often face the case when you know that a method call is valid but there is no \"real\" method behind it. As an example, take the Grails dynamic finders. You can have a method call consisting of a method named *findByName(...)*. As there's no *findByName* method defined in the bean, the type checker would complain. Yet, you would know that this method wouldn't fail at runtime, and you can even tell what is the return type of this method. For this case, the DSL supports two special constructs that consist of *phantom methods*. This means that you will return a method node that doesn't really exist but is defined in the context of type checking. Three methods exist:

-   `newMethod(String name, Class returnType)`

-   `newMethod(String name, ClassNode returnType)`

-   `newMethod(String name, Callable<ClassNode> return Type)`

All three variants do the same: they create a new method node which name is the supplied name and define the return type of this method. Moreover, the type checker would add those methods in the `generatedMethods` list (see `isGenerated` below). The reason why we only set a name and a return type is that it is only what you need in 90% of the cases. For example, in the `findByName` example upper, the only thing you need to know is that `findByName` wouldn't fail at runtime, and that it returns a domain class. The `Callable` version of return type is interesting because it defers the computation of the return type when the type checker actually needs it. This is interesting because in some circumstances, you may not know the actual return type when the type checker demands it, so you can use a closure that will be called each time `getReturnType` is called by the type checker on this method node. If you combine this with deferred checks, you can achieve pretty complex type checking including handling of forward references.

    newMethod(name) {
        // each time getReturnType on this method node will be called, this closure will be called!
        println 'Type checker called me!'
        lookupClassNodeFor(Foo) // return type
    }

Should you need more than the name and return type, you can always create a new `MethodNode` by yourself.

#### Scoping

Scoping is very important in DSL type checking and is one of the reasons why we couldn't use a *pointcut* based approach to DSL type checking. Basically, you must be able to define very precisely when your extension applies and when it does not. Moreover, you must be able to handle situations that a regular type checker would not be able to handle, such as forward references:

    point a(1,1)
    line a,b // b is referenced afterwards!
    point b(5,2)

Say for example that you want to handle a builder:

    builder.foo {
       bar
       baz(bar)
    }

Your extension, then, should only be active once you've entered the `foo` method, and inactive outside this scope. But you could have complex situations like multiple builders in the same file or embedded builders (builders in builders). While you should not try to fix all this from start (you must accept limitations to type checking), the type checker does offer a nice mechanism to handle this: a scoping stack, using the `newScope` and `scopeExit` methods.

-   `newScope` creates a new scope and puts it on top of the stack

-   `scopeExits` pops a scope from the stack

A scope consists of:

-   a parent scope

-   a map of custom data

If you want to look at the implementation, it's simply a `LinkedHashMap` (gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport.TypeCheckingScope\[\]), but it's quite powerful. For example, you can use such a scope to store a list of closures to be executed when you exit the scope. This is how you would handle forward references: 

    def scope = newScope()
    scope.secondPassChecks = []
    //...
    scope.secondPassChecks << { println 'executed later' }
    // ...
    scopeExit {
        secondPassChecks*.run() // execute deferred checks
    }

That is to say, that if at some point you are not able to determine the type of an expression, or that you are not able to check at this point that an assignment is valid or not, you can still make the check later... This is a very powerful feature. Now, `newScope` and `scopeExit` provide some interesting syntactic sugar:

    newScope {
        secondPassChecks = []
    }

At anytime in the DSL, you can access the current scope using `getCurrentScope()` or more simply `currentScope`:

    //...
    currentScope.secondPassChecks << { println 'executed later' }
    // ...

The general schema would then be:

-   determine a *pointcut* where you push a new scope on stack and initialize custom variables within this scope

-   using the various events, you can use the information stored in your custom scope to perform checks, defer checks,...

-   determine a *pointcut* where you exit the scope, call `scopeExit` and eventually perform additional checks

#### Other useful methods

For the complete list of helper methods, please refer to the gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport\[\] and  gapi:org.codehaus.groovy.transform.stc.TypeCheckingExtension\[\] classes. However, take special attention to those methods:

-   `isDynamic`: takes a VariableExpression as argument and returns true if the variable is a DynamicExpression, which means, in a script, that it wasn't defined using a type or `def`.

-   `isGenerated`: takes a MethodNode as an argument and tells if the method is one that was generated by the type checker extension using the `newMethod` method

-   `isAnnotatedBy`: takes an AST node and a Class (or ClassNode), and tells if the node is annotated with this class. For example: `isAnnotatedBy(node, NotNull)`

-   `getTargetMethod`: takes a method call as argument and returns the `MethodNode` that the type checker has determined for it

-   `delegatesTo`: emulates the behaviour of the `@DelegatesTo` annotation. It allows you to tell that the argument will delegate to a specific type (you can also specify the delegation strategy)

## Advanced type checking extensions

### Precompiled type checking extensions

All the examples above use type checking scripts. They are found in source form in classpath, meaning that:

-   a Groovy source file, corresponding to the type checking extension, is available on compilation classpath

-   this file is compiled by the Groovy compiler for each source unit being compiled (often, a source unit corresponds to a single file)

It is a very convenient way to develop type checking extensions, however it implies a slower compilation phase, because of the compilation of the extension itself for each file being compiled. For those reasons, it can be practical to rely on a precompiled extension. You have two options to do this:

-   write the extension in Groovy, compile it, then use a reference to the extension class instead of the source

-   write the extension in Java, compile it, then use a reference to the extension class

Writing a type checking extension in Groovy is the easiest path. Basically, the idea is that the type checking extension script becomes the body of the main method of a type checking extension class, as illustrated here:

    import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport
    
    class PrecompiledExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     
        @Override
        Object run() {                                                                          
            unresolvedVariable { var ->
                if ('robot'==var.name) {
                    storeType(var, classNodeFor(Robot))                                         
                    handled = true
                }
            }
        }
    }

-   extending the `TypeCheckingDSL` class is the easiest

-   then the extension code needs to go inside the `run` method

-   and you can use the very same events as an extension written in source form

Setting up the extension is very similar to using a source form extension:

    config.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            TypeChecked,
            extensions:['typing.PrecompiledExtension'])
    )

The difference is that instead of using a path in classpath, you just specify the fully qualified class name of the precompiled extension.

In case you really want to write an extension in Java, then you will not benefit from the type checking extension DSL. The extension above can be rewritten in Java this way:

    import org.codehaus.groovy.ast.ClassHelper;
    import org.codehaus.groovy.ast.expr.VariableExpression;
    import org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension;


    import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
    
    public class PrecompiledJavaExtension extends AbstractTypeCheckingExtension {                   
    
        public PrecompiledJavaExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
            super(typeCheckingVisitor);
        }
    
        @Override
        public boolean handleUnresolvedVariableExpression(final VariableExpression vexp) {          
            if ("robot".equals(vexp.getName())) {
                storeType(vexp, ClassHelper.make(Robot.class));
                setHandled(true);
                return true;
            }
            return false;
        }
    
    }

-   extend the `AbstractTypeCheckingExtension` class

-   then override the `handleXXX` methods as required

### Using \@Grab in a type checking extension

It is totally possible to use the `@Grab` annotation in a type checking extension. This means you can include libraries that would only be available at compile time. In that case, you must understand that you would increase the time of compilation significantly (at least, the first time it grabs the dependencies).

### Sharing or packaging type checking extensions

A type checking extension is just a script that need to be on classpath. As such, you can share it as is, or bundle it in a jar file that would be added to classpath.

### Global type checking extensions

While you can configure the compiler to transparently add type checking extensions to your script, there is currently no way to apply an extension transparently just by having it on classpath.

### Type checking extensions and \@CompileStatic

Type checking extensions are used with `@TypeChecked` but can also be used with `@CompileStatic`. However, you must be aware that:

-   a type checking extension used with `@CompileStatic` will in general not be sufficient to let the compiler know how to generate statically compilable code from \"unsafe\" code

-   it is possible to use a type checking extension with `@CompileStatic` just to enhance type checking, that is to say introduce **more** compilation errors, without actually dealing with dynamic code

Let's explain the first point, which is that even if you use an extension, the compiler will not know how to compile your code statically: technically, even if you tell the type checker what is the type of a dynamic variable, for example, it would not know how to compile it. Is it `getBinding('foo')`, `getProperty('foo')`, `delegate.getFoo()`,...? There's absolutely no direct way to tell the static compiler how to compile such code even if you use a type checking extension (that would, again, only give hints about the type).

One possible solution for this particular example is to instruct the compiler to use [mixed mode compilation](#mixed-mode). The more advanced one is to use [AST transformations during type checking](#ast-xform-as-extension) but it is far more complex.

Type checking extensions allow you to help the type checker where it fails, but it also allows you to fail where it doesn't. In that context, it makes sense to support extensions for `@CompileStatic` too. Imagine an extension that is capable of type checking SQL queries. In that case, the extension would be valid in both dynamic and static context, because without the extension, the code would still pass.

### Mixed mode compilation

In the previous section, we highlighted the fact that you can activate type checking extensions with `@CompileStatic`. In that context, the type checker would not complain anymore about some unresolved variables or unknown method calls, but it would still wouldn't know how to compile them statically.

Mixed mode compilation offers a third way, which is to instruct the compiler that whenever an unresolved variable or method call is found, then it should fall back to a dynamic mode. This is possible thanks to type checking extensions and a special `makeDynamic` call.

To illustrate this, let's come back to the `Robot` example:

    robot.move 100

And let's try to activate our type checking extension using `@CompileStatic` instead of `@TypeChecked`:

    def config = new CompilerConfiguration()
    config.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            CompileStatic,                                      
            extensions:['robotextension.groovy'])               
    )
    def shell = new GroovyShell(config)
    def robot = new Robot()
    shell.setVariable('robot', robot)
    shell.evaluate(script)

-   Apply `@CompileStatic` transparently

-   Activate the type checking extension

The script will run fine because the static compiler is told about the type of the `robot` variable, so it is capable of making a direct call to `move`. But before that, how did the compiler know how to get the `robot` variable? In fact by default, in a type checking extension, setting `handled=true` on an unresolved variable will automatically trigger a dynamic resolution, so in this case you don't have anything special to make the compiler use a mixed mode. However, let's slightly update our example, starting from the robot script:

    move 100

Here you can notice that there is no reference to `robot` anymore. Our extension will not help then because we will not be able to instruct the compiler that `move` is done on a `Robot` instance. This example of code can be executed in a totally dynamic way thanks to the help of a gapi:groovy.util.DelegatingScript\[\]:

    def config = new CompilerConfiguration()
    config.scriptBaseClass = 'groovy.util.DelegatingScript'     
    def shell = new GroovyShell(config)
    def runner = shell.parse(script)                            
    runner.setDelegate(new Robot())                             
    runner.run()                                                

-   we configure the compiler to use a `DelegatingScript` as the base class

-   the script source needs to be parsed and will return an instance of `DelegatingScript`

-   we can then call `setDelegate` to use a `Robot` as the delegate of the script

-   then execute the script. `move` will be directly executed on the delegate

If we want this to pass with `@CompileStatic`, we have to use a type checking extension, so let's update our configuration:

    config.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            CompileStatic,                                      
            extensions:['robotextension2.groovy'])              
    )

-   apply `@CompileStatic` transparently

-   use an alternate type checking extension meant to recognize the call to `move`

Then in the previous section we have learnt how to deal with unrecognized method calls, so we are able to write this extension:

**robotextension2.groovy**

    methodNotFound { receiver, name, argList, argTypes, call ->
        if (isMethodCallExpression(call)                        
            && call.implicitThis                                
            && 'move'==name                                     
            && argTypes.length==1                               
            && argTypes[0] == classNodeFor(int)                 
        ) {
            handled = true                                      
            newMethod('move', classNodeFor(Robot))              
        }
    }

-   if the call is a method call (not a static method call)

-   that this call is made on \"implicit this\" (no explicit `this.`)

-   that the method being called is `move`

-   and that the call is done with a single argument

-   and that argument is of type `int`

-   then tell the type checker that the call is valid

-   and that the return type of the call is `Robot`

If you try to execute this code, then you could be surprised that it actually fails at runtime:

    java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;

The reason is very simple: while the type checking extension is sufficient for `@TypeChecked`, which does not involve static compilation, it is not enough for `@CompileStatic` which requires additional information. In this case, you told the compiler that the method existed, but you didn't explain to it **what** method it is in reality, and what is the receiver of the message (the delegate).

Fixing this is very easy and just implies replacing the `newMethod` call with something else:

**robotextension3.groovy**

    methodNotFound { receiver, name, argList, argTypes, call ->
        if (isMethodCallExpression(call)
            && call.implicitThis
            && 'move'==name
            && argTypes.length==1
            && argTypes[0] == classNodeFor(int)
        ) {
            makeDynamic(call, classNodeFor(Robot))              
        }
    }

-   tell the compiler that the call should be make dynamic

The `makeDynamic` call does 3 things:

-   it returns a virtual method just like `newMethod`

-   automatically sets the `handled` flag to `true` for you

-   but also marks the `call` to be done dynamically

So when the compiler will have to generate bytecode for the call to `move`, since it is now marked as a dynamic call, it will fall back to the dynamic compiler and let it handle the call. And since the extension tells us that the return type of the dynamic call is a `Robot`, subsequent calls will be done statically!

Some would wonder why the static compiler doesn't do this by default without an extension. It is a design decision:

-   if the code is statically compiled, we normally want type safety and best performance

-   so if unrecognized variables/method calls are made dynamic, you loose type safety, but also all support for typos at compile time!

In short, if you want to have mixed mode compilation, it **has** to be explicit, through a type checking extension, so that the compiler, and the designer of the DSL, are totally aware of what they are doing.

`makeDynamic` can be used on 3 kind of AST nodes:

-   a method node (`MethodNode`)

-   a variable (`VariableExpression`)

-   a property expression (`PropertyExpression`)

If that is not enough, then it means that static compilation cannot be done directly and that you have to rely on AST transformations.

### Transforming the AST in an extension

Type checking extensions look very attractive from an AST transformation design point of view: extensions have access to context like inferred types, which is often nice to have. And an extension has a direct access to the abstract syntax tree. Since you have access to the AST, there is nothing in theory that prevents you from modifying the AST. However, we do not recommend you to do so, unless you are an advanced AST transformation designer and well aware of the compiler internals:

-   First of all, you would explicitly break the contract of type checking, which is to annotate, and only annotate the AST. Type checking should **not** modify the AST tree because you wouldn't be able to guarantee anymore that code without the *\@TypeChecked* annotation behaves the same without the annotation.

-   If your extension is meant to work with *\@CompileStatic*, then you **can** modify the AST because this is indeed what *\@CompileStatic* will eventually do. Static compilation doesn't guarantee the same semantics at dynamic Groovy so there is effectively a difference between code compiled with *\@CompileStatic* and code compiled with *\@TypeChecked*. It's up to you to choose whatever strategy you want to update the AST, but probably using an AST transformation that runs before type checking is easier.

-   if you cannot rely on a transformation that kicks in before the type checker, then you must be **very** careful

The type checking phase is the last phase running in the compiler before bytecode generation. All other AST transformations run before that and the compiler does a very good job at \"fixing\" incorrect AST generated before the type checking phase. As soon as you perform a transformation during type checking, for example directly in a type checking extension, then you have to do all this work of generating a 100% compiler compliant abstract syntax tree by yourself, which can easily become complex. That's why we do not recommend to go that way if you are beginning with type checking extensions and AST transformations.

### Examples

Examples of real life type checking extensions are easy to find. You can download the source code for Groovy and take a look at the [TypeCheckingExtensionsTest](https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy) class which is linked to [various extension scripts](https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc).

An example of a complex type checking extension can be found in the [Markup Template Engine](../markup-template-engine.html) source code: this template engine relies on a type checking extension and AST transformations to transform templates into fully statically compiled code. Sources for this can be found [here](https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup).
