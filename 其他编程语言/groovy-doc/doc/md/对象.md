This chapter covers the object-oriented aspects of the Groovy programming language.

# 类型

## 基本类型

Groovy 支持 [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se14/html/) 相同的基本类型：

-   整数类型： `byte` （8 位）、 `short` （16 位）、 `int` （32 位）和 `long` （64 位）

-   浮点类型： `float` （32 位）和 `double` （64 位）

-   `boolean` 类型（ `true` 或 `false` 之一）

-   `char` 类型（16 位，可用作数字类型，表示 UTF-16 代码） 与 Java 一样，当需要与任何基本类型相对应的对象时，Groovy 使用相应的包装类：

基础类型包装类

-----------------------------------------------------------------------
  基础类型                            包装类
----------------------------------- -----------------------------------
  boolean                             Boolean

  char                                Character

  short                               Short

  int                                 Integer

  long                                Long

  float                               Float

  double                              Double
  -----------------------------------------------------------------------

  : 基础类型包装类

例如，当调用需要包装类的方法并将原始变量作为参数传递给它时，就会发生自动装箱和拆箱，反之亦然。这与 Java 类似，但 Groovy 更进一步地发展了这个想法。 在大多数情况下，您可以像对待包装器一样对待基础类。例如，您可以在基础类上调用 `.toString()` 或 `.equals(other)` 。 Groovy 根据需要在包装类和基础类之间自动包装和展开。

下面是一个使用 int 的示例，它被声明为类中的静态字段（稍后讨论）：

    class Foo {
        static int i
    }
    
    assert Foo.class.getDeclaredField('i').type == int.class           
    assert Foo.i.class != int.class && Foo.i.class == Integer.class    

-   基础类型保留在字节码中

-   在运行时查看该字段表明它已被自动包装

现在您可能会担心，这意味着每次您对基础类型的引用使用数学运算符时，都会产生拆箱和重新装箱基础类型的成本。但事实并非如此，因为 Groovy 会将您的运算符编译为其[等效方法](core-operators.html#Operator-Overloading)并使用它们。此外，当调用接收基础类型参数的 Java 方法时，Groovy 将自动拆箱为基础类，并自动对方法返回的基础类型进行装箱。但是，请注意，与 Java 的方法解析存在一些[差异](../core-differences-java.html#_primitives_and_wrappers)。

## 引用类型

除了基础类型之外，其他一切都是对象，并且有定义其类型的关联类。我们将很快讨论类以及与类相关或类似类的事物，例如接口、特征和记录。

我们可以声明两个类型为 String 和 List 的变量，如下所示：

    String movie = 'The Matrix'
    List actors = ['Keanu Reeves', 'Hugo Weaving']

## 泛型

Groovy 在泛型方面与 Java 具有相同的概念。定义类和方法时，可以使用类型参数并创建泛型类、接口、方法或构造函数。

泛型类和方法的使用，无论它们是在 Java 还是 Groovy 中定义的，都可能涉及提供类型参数。

我们可以声明一个 "字符串列表" 类型的变量，如下所示：

    List<String> roles = ['Trinity', 'Morpheus']

Java 采用类型擦除来向后兼容早期版本的 Java。 Dynamic Groovy 可以被认为是更积极地应用类型擦除。一般来说，编译时会检查的泛型类型信息较少。 Groovy 的静态特性在泛型信息方面采用了与 Java 类似的检查。

# 类

Groovy 类与 Java 类非常相似，并且在 JVM 级别与 Java 类兼容。它们可能有方法、字段和属性（类似 JavaBeans 属性，但样板代码较少）。类和类成员可以具有与 Java 中相同的修饰符（public、protected、private、static 等），但在源代码级别有一些细微的差异，稍后将对此进行解释。

Groovy 类与其 Java 类之间的主要区别是：

-   **没有可见性修饰符的类或方法自动是公共的** （可以使用特殊的注解来实现包私有可见性）。

-   **没有可见性修饰符的字段会自动转换为属性，从而减少冗长的代码，因为不需要显式的 getter 和 setter 方法**。有关这方面的更多信息将在[字段和属性部分](#fields)中介绍。

-   **类不需要与其源文件定义具有相同的基本名称**，但在大多数情况下强烈建议这样做（另请参阅有关脚本的下一点）。

-   一个源文件可能包含一个或多个类（但如果文件包含任何不在类中的代码，则将其视为脚本）。脚本只是具有一些特殊约定的类，并且与其源文件具有相同的名称（因此不要在与脚本源文件同名的脚本中包含类定义）。

以下代码提供了一个示例类。

    class Person {                       
    
        String name                      
        Integer age
    
        def increaseAge(Integer years) { 
            this.age += years
        }
    }

-   类以名称 `Person` 开头

-   名为 `name` 的字符串字段和属性

-   方法定义

## 普通类

普通类是指顶层的、具体的类。这意味着它们可以被实例化，而不受任何其他类或脚本的限制。这样，它们只能是公开的（即使 `public` 关键字可能被抑制）。类是通过使用 `new` 关键字调用其构造函数来实例化的，如以下代码片段所示。

    def p = new Person()

## 内部类

内部类是在另一个类中定义的。封闭类可以像往常一样使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的。封闭类以外的类不允许访问内部类。这是一个例子：

    class Outer {
        private String privateStr
    
        def callInnerMethod() {
            new Inner().methodA()       
        }
    
        class Inner {                   
            def methodA() {
                println "${privateStr}." 
            }
        }
    }

-   内部类被实例化并调用其方法

-   内部类定义，位于其封闭类内部

-   即使是私有的，封闭类的字段也可以由内部类访问

使用内部类有一些原因：

-   通过对其他类隐藏内部类来增加封装性，其他类不需要知道它。这也导致了更清洁的软件包和工作空间。

-   它们通过将仅由一个类使用的类分组来提供良好的组织。

-   们会导致更易于维护的代码，因为内部类靠近使用它们的类。

内部类通常会实现一些外部类的方法所需要的接口。下面的代码说明了这种典型的使用模式，此处与线程一起使用。

    class Outer2 {
        private String privateStr = 'some string'
    
        def startThread() {
           new Thread(new Inner2()).start()
        }
    
        class Inner2 implements Runnable {
            void run() {
                println "${privateStr}."
            }
        }
    }

请注意，类 `Inner2` 的定义只是为了向类 `Outer2` 提供方法 `run` 的实现。在这种情况下，匿名内部类有助于消除冗长的内容。我们很快就会讨论这个主题。

Groovy 3+ 还支持非静态内部类实例化的 Java 语法，例如：

    class Computer {
        class Cpu {
            int coreNumber
    
            Cpu(int coreNumber) {
                this.coreNumber = coreNumber
            }
        }
    }
    
    assert 4 == new Computer().new Cpu(4).coreNumber

### 匿名内部类

前面的内部类示例 ( `Inner2` ) 可以使用匿名内部类进行简化。使用以下代码可以实现相同的功能：

    class Outer3 {
        private String privateStr = 'some string'
    
        def startThread() {
            new Thread(new Runnable() {      
                void run() {
                    println "${privateStr}."
                }
            }).start()                       
        }
    }

-   与上一节的最后一个示例相比， `new Inner2()` 及其所有实现都被替换为 `new Runnable()`

-   方法 start 被正常调用

因此，不需要定义一个只使用一次的新类。

### 抽象类

抽象类代表通用概念，因此它们不能被实例化，也不能被创建为子类。它们的成员包括字段/属性和抽象或具体方法。抽象方法没有具体的实现，必须由具体的子类实现。

    abstract class Abstract {         
        String name
    
        abstract def abstractMethod() 
    
        def concreteMethod() {
            println 'concrete'
        }
    }

-   抽象类必须使用 `abstract` 关键字声明

-   抽象方法也必须用 `abstract` 关键字声明

抽象类通常与接口进行比较。选择其中之一至少有两个重要的区别。首先，抽象类可以包含字段/属性和具体方法，但接口仅包含抽象方法（方法签名）。此外，一个类可以实现多个接口，而它只能扩展一个类，无论是否是抽象类。

## 继承

Groovy 中的继承类似于 Java 中的继承。它为子类（或子类）提供了一种重用父类（或超类）的代码或属性的机制。 通过继承相关的类形成继承层次结构。常见的行为和成员被推到层次结构中以减少重复。

## 父类

父类与子类共享可见的字段、属性或方法。一个子类最多可以有一个父类。 `extends` 关键字紧接在超类类型之前。

## Interfaces

接口定义了类需要遵守的合约。接口只定义了需要实现的方法列表，但没有定义方法的实现。

下面是一个 `Greeter` 接口, 只定义了一个 `greet` 方法

    interface Greeter {                                         
        void greet(String name)                                 
    }

-   需要使用 `interface` 关键字声明接口

-   接口仅定义方法签名

接口的方法始终是 `public` 的。在接口中使用 `protected` 或 `private` 方法是错误的：

    interface Greeter {
        protected void greet(String name)                       
    }

-   使用 `protected` 是一个编译时错误

如果一个类在其 `implements` 列表中定义了接口，或者它的任何超类定义了该接口，则该类实现了该接口：

    class SystemGreeter implements Greeter {                    
        void greet(String name) {                               
            println "Hello $name"
        }
    }
    
    def greeter = new SystemGreeter()
    assert greeter instanceof Greeter                           

-   `SystemGreeter` 使用 `implements` 关键字声明 `Greeter` 接口

-   然后实现所需的 `greet` 方法

-   `SystemGreeter` 的任何实例也是 `Greeter` 接口的实例

一个接口可以扩展另一个接口：

    interface ExtendedGreeter extends Greeter {                 
        void sayBye(String name)
    }

-   `ExtendedGreeter` 接口使用 `extends` 关键字扩展 `Greeter` 接口

值得注意的是，要使类成为接口的实例，它必须显式使用 `implements` 。例如，以下类定义了在 `Greeter` 接口中声明的 `greet` 方法，但没有在其接口中声明 `Greeter` ：\`

    class DefaultGreeter {
        void greet(String name) { println "Hello" }
    }
    
    greeter = new DefaultGreeter()
    assert !(greeter instanceof Greeter)

换句话说，Groovy 没有定义结构类型(structural typing)。然而，可以使用 `as` 强制运算符使对象实例在运行时实现接口：

    greeter = new DefaultGreeter()                              
    coerced = greeter as Greeter                                
    assert coerced instanceof Greeter                           

-   创建一个不实现该接口的 DefaultGreeter 实例

-   在运行时将实例强制转换为 Greeter

-   强制实例实现 Greeter 接口

您可以看到有两个不同的对象：一个是源对象，DefaultGreeter 实例，它没有实现该接口。另一个是委托给强制对象的 Greeter 实例。

Groovy [traits](#X9cde14012b1faea3eccbc21d8ad88c8be021419) 与接口类似, 但是比接口更强大:

-   接口中只能包含default method和抽象方法(Java中的接口还可以包含static method, 但是groovy中的接口不行)

-   特质出了不能直接创建对象, 和普通类一样

# 类成员

## 构造函数

构造函数是用于初始化具有特定状态的对象的特殊方法。与普通方法一样，一个类可以声明多个构造函数，只要每个构造函数都有唯一的类型签名。如果一个对象在构造过程中不需要任何参数，它可以使用无参数构造函数。如果未提供构造函数，Groovy 编译器将提供一个空的无参数构造函数。

Groovy 支持两种调用方式：

-   位置参数的使用方式与使用 Java 构造函数的方式类似

-   命名参数允许您在调用构造函数时指定参数名称。

### 位置参数

要使用位置参数创建对象，相应的类需要声明一个或多个构造函数。在有多个构造函数的情况下，每个构造函数都必须具有唯一的类型签名。还可以使用 `groovy.transform.TupleConstructor` 注解将构造函数添加到类中。

通常，**一旦声明了至少一个构造函数，则只能通过调用其构造函数来实例化该类。值得注意的是，在这种情况下，您通常无法创建带有命名参数的类**。





**Groovy 确实支持命名参数，只要该类包含无参数构造函数或提供将** `Map` **参数作为第一个（也可能是唯一的）参数的构造函数** - 请参阅下一节了解详细信息。

使用声明的构造函数有三种形式。第一种是普通的 Java 方式，使用 new 关键字。其他依赖于将列表强制转换为所需类型。在这种情况下，可以使用 as 关键字并通过静态键入变量来进行强制。

    class PersonConstructor {
        String name
        Integer age
    
        PersonConstructor(name, age) {          
            this.name = name
            this.age = age
        }
    }
    
    def person1 = new PersonConstructor('Marie', 1)  
    def person2 = ['Marie', 2] as PersonConstructor  
    PersonConstructor person3 = ['Marie', 3]         

-   构造函数声明

-   构造函数调用，经典Java方式

-   构造函数的使用，使用带有 `as` 关键字的强制转换

-   构造函数的使用，在赋值中使用强制

### 命名参数

**如果没有声明构造函数, 或者声明了无参构造函数，则可以通过以** `Map`**（属性/值对）的形式传递参数来创建对象**。当人们想要允许多种参数组合的情况下，这会很方便。否则，通过使用传统的位置参数，有必要声明所有可能的构造函数。

**命名参数也支持第一个（也许是唯一）参数为 Map 参数的构造函数** - 也可以使用 `groovy.transform.MapConstructor` 注解添加这样的构造函数。

    class PersonWOConstructor {                                  
        String name
        Integer age
    }
    
    def person4 = new PersonWOConstructor()                      
    def person5 = new PersonWOConstructor(name: 'Marie')         
    def person6 = new PersonWOConstructor(age: 1)                
    def person7 = new PersonWOConstructor(name: 'Marie', age: 2) 

-   没有声明构造函数

-   实例化时没有给出参数

-   实例化中给出 name 的参数

-   实例化中给出 age 的参数

-   实例化中给出 age 和 name 的参数

然而，需要强调的是，这种方法为构造函数调用者提供了更多的权力，同时对调用者施加了更多的责任来确保名称和值类型正确。因此，如果需要更好的控制，那么使用位置参数声明构造函数可能是首选。

Notes:

-   虽然上面的示例未提供构造函数，但您还可以提供无参数构造函数或第一个参数为 `Map` 的构造函数，最常见的是它是唯一的参数。

-   当未声明构造函数时, 或者声明了无参构造函数，Groovy 将调用无参数构造函数，然后调用每个传入的命名参数的 setter。

-   当第一个参数是 `Map` 时，Groovy 将所有命名参数组合到一个 `Map` 中（无论顺序如何），并将该映射提供为第一个参数。如果您的属性被声明为 `final` （因为它们将在构造函数中设置，而不是在事后使用setter设置），那么这可能是一个好方法。

-   您可以通过提供位置构造函数以及无参数或 Map 构造函数来支持命名构造函数和位置构造函数。

-   您可以通过使用第一个参数是 Map 但还有其他位置参数的构造函数来支持混合构造。谨慎使用这种风格。





## 方法

Groovy 方法与其他语言非常相似。一些特性将在下一小节中显示。

### 方法定义

使用\*返回类型\*定义方法或使用 `def` 关键字定义方法以使返回类型成为非类型化。

方法还可以接收任意数量的参数，这些参数可能没有显式声明其类型。

Java修饰符可以正常使用，如果没有提供可见性修饰符，则该方法是 `public` 的。

Groovy 中的方法总是返回一些值。如果未提供 `return` 语句，则将返回在执行的最后一行中计算的值。例如，请注意以下方法均不使用 `return` 关键字。

    def someMethod() { 'method called' }                           
    String anotherMethod() { 'another method called' }             
    def thirdMethod(param1) { "$param1 passed" }                   
    static String fourthMethod(String param1) { "$param1 passed" } 

-   未声明返回类型且无参数的方法

-   具有显式返回类型且无参数的方法

-   带有未定义类型的参数的方法

-   带有字符串参数的静态方法

### 命名参数

与构造函数一样，普通方法也可以使用命名参数来调用。为了支持这种表示法，使用了一种约定，其中方法的第一个参数是 Map 。在方法主体中，可以像普通map ( map.key ) 中一样访问参数值。如果该方法只有一个 `Map` 参数，则必须命名所有提供的参数。

    def foo(Map args) { "${args.name}: ${args.age}" }
    foo(name: 'Marie', age: 1)

#### 混合命名参数和位置参数

命名参数可以与位置参数混合。在这种情况下，除了作为第一个参数的 Map 参数之外，方法将根据需要具有其他位置参数。调用方法时提供的位置参数必须按顺序排列。命名参数可以位于任何位置。它们被合并到map中并自动作为第一个参数传递。

    def foo(Map args, Integer number) { "${args.name}: ${args.age}, and the number is ${number}" }
    foo(name: 'Marie', age: 1, 23)  
    foo(23, name: 'Marie', age: 1)  

-   使用 Integer 类型的附加 number 参数调用方法

-   改变参数顺序的方法调用

如果不是 `Map` 作为第一个参数，则必须为该参数提供 Map 而不是命名参数。如果不这样做将导致 `groovy.lang.MissingMethodException` ：

    def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
    foo(name: 'Marie', age: 1, 23)  

-   方法调用抛出 `groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23]` ，因为命名参数 Map 不是第一个参数

如果我们用显式的 `Map` 参数替换命名参数，则可以避免上述异常：

    def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
    foo(23, [name: 'Marie', age: 1])  

-   显式 Map 参数代替命名参数使调用有效

尽管 Groovy 允许您混合命名参数和位置参数，但它可能会导致不必要的混乱。谨慎混合命名参数和位置参数。

### 默认参数

默认参数使参数可选。如果未提供参数，则该方法采用默认值。

    def foo(String par1, Integer par2 = 1) { [name: par1, age: par2] }
    assert foo('Marie').age == 1

参数从右侧删除，但强制参数永远不会删除。

    def baz(a = 'a', int b, c = 'c', boolean d, e = 'e') { "$a $b $c $d $e" }
    
    assert baz(42, true) == 'a 42 c true e'
    assert baz('A', 42, true) == 'A 42 c true e'
    assert baz('A', 42, 'C', true) == 'A 42 C true e'
    assert baz('A', 42, 'C', true, 'E') == 'A 42 C true E'

同样的规则适用于构造函数和方法。如果使用 `@TupleConstructor` ，则应用其他配置选项。

### 可变参数

Groovy 支持具有可变数量参数的方法。它们的定义如下： `def foo(p1, …​, pn, T…​ args)` 。这里 foo 默认支持 `n` 参数，但也支持超过 `n` 的未指定数量的其他参数。

    def foo(Object... args) { args.length }
    assert foo() == 0
    assert foo(1) == 1
    assert foo(1, 2) == 2

T此示例定义了一个方法 `foo` ，该方法可以采用任意数量的参数，包括根本不带参数。 `args.length` 将返回给定参数的数量。 Groovy 允许 `T[]` 作为 `T…​` 的替代表示法。这意味着任何以数组作为最后一个参数的方法都被 Groovy 视为可以采用可变数量参数的方法。

    def foo(Object[] args) { args.length }
    assert foo() == 0
    assert foo(1) == 1
    assert foo(1, 2) == 2

**如果使用** `null` **作为 可变参数 来调用带有 可变参数 的方法，则参数将为 null 而不是长度为 1 且以 null 作为唯一参数的数组元素**。

    def foo(Object... args) { args }
    assert foo(null) == null

如果使用数组作为参数调用 可变参数方法，则参数将是该数组，而不是包含给定数组作为唯一元素的长度为 1 的数组。

    def foo(Object... args) { args }
    Integer[] ints = [1, 2]
    assert foo(ints) == [1, 2]

另一个重要的点是可变参数与方法重载的结合。如果方法重载，Groovy 将选择最具体的方法。例如，如果方法 `foo` 采用 `T` 类型的 可变 参数，而另一个方法 `foo` 也采用 `T` 类型的参数，则第二种方法是首选。

    def foo(Object... args) { 1 }
    def foo(Object x) { 2 }
    assert foo() == 1
    assert foo(1) == 2
    assert foo(1, 2) == 1

### 方法选择算法

Dynamic Groovy 支持 [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch)（也称为多重方法）。调用方法时，实际调用的方法是根据方法参数的运行时类型动态确定的。首先将考虑方法名称和参数数量（包括允许可变参数），然后考虑每个参数的类型。考虑以下方法定义：

    def method(Object o1, Object o2) { 'o/o' }
    def method(Integer i, String  s) { 'i/s' }
    def method(String  s, Integer i) { 's/i' }

也许正如预期的那样，使用 `String` 和 `Integer` 参数调用 `method` 会调用我们的第三个方法定义。

    assert method('foo', 42) == 's/i'

这里更有趣的是编译时类型未知的情况。也许参数被声明为 `Object` 类型（在我们的例子中是此类对象的列表）。 Java 将确定在所有情况下都将选择 `method(Object, Object)` 变体（除非使用强制转换），但如以下示例所示，Groovy 使用运行时类型并将调用每个方法一次（并且不进行类型转换）：

    List<List<Object>> pairs = [['foo', 1], [2, 'bar'], [3, 4]]
    assert pairs.collect { a, b -> method(a, b) } == ['s/i', 'i/s', 'o/o']

对于三个方法调用中的前两个，都找到了参数类型的精确匹配。对于第三次调用，未找到 `method(Integer, Integer)` 的精确匹配，但 `method(Object, Object)` 仍然有效并将被选择。

方法选择就是从具有兼容参数类型的有效候选方法中找到最接近的拟合。因此， `method(Object, Object)` 对于前两次调用也有效，但不如类型完全匹配的变体那么接近匹配。为了确定最接近的拟合，运行时有一个实际参数类型与声明的参数类型之间的距离的概念，并尝试最小化所有参数的总距离。

下表说明了影响距离计算的一些因素。

+--------------------------------------------------------------------+---------------------------------------------------------------------+
| Aspect                                                             | Example                                                             |
+====================================================================+=====================================================================+
| 直接实现的接口比继承层次结构中更高层的接口匹配得更紧密。           | 给定这些接口和方法定义：                                            |
|                                                                    |                                                                     |
|                                                                    |     interface I1 {}                                                 |
|                                                                    |     interface I2 extends I1 {}                                      |
|                                                                    |     interface I3 {}                                                 |
|                                                                    |     class Clazz implements I3, I2 {}                                |
|                                                                    |                                                                     |
|                                                                    |     def method(I1 i1) { 'I1' }                                      |
|                                                                    |     def method(I3 i3) { 'I3' }                                      |
|                                                                    |                                                                     |
|                                                                    | 直接实现的接口将匹配：                                              |
|                                                                    |                                                                     |
|                                                                    |     assert method(new Clazz()) == 'I3'                              |
+--------------------------------------------------------------------+---------------------------------------------------------------------+
| 对象数组优于对象。                                                 |     def method(Object[] arg) { 'array' }                            |
|                                                                    |     def method(Object arg) { 'object' }                             |
|                                                                    |                                                                     |
|                                                                    |     assert method([] as Object[]) == 'array'                        |
+--------------------------------------------------------------------+---------------------------------------------------------------------+
| 非可变参数变体比可变参数变体更优。                                 |     def method(String s, Object... vargs) { 'vararg' }              |
|                                                                    |     def method(String s) { 'non-vararg' }                           |
|                                                                    |                                                                     |
|                                                                    |     assert method('foo') == 'non-vararg'                            |
+--------------------------------------------------------------------+---------------------------------------------------------------------+
| 如果两个 vararg 变体适用，则首选使用最少数量的 vararg 参数的变体。 |     def method(String s, Object... vargs) { 'two vargs' }           |
|                                                                    |     def method(String s, Integer i, Object... vargs) { 'one varg' } |
|                                                                    |                                                                     |
|                                                                    |     assert method('foo', 35, new Date()) == 'one varg'              |
+--------------------------------------------------------------------+---------------------------------------------------------------------+
| 接口优先于超类。                                                   |     interface I {}                                                  |
|                                                                    |     class Base {}                                                   |
|                                                                    |     class Child extends Base implements I {}                        |
|                                                                    |                                                                     |
|                                                                    |     def method(Base b) { 'superclass' }                             |
|                                                                    |     def method(I i) { 'interface' }                                 |
|                                                                    |                                                                     |
|                                                                    |     assert method(new Child()) == 'interface'                       |
+--------------------------------------------------------------------+---------------------------------------------------------------------+
| 对于原始参数类型，首选相同或稍大的声明参数类型。                   |     def method(Long l) { 'Long' }                                   |
|                                                                    |     def method(Short s) { 'Short' }                                 |
|                                                                    |     def method(BigInteger bi) { 'BigInteger' }                      |
|                                                                    |                                                                     |
|                                                                    |     assert method(35) == 'Long'                                     |
+--------------------------------------------------------------------+---------------------------------------------------------------------+

在两个变体具有完全相同的距离的情况下，这被认为是不明确的并且将导致运行时异常：

    def method(Date d, Object o) { 'd/o' }
    def method(Object o, String s) { 'o/s' }
    
    def ex = shouldFail {
        println method(new Date(), 'baz')
    }
    assert ex.message.contains('Ambiguous method overloading')

可以使用类型转换来选择所需的方法：

    assert method(new Date(), (Object)'baz') == 'd/o'
    assert method((Object)new Date(), 'baz') == 'o/s'

### 声明异常

Groovy 自动允许您像对待unchecked exceptions一样对待unchecked exceptions。这意味着您不需要声明方法可能抛出的任何已检查异常，如以下示例所示，如果未找到文件，该方法可能会抛出 `FileNotFoundException` ：

    def badRead() {
        new File('doesNotExist.txt').text
    }
    
    shouldFail(FileNotFoundException) {
        badRead()
    }

您也不需要将对上例中的 badRead 方法的调用包含在 `try/catch` 块中 - 尽管您可以根据需要自由地这样做。

如果您希望声明代码可能抛出的任何异常（checked or otherwise），您可以随意这样做。添加异常不会改变代码在其他 Groovy 代码中的使用方式，但可以被视为代码文档。异常将成为字节码中方法声明的一部分，因此如果您的代码可能从 Java 调用，则包含它们可能会很有用。以下示例说明了如何使用显式检查异常声明：

    def badRead() throws FileNotFoundException {
        new File('doesNotExist.txt').text
    }
    
    shouldFail(FileNotFoundException) {
        badRead()
    }

## 字段和属性

### 字段

字段用于存储数据, 是类、接口或特征的成员。 Groovy 中的字段具有：

-   一个必须得访问修饰符 (`public`, `protected`, or `private`)

-   一个或多个可选修饰符 (`static`, `final`, `synchronized`)

-   一个可选的类型

-   一个必选的名称

```{=html}
<!-- -->
```
    class Data {
        private int id                                  
        protected String description                    
        public static final boolean DEBUG = false       
    }

-   名为 `id` 的 `private` 字段，类型为 `int`

-   名为 `description` 的 `protected` 字段，类型为 `String`

-   名为 `DEBU`、类型为 `boolean` 的 `public static final` 字段

字段可以直接在声明时初始化：

    class Data {
        private String id = IDGenerator.next() 
        // ...
    }

-   私有字段 id 用 `IDGenerator.next()` 初始化

可以省略字段的类型声明。然而，这被认为是一种不好的做法，一般来说，对字段使用强类型是一个好主意：

    class BadPractice {
        private mapping                         
    }
    class GoodPractice {
        private Map<String,String> mapping      
    }

-   字段 `mapping` 未声明类型

-   字段 `mapping` 具有强类型

如果您想使用可选的类型检查，则两者之间的区别很重要。作为类的设计文档，它也很重要。但是，在某些情况下（例如脚本编写或您想依赖鸭子类型），省略类型可能会很有用。

### 属性

属性是类的外部可见特征。 与使用公共字段来表示此功能（这提供了更有限的抽象并会限制重构的可能性）不同，Java中的经典实现是遵循 JavaBeans 规范中概述的约定，即使用以下组合来表示属性：private字段和 getter/setter。

Groovy 遵循这些相同的约定，但提供了一种更简单的方法来定义属性。您可以使用以下方式定义属性：

-   无需访问修饰符 (no `public`, `protected` or `private`)

-   一个或多个可选修饰符 (`static`, `final`, `synchronized`)

-   一个可选类型

-   一个必选的名称

然后 Groovy 将适当地生成 getter/setter。例如：

    class Person {
        String name                             
        int age                                 
    }

-   创建一个支持 `private String name` 字段、一个 `getName` 和一个 `setName` 方法

-   创建一个支持 `private int age` 字段、一个 `getAge` 和一个 `setAge` 方法

如果属性声明为 `final` ，则不会生成 setter：

    class Person {
        final String name                   
        final int age                       
        Person(String name, int age) {
            this.name = name                
            this.age = age                  
        }
    }

-   定义类型 `String` 的只读属性

-   定义类型 `int` 的只读属性

-   将 `name` 参数分配给 `name` 字段

-   将 `age` 参数分配给 `age` 字段

属性通过名称访问，并且会透明地调用 `getter` 或 `setter` ，除非代码位于定义该属性的类中：

    class Person {
        String name
        void name(String name) {
            this.name = "Wonder $name"      
        }
        String title() {
            this.name                       
        }
    }
    def p = new Person()
    p.name = 'Diana'                        
    assert p.name == 'Diana'                
    p.name('Woman')                         
    assert p.title() == 'Wonder Woman'      

-   `this.name` 将直接访问该字段，因为该属性是从定义它的类中访问的

-   类似地，读取访问是直接在 `name` 字段上完成的

-   对属性的写访问是在 `Person` 类外部完成的，因此它将隐式调用 `setName`

-   对属性的读取访问是在 `Person` 类之外完成的，因此它将隐式调用 `getName`

-   这将调用 `Person` 上的 `name` 方法，该方法执行对该字段的直接访问

-   这将调用 `Person` 上的 `title` 方法，该方法对字段执行直接读取访问

值得注意的是，这种直接访问支持字段的行为是为了防止在定义属性的类中使用属性访问语法时出现堆栈溢出(调用属性自动转换到setter上, setter中调用属性有转到setter上)。

可以通过实例的 `properties` 属性来列出所有属性

    class Person {
        String name
        int age
    }
    def p = new Person()
    assert p.properties.keySet().containsAll(['name','age'])

按照惯例，即使没有支持字段，只要存在遵循 Java Beans 规范的 getter 或 setter，Groovy 也会识别属性。例如：

    class PseudoProperties {
        // a pseudo property "name"
        void setName(String name) {}
        String getName() {}
    
        // a pseudo read-only property "age"
        int getAge() { 42 }
    
        // a pseudo write-only property "groovy"
        void setGroovy(boolean groovy) {  }
    }
    def p = new PseudoProperties()
    p.name = 'Foo'                      
    assert p.age == 42                  
    p.groovy = true                     

-   允许写入 p.name ，因为存在伪属性 name

-   允许读取 p.age ，因为存在伪只读属性 age

-   允许写入 p.groovy ，因为存在伪只写属性 groovy

这种语法糖是许多用 Groovy 编写的 DSL 的核心。

#### 属性命名规范

通常建议属性名称的前两个字母小写，对于多单词属性，使用驼峰式大小写。在这些情况下，生成的 `getter` 和 `setter` 的名称将通过将属性名称大写并添加 `get` 或 `set` 前缀（布尔 `getter` 的 `is` ）来形成。因此， `getLength` 将是 `length` 属性的 `getter` ，而 `setFirstName` 将是 `firstName` 属性的 `setter`。 `isEmpty` 可能是名为 `empty` 的属性的 `getter` 方法名称。

以大写字母开头的属性名称将具有仅添加前缀的 getter/setter。因此，即使属性 `Foo` 不遵循建议的命名约定，也是允许的。对于此属性，访问器方法将为 `setFoo` 和 `getFoo` 。这样做的结果是不允许您同时拥有 `foo` 和 `Foo` 属性，因为它们将具有相同的命名访问器方法。

JavaBeans 规范对通常可能是首字母缩略词的属性做了特殊处理。如果属性名称的前两个字母为大写，则不执行大写（或更重要的是，如果从访问器方法名称生成属性名称，则不执行小写）。因此， `getURL` 将是 `URL` 属性的 `getter` 。

由于 JavaBeans 规范中特殊的"首字母缩略词处理"属性命名逻辑，属性名称的转换是不对称的。这会导致一些奇怪的边缘情况。 Groovy 采用了一种命名约定，避免了一种歧义，这种歧义可能看起来有点奇怪，但在 Groovy 设计时很流行，并且由于历史原因一直保留（到目前为止）。 Groovy 查看属性名称的第二个字母。如果这是大写字母，则该属性被视为首字母缩略词样式属性之一，并且不进行大写，否则进行正常大写。尽管我们从不推荐它，但它确实允许您拥有看似"重复命名"的属性，例如您可以有 `aProp` 和 `AProp` ，或 `pNAME` 和 `PNAME` 。 `getter` 分别是 `getaProp` 和 `getAProp` 以及 `getpNAME` 和 `getPNAME` 。

#### 属性的修饰符

我们已经看到属性是通过省略可见性修饰符来定义的。一般来说，任何其他修饰符，例如 `transient` 将被复制到该字段。有两个特殊情况值得注意：

-   `final` ，我们之前看到的是只读属性，被复制到支持字段上，但也导致没有定义 setter

-   `static` 被复制到支持字段，但也会导致访问器方法成为静态

如果您希望将像 `final` 这样的修饰符也保留到访问器方法中，则可以手动编写属性或考虑使用[拆分属性定义](#split-properties)。

#### 属性上的注解

注解（包括与 AST 转换相关的注解）将被复制到属性的支持字段。这允许适用于字段的 AST 转换应用于属性，例如：

    class Animal {
        int lowerCount = 0
        @Lazy String name = { lower().toUpperCase() }()
        String lower() { lowerCount++; 'sloth' }
    }
    
    def a = new Animal()
    assert a.lowerCount == 0  
    assert a.name == 'SLOTH'  
    assert a.lowerCount == 1  

-   确认没有急切初始化

-   正常的财产访问

-   确认属性访问时才初始化

#### 使用显式支持字段拆分属性定义

当您的类设计遵循某些与常见 JavaBean 实践一致的约定时，Groovy 的属性语法是一种方便的速记方式。如果您的类不完全符合这些约定，您当然可以像在 Java 中一样编写 getter、setter 和支持字段。

However, Groovy does provide a split definition capability which still provides a shortened syntax while allowing slight adjustments to the conventions. For a split definition, you write a field and a property with the same name and type. Only one of the field or property may have an initial value.

For split properties, annotations on the field remain on the backing field for the property. Annotations on the property part of the definition are copied onto the getter and setter methods.

This mechanism allows a number of common variations that property users may wish to use if the standard property definition doesn't exactly fit their needs. For example, if the backing field should be `protected` rather than `private`:

    class HasPropertyWithProtectedField {
        protected String name  
        String name            
    }

-   Protected backing field for name property instead of normal private one

-   Declare name property

或者，相同的示例，但具有包私有支持字段：

    class HasPropertyWithPackagePrivateField {
        String name                
        @PackageScope String name  
    }

-   Declare name property

-   Package-private backing field for name property instead of normal private one

As a final example, we may wish to apply method-related AST transforms, or in general, any annotation to the setters/getters, e.g. to have the accessors be synchronized:

    class HasPropertyWithSynchronizedAccessorMethods {
        private String name        
        @Synchronized String name  
    }

-   Backing field for name property

-   Declare name property with annotation for setter/getter

#### 显式的setter/getter方法

如果类中明确定义了 getter 或 setter，则不会自动生成访问器方法。这允许您根据需要修改此类 getter 或 setter 的正常行为。通常不考虑继承的访问器方法，但如果继承的访问器方法被标记为最终的，这也将导致不生成额外的访问器方法来满足此类方法没有子类化的 final 要求。

# 注解

## 定义注解

注解是一种专用于注解代码元素的特殊接口。注解是一种类型，其超级接口是 `java.lang.annotation.Annotation` 接口。注解的声明方式与接口非常相似，使用 `@interface` 关键字：

    @interface SomeAnnotation {}

注解可以以不带主体和可选默认值的方法的形式定义成员。可能的成员类型仅限于：

-   基础类型

-   java.lang.String

-   java.lang.Class

-   java.lang.Enum

-   另外一个注解类型

-   或者以上类型的数组

例如:

    @interface SomeAnnotation {
        String value()                          
    }
    @interface SomeAnnotation {
        String value() default 'something'      
    }
    @interface SomeAnnotation {
        int step()                              
    }
    @interface SomeAnnotation {
        Class appliesTo()                       
    }
    @interface SomeAnnotation {}
    @interface SomeAnnotations {
        SomeAnnotation[] value()                
    }
    enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
    @interface Scheduled {
        DayOfWeek dayOfWeek()                   
    }

-   定义 `String` 类型的 `value` 成员的注解

-   定义 `String` 类型的 `value` 成员的注解，默认值为 something

-   定义原始类型 `int` 类型的 `step` 成员的注解

-   定义 `Class` 类型的 `appliesTo` 成员的注解

-   定义 `value` 成员的注解，其类型是另一个注解类型的数组

-   定义 `dayOfWeek` 成员的注解，其类型为枚举类型 `DayOfWeek`

与 Java 语言不同，在 Groovy 中，注解可用于更改语言的语义。对于将基于注解生成代码的 AST 转换尤其如此。

### 使用注解的位置

注解可以应用于代码的各个元素：

    @SomeAnnotation                 
    void someMethod() {
        // ...
    }
    
    @SomeAnnotation                 
    class SomeClass {}
    
    @SomeAnnotation String var      

-   `` @SomeAnnotation `适用于 `someMethod `` 方法

-   `@SomeAnnotation` 适用于 `SomeClass` 类

-   `@SomeAnnotation` 适用于 `var` 变量

为了限制注解的应用范围，需要在注解定义上使用 `java.lang.annotation.Target` 注解进行声明。例如，以下是如何声明注解可以应用于类或方法：

    import java.lang.annotation.ElementType
    import java.lang.annotation.Target
    
    @Target([ElementType.METHOD, ElementType.TYPE])     
    @interface SomeAnnotation {}                        

-   `@Target` 注解限定注解的使用位置

-   因此， `@SomeAnnotation` 只能在 `TYPE` 或 `METHOD` 上使用

`java.lang.annotation.ElementType` 中提供了可能的 `Target` 的列表。

Groovy 不支持 Java 8 中引入的 `java.lang.annotation.ElementType#TYPE_PARAMETER` 和 `java.lang.annotation.ElementType#TYPE_PARAMETER` 元素类型。

### 注解中成员的值

当使用注解时，至少需要设置所有没有默认值的成员。例如：

    @interface Page {
        int statusCode()
    }
    
    @Page(statusCode=404)
    void notFound() {
        // ...
    }

但是，如果 `value` 是唯一需要被设置的成员，则可以在注解值的声明中省略 `value=` ：

    @interface Page {
        String value()
        int statusCode() default 200
    }
    
    @Page(value='/home')                    
    void home() {
        // ...
    }
    
    @Page('/users')                         
    void userList() {
        // ...
    }
    
    @Page(value='error',statusCode=404)     
    void notFound() {
        // ...
    }

-   我们可以省略 `statusCode` ，因为它有默认值，但需要设置 value

-   由于 `value` 是唯一没有默认值的强制成员，因此我们可以省略 `value=`

-   如果 `value` 和 `statusCode` 都需要设置，则需要使用 `value=` 作为默认的 `value` 成员

### 保留策略

注解的可见性取决于其保留策略。注解的保留策略是使用 `java.lang.annotation.Retention` 注解设置的：

    import java.lang.annotation.Retention
    import java.lang.annotation.RetentionPolicy
    
    @Retention(RetentionPolicy.SOURCE)                   
    @interface SomeAnnotation {}                         

-   `@Retention` 注解 `@SomeAnnotation`

-   因此 `@SomeAnnotation` 将具有 `SOURCE` 保留策略

`java.lang.annotation.RetentionPolicy` 枚举中提供了可能的保留目标和描述的列表。选择通常取决于您希望注解在编译时还是运行时可见。

### Closure annotation parameters

Groovy 中注解的一个有趣功能是您可以使用闭包作为注解值。因此，注解可以与多种表达式一起使用，并且仍然具有 IDE 支持。例如，想象一个框架，您希望在其中根据环境约束（例如 JDK 版本或操作系统）执行一些方法。可以编写以下代码：

    class Tasks {
        Set result = []
        void alwaysExecuted() {
            result << 1
        }
        @OnlyIf({ jdk>=6 })
        void supportedOnlyInJDK6() {
            result << 'JDK 6'
        }
        @OnlyIf({ jdk>=7 && windows })
        void requiresJDK7AndWindows() {
            result << 'JDK 7 Windows'
        }
    }

要使 `@OnlyIf` 注解接受 `Closure` 作为参数，您只需将 `value` 声明为 `Class` ：

    @Retention(RetentionPolicy.RUNTIME)
    @interface OnlyIf {
        Class value()                    
    }

为了完成该示例，让我们编写一个使用该信息的示例运行程序：

    class Runner {
        static <T> T run(Class<T> taskClass) {
            def tasks = taskClass.newInstance()                                         
            def params = [jdk: 6, windows: false]                                       
            tasks.class.declaredMethods.each { m ->                                     
                if (Modifier.isPublic(m.modifiers) && m.parameterTypes.length == 0) {   
                    def onlyIf = m.getAnnotation(OnlyIf)                                
                    if (onlyIf) {
                        Closure cl = onlyIf.value().newInstance(tasks,tasks)            
                        cl.delegate = params                                            
                        if (cl()) {                                                     
                            m.invoke(tasks)                                             
                        }
                    } else {
                        m.invoke(tasks)                                                 
                    }
                }
            }
            tasks                                                                       
        }
    }

-   创建一个实例

-   模拟 JDK 6 并且不是 Windows 的环境

-   迭代任务类的所有声明的方法

-   如果该方法是公共的并且不带参数

-   尝试找到 \@OnlyIf 注解

-   如果找到，则获取 value 并从中创建一个新的 Closure

-   将闭包的 delegate 设置为我们的环境变量

-   调用闭包，即注解闭包。它将返回一个 boolean

-   如果是 true ，则调用该方法

-   如果该方法没有用 \@OnlyIf 注解，则无论如何执行该方法

-   之后，返回任务对象

可以这样使用：

    def tasks = Runner.run(Tasks)
    assert tasks.result == [1, 'JDK 6'] as Set

## Meta-annotations

### 声明元注解

元注解，也称为注解别名，是 **在编译时被其他注解替换的注解**（一个元注解是一个或多个注解的别名）。元注解可用于减少涉及多个注解的代码的大小。

让我们从一个简单的例子开始。假设您有 `@Service` 和 `@Transactional` 注解，并且您想用这两者注解一个类：

    @Service
    @Transactional
    class MyTransactionalService {}

考虑到您可以添加到同一个类中的注解数量增多，元注解可以通过将两个注解减少为具有完全相同语义的单个注解来提供帮助。例如，我们可能想这样写：

    @TransactionalService                           
    class MyTransactionalService {}

-   `@TransactionalService` 是元注解

元注解被声明为常规注解，但被 `@AnnotationCollector` 和一系列其正在收集的注解列表进行注解。在我们的例子中， `@TransactionalService` 注解可以这样写：

    import groovy.transform.AnnotationCollector
    
    @Service                                        
    @Transactional                                  
    @AnnotationCollector                            
    @interface TransactionalService {
    }

-   使用 \@Service 注释元注解

-   使用 \@Transactional 注释元注解

-   使用 \@AnnotationCollector 注释元注解

### 元注解的行为

Groovy supports both *precompiled* and *source form* meta-annotations. This means that your meta-annotation *may* be precompiled, or you can have it in the same source tree as the one you are currently compiling.

INFO: Meta-annotations are a Groovy-only feature. There is no chance for you to annotate a Java class with a meta-annotation and hope it will do the same as in Groovy. Likewise, you cannot write a meta-annotation in Java: both the meta-annotation definition **and** usage have to be Groovy code. But you can happily collect Java annotations and Groovy annotations within your meta-annotation.

When the Groovy compiler encounters a class annotated with a meta-annotation, it **replaces** it with the collected annotations. So, in our previous example, it will replace `@TransactionalService` with `@Transactional` and `@Service`:

    def annotations = MyTransactionalService.annotations*.annotationType()
    assert (Service in annotations)
    assert (Transactional in annotations)

The conversion from a meta-annotation to the collected annotations is performed during the *semantic analysis* compilation phase. 

In addition to replacing the alias with the collected annotations, a meta-annotation is capable of processing them, including arguments.

### 元注解的参数

元注解可以收集带有参数的注解。为了说明这一点，我们将想象两个注解，每个注解都接受一个参数：

    @Timeout(after=3600)
    @Dangerous(type='explosive')

假设您要创建一个名为 `@Explosive` 的元注解：

    @Timeout(after=3600)
    @Dangerous(type='explosive')
    @AnnotationCollector
    public @interface Explosive {}

默认情况下，当 `@Explosive` 被替换时，`@Timeout` `` @Dangerous`将获取 `@Explosive `` 中定义的对应的参数值。更有趣的是，元注解支持覆盖特定值：

    @Explosive(after=0)                 
    class Bomb {}

-   作为参数提供给 \@Explosive 的 after 值会覆盖 \@Timeout 注解中定义的值

如果两个注解定义了相同的参数名称，则默认处理器会将注解值复制到所有接受该参数的注解：

    @Retention(RetentionPolicy.RUNTIME)
    public @interface Foo {
       String value()                                   
    }
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Bar {
        String value()                                  
    }
    
    @Foo
    @Bar
    @AnnotationCollector
    public @interface FooBar {}                         
    
    @Foo('a')
    @Bar('b')
    class Bob {}                                        
    
    assert Bob.getAnnotation(Foo).value() == 'a'        
    println Bob.getAnnotation(Bar).value() == 'b'       
    
    @FooBar('a')
    class Joe {}                                        
    assert Joe.getAnnotation(Foo).value() == 'a'        
    println Joe.getAnnotation(Bar).value() == 'a'       

-   \@Foo 注解定义 String 类型的 value 成员

-   \@Bar 注解还定义了 String 类型的 value 成员

-   \@FooBar 元注解聚合 \@Foo 和 \@Bar

-   类 Bob 用 \@Foo 和 \@Bar 注解

-   Bob 上的 \@Foo 注解的值为 a

-   而 Bob 上的 \@Bar 注解的值为 b

-   类 Joe 用 \@FooBar 注解

-   那么 Joe 上的 \@Foo 注解的值为 a

-   Joe 上的 \@Bar 注解的值也是 a

在第二种情况下，元注解值被复制到 \@Foo 和 \@Bar 注解中。

如果收集的注解定义了具有不兼容类型的相同成员，则会出现编译时错误。例如，如果在前面的示例中 \@Foo 定义了 String 类型的值，但 \@Bar 定义了 int 类型的值。

然而，可以自定义元注解的行为并描述如何扩展收集的注解。我们很快就会了解如何做到这一点，但首先要介绍一个高级处理选项。

### 处理元注解中的重复注解

\@AnnotationCollector 注解支持 mode 参数，该参数可用于更改默认处理器在存在重复注解的情况下处理注解替换的方式。

INFO: Custom processors （接下来讨论）可能支持也可能不支持此参数。

例如，假设您创建一个包含 \@ToString 注解的元注解，然后将元注解放在已经具有显式 \@ToString 注解的类上。这应该是一个错误吗？是否应该应用这两个注解？其中一个优先于另一个吗？没有正确答案。在某些情况下，这些答案中的任何一个都可能是正确的。因此，Groovy 不是试图抢占一种正确的方法来处理重复注解问题，而是让您编写自己的自定义元注解处理器（接下来介绍），并让您在 AST 转换中编写您喜欢的任何检查逻辑 - 这是一个常见的目标用于聚合。话虽如此，通过简单地设置 mode ，在任何额外的编码中都会自动为您处理许多常见的预期场景。 mode 参数的行为由所选的 AnnotationCollectorMode 枚举值确定，并总结在下表中。

----------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Mode                                Description

  DUPLICATE                           Annotations from the annotation collection will always be inserted. After all transforms have been run, it will be an error if multiple annotations (excluding those with SOURCE retention) exist.

  PREFER_COLLECTOR                    Annotations from the collector will be added and any existing annotations with the same name will be removed.

  PREFER_COLLECTOR_MERGED             Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation.

  PREFER_EXPLICIT                     Annotations from the collector will be ignored if any existing annotations with the same name are found.

  PREFER_EXPLICIT_MERGED              Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations.
----------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 自定义元注解处理器

自定义注解处理器将允许您选择如何将元注解扩展为收集的注解。在这种情况下，元注解的行为完全取决于您。为此，您必须：

-   创建一个元注解处理器，扩展 org.codehaus.groovy.transform.AnnotationCollectorTransform

-   声明要在元注解声明中使用的处理器

为了说明这一点，我们将探讨元注解 \@CompileDynamic 是如何实现的。

\@CompileDynamic 是一个元注解，可扩展为 \@CompileStatic(TypeCheckingMode.SKIP) 。问题是默认的元注解处理器不支持枚举，并且注解值 TypeCheckingMode.SKIP 是 1。

这里的简单实现是行不通的：

    @CompileStatic(TypeCheckingMode.SKIP)
    @AnnotationCollector
    public @interface CompileDynamic {}

相反，我们将这样定义它：

    @AnnotationCollector(processor = "org.codehaus.groovy.transform.CompileDynamicProcessor")
    public @interface CompileDynamic {
    }

The first thing you may notice is that our interface is no longer annotated with `@CompileStatic`. The reason for this is that we rely on the `processor` parameter instead, that references a class which will **generate** the annotation.

Here is how the custom processor is implemented:

**CompileDynamicProcessor.groovy**

    @CompileStatic                                                                  
    class CompileDynamicProcessor extends AnnotationCollectorTransform {            
        private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic)    
        private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) 
    
        List<AnnotationNode> visit(AnnotationNode collector,                        
                                   AnnotationNode aliasAnnotationUsage,             
                                   AnnotatedNode aliasAnnotated,                    
                                   SourceUnit source) {                             
            def node = new AnnotationNode(CS_NODE)                                  
            def enumRef = new PropertyExpression(
                new ClassExpression(TC_NODE), "SKIP")                               
            node.addMember("value", enumRef)                                        
            Collections.singletonList(node)                                         
        }
    }

-   our custom processor is written in Groovy, and for better compilation performance, we use static compilation

-   the custom processor has to extend gapi:org.codehaus.groovy.transform.AnnotationCollectorTransform\[AnnotationCollectorTransform\]

-   create a class node representing the `@CompileStatic` annotation type

-   create a class node representing the `TypeCheckingMode` enum type

-   `collector` is the `@AnnotationCollector` node found in the meta-annotation. Usually unused.

-   `aliasAnnotationUsage` is the meta-annotation being expanded, here it is `@CompileDynamic`

-   `aliasAnnotated` is the node being annotated with the meta-annotation

-   `sourceUnit` is the `SourceUnit` being compiled

-   we create a new annotation node for `@CompileStatic`

-   we create an expression equivalent to `TypeCheckingMode.SKIP`

-   we add that expression to the annotation node, which is now `@CompileStatic(TypeCheckingMode.SKIP)`

-   return the generated annotation

In the example, the `visit` method is the only method which has to be overridden. It is meant to return a list of annotation nodes that will be added to the node annotated with the meta-annotation. In this example, we return a single one corresponding to `@CompileStatic(TypeCheckingMode.SKIP)`.

# 特质

特质是groovy的结构构造，它允许：

-   行为的构成

-   接口的运行时实现

-   行为的重写

-   与静态类型检查/编译的兼容性

**它们可以被视为携带默认实现和状态的interface**。使用 trait 关键字定义特质：

    trait FlyingAbility {                           
            String fly() { "I'm flying!" }          
    }

-   特性的声明

-   特质内方法的声明

然后就可以像接口一样使用 `implements` 关键字来使用它：

    class Bird implements FlyingAbility {}          
    def b = new Bird()                              
    assert b.fly() == "I'm flying!"                 

-   将特质 FlyingAbility 添加到 Bird 类功能中

-   实例化一个新的 Bird

-   Bird 类自动获取 FlyingAbility 特质的行为

特质提供了广泛的功能，从简单的组合到测试，本节将对此进行详细描述。

## 方法

### Public 方法

在特质中声明方法可以像类中的常规方法一样：

    trait FlyingAbility {                           
            String fly() { "I'm flying!" }          
    }

-   特性的声明

-   特质内方法的声明

### Abstract methods

此外，特质也可以声明抽象方法，因此需要在实现特质的类中实现：

    trait Greetable {
        abstract String name()                              
        String greeting() { "Hello, ${name()}!" }           
    }

-   实现类必须声明 name 方法

-   可与具体方法进行混合

然后可以像这样使用该特质：

    class Person implements Greetable {                     
        String name() { 'Bob' }                             
    }
    
    def p = new Person()
    assert p.greeting() == 'Hello, Bob!'                    

-   实现特质 Greetable

-   由于 name 是抽象的，因此需要实现它

-   然后可以调用 greeting

### Private 方法

特质还可以定义私有方法。这些方法不会出现在实现特质的子类中：

    trait Greeter {
        private String greetingMessage() {                      
            'Hello from a private method!'
        }
        String greet() {
            def m = greetingMessage()                           
            println m
            m
        }
    }
    class GreetingMachine implements Greeter {}                 
    def g = new GreetingMachine()
    assert g.greet() == "Hello from a private method!"          
    try {
        assert g.greetingMessage()                              
    } catch (MissingMethodException e) {
        println "greetingMessage is private in trait"
    }

-   在特质中定义私有方法 greetingMessage

-   公共 greet 消息默认调用 greetingMessage

-   创建一个实现该特质的类

-   greet 可以被调用

-   但 greetingMessage 不行

特质仅支持 public 和 private 方法。 protected 和 `package private` 范围均不受支持。

### Final 方法

如果我们有一个实现特质的类，从概念上讲，特质方法的实现将"继承"到该类中。但实际上，不存在包含此类实现的基类。相反，它们直接融入课堂。方法的最终修饰符仅指示编织方法的修饰符。虽然继承和覆盖或乘以具有相同签名但混合了最终和非最终变体的继承方法可能被认为是不好的风格，但 Groovy 并不禁止这种情况。应用正常方法选择，并且所使用的修饰符将根据结果方法确定。如果您想要无法重写的特质实现方法，您可以考虑创建一个实现所需特质的基类。

If we have a class implementing a trait, conceptually implementations from the trait methods are \"inherited\" into the class. But, in reality, there is no base class containing such implementations. Rather, they are woven directly into the class. A final modifier on a method just indicates what the modifier will be for the woven method. While it would likely be considered bad style to inherit and override or multiply inherit methods with the same signature but a mix of final and non-final variants, Groovy doesn't prohibit this scenario. Normal method selection applies and the modifier used will be determined from the resulting method. You might consider creating a base class which implements the desired trait(s) if you want trait implementation methods that can't be overridden.

## this的含义

this 代表具体实现的实例。将特质视为一个父类。这意味着当你写：

    trait Introspector {
        def whoAmI() { this }
    }
    class Foo implements Introspector {}
    def foo = new Foo()

然后调用：

    foo.whoAmI()

将返回相同的实例：

    assert foo.whoAmI().is(foo)

## 接口

特质可以实现接口，在这种情况下，使用 `implements` 关键字声明接口：

    interface Named {                                       
        String name()
    }
    trait Greetable implements Named {                      
        String greeting() { "Hello, ${name()}!" }
    }
    class Person implements Greetable {                     
        String name() { 'Bob' }                             
    }
    
    def p = new Person()
    assert p.greeting() == 'Hello, Bob!'                    
    assert p instanceof Named                               
    assert p instanceof Greetable                           

-   普通接口的声明

-   将 Named 添加到已实现的接口列表中

-   声明一个实现 Greetable 特质的类

-   实现缺少的 name 方法

-   greeting 实现来自特质

-   确保 Person 实现 Named 接口

-   确保 Person 实现 Greetable 特质

## 属性

特质可以定义属性，如下例所示：

    trait Named {
        String name                             
    }
    class Person implements Named {}            
    def p = new Person(name: 'Bob')             
    assert p.name == 'Bob'                      
    assert p.getName() == 'Bob'                 

-   在特质中声明属性 name

-   声明一个实现该特质的类

-   该属性自动可见

-   可以使用属性访问器来访问它

-   或使用常规 getter 语法

## 字段

### Private字段

由于特质允许使用私有方法，因此使用私有字段来存储状态也很有趣。特质可以让你做到这一点：

    trait Counter {
        private int count = 0                   
        int count() { count += 1; count }       
    }
    class Foo implements Counter {}             
    def f = new Foo()
    assert f.count() == 1                       
    assert f.count() == 2

-   在特质中声明私有字段 count

-   声明一个公共方法 count 来增加计数器并返回它

-   声明一个实现 Counter 特质的类

-   count 方法可以使用私有字段来保存状态

这是与 Java 8 [Java 8 virtual extension methods](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)的一个主要区别。虽然虚拟扩展方法不携带状态，但特质可以。此外，从 Java 6 开始支持 Groovy 中的特质，因为它们的实现不依赖于虚拟扩展方法。这意味着即使一个特质可以从 Java 的角度视为常规接口，该接口也不会具有default方法，只有抽象方法。

### Public字段

公共字段的工作方式与私有字段相同，但为了避免http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\[菱形问题\]问题，字段名称在实现类中重新映射：

    trait Named {
        public String name                      
    }
    class Person implements Named {}            
    def p = new Person()                        
    p.Named__name = 'Bob'                       

-   在特质内声明一个公共字段

-   声明一个实现该特质的类

-   创建该类的一个实例

-   公共字段可用，但已重命名

字段的名称取决于特质的完全限定名称。包中的所有点（ . ）都替换为下划线（ \_ ），最终名称包含双下划线。因此，如果字段的类型为 String ，包的名称为 my.package ，特质的名称为 Foo ，字段的名称为 bar ，在实现类中，公共字段将显示为：

    String my_package_Foo__bar

虽然特质支持公共字段，但不建议使用它们，并被认为是一种不好的做法。

## 行为的组合

Traits 可用于实现多重继承。例如，我们可以具有以下特质：

    trait FlyingAbility {                           
            String fly() { "I'm flying!" }          
    }
    trait SpeakingAbility {
        String speak() { "I'm speaking!" }
    }

以及一个实现这两个特质的类：

    class Duck implements FlyingAbility, SpeakingAbility {} 
    
    def d = new Duck()                                      
    assert d.fly() == "I'm flying!"                         
    assert d.speak() == "I'm speaking!"                     

-   Duck 类同时实现 FlyingAbility 和 SpeakingAbility

-   创建 Duck 的新实例

-   我们可以从 FlyingAbility 调用方法 fly

-   还有 SpeakingAbility 中的方法 speak

特质鼓励对象之间重用功能，并通过现有行为的组合来创建新类。

## 重写default方法

特质提供方法的默认实现，但可以在实现类中重写它们。例如，我们可以稍微改变上面的例子，让鸭子嘎嘎叫：

    class Duck implements FlyingAbility, SpeakingAbility {
        String quack() { "Quack!" }                         
        String speak() { quack() }                          
    }
    
    def d = new Duck()
    assert d.fly() == "I'm flying!"                         
    assert d.quack() == "Quack!"                            
    assert d.speak() == "Quack!"                            

-   定义一个特定于 Duck 的方法，名为 quack

-   覆盖 speak 的默认实现，以便我们使用 quack 代替

-   鸭子仍然在飞

-   quack 来自 Duck 类

-   speak 不再使用 SpeakingAbility 中的默认实现

## 特质的继承

### 简单继承

特质可能会扩展另一个特质，在这种情况下，您必须使用 extends 关键字：

    trait Named {
        String name                                     
    }
    trait Polite extends Named {                        
        String introduce() { "Hello, I am $name" }      
    }
    class Person implements Polite {}
    def p = new Person(name: 'Alice')                   
    assert p.introduce() == 'Hello, I am Alice'         

-   Named 特质定义单个 name 属性

-   Polite 特性扩展了 Named 特性

-   Polite 添加了一个新方法，可以访问父特质的 name 属性

-   name 属性在实现 Polite 的 Person 类中可见

-   与 introduce 方法一样

### 多重继承

一个特质可以继承多个特质。在这种情况下，所有父特质都必须在 implements 子句中声明：

    trait WithId {                                      
        Long id
    }
    trait WithName {                                    
        String name
    }
    trait Identified implements WithId, WithName {}     

-   WithId 特质定义 id 属性

-   WithName 特质定义 name 属性

-   Identified 是继承 WithId 和 WithName 的特质

## 鸭子类型与特质

### 动态代码

Traits 可以调用任何动态代码，就像普通的 Groovy 类一样。这意味着 **您可以在方法主体中调用应该存在于实现类中的方法，而无需在接口中显式声明它们**。这意味着特质与鸭子类型完全兼容：

    trait SpeakingDuck {
        String speak() { quack() }                      
    }
    class Duck implements SpeakingDuck {
        String methodMissing(String name, args) {
            "${name.capitalize()}!"                     
        }
    }
    def d = new Duck()
    assert d.speak() == 'Quack!'                        

-   SpeakingDuck 期望定义 quack 方法

-   Duck 类 实现了 methodMissing 方法方法

-   调用 speak 方法会触发对 quack 的调用，该调用由 methodMissing 处理

### 特质中的动态方法

特质还可以实现 MOP 方法，例如 methodMissing 或 propertyMissing ，在这种情况下，实现类将从特质继承行为，如下例所示：

    trait DynamicObject {                               
        private Map props = [:]
        def methodMissing(String name, args) {
            name.toUpperCase()
        }
        def propertyMissing(String name) {
            props.get(name)
        }
        void setProperty(String name, Object value) {
            props.put(name, value)
        }
    }
    
    class Dynamic implements DynamicObject {
        String existingProperty = 'ok'                  
        String existingMethod() { 'ok' }                
    }
    def d = new Dynamic()
    assert d.existingProperty == 'ok'                   
    assert d.foo == null                                
    d.foo = 'bar'                                       
    assert d.foo == 'bar'                               
    assert d.existingMethod() == 'ok'                   
    assert d.someMethod() == 'SOMEMETHOD'               

-   创建一个实现多个 MOP 方法的特质

-   Dynamic 类定义一个属性

-   Dynamic 类定义了一个方法

-   调用现有属性将调用 Dynamic 中的方法

-   调用不存在的属性将调用特质中的方法

-   将调用特质上定义的 setProperty

-   将调用特质上定义的 getProperty

-   调用 Dynamic 上的现有方法

-   但由于 methodMissing 特性而调用不存在的方法

## 多重继承的冲突

### 默认冲突解决方案

一个类可以实现多个特质。如果某个特质定义的方法与另一个特质中的方法具有相同的签名，则会发生冲突：

    trait A {
        String exec() { 'A' }               
    }
    trait B {
        String exec() { 'B' }               
    }
    class C implements A,B {}               

-   Trait A 定义了一个名为 exec 的方法，返回一个 String

-   特质 B 定义了完全相同的方法

-   类 C 实现了这两个特质

在这种情况下，默认行为是 implements 子句中最后声明的特质中的方法获胜。这里， B 是在 A 之后声明的，因此 B 中的方法将被选取：

    def c = new C()
    assert c.exec() == 'B'

### User conflict resolution

如果这种行为不是您想要的，您可以使用 Trait.super.foo 语法显式选择要调用的方法。在上面的示例中，我们可以通过编写以下内容来确保调用特质 A 中的方法：

    class C implements A,B {
        String exec() { A.super.exec() }    
    }
    def c = new C()
    assert c.exec() == 'A'                  

-   从特质 A 显式调用 exec

-   调用 A 中的版本，而不是使用默认的 B 中的版本

## 特质的运行时实现

### 在运行时实现特质

Groovy 还支持在运行时动态实现特质。它允许您使用特质"装饰"现有对象。作为一个例子，让我们从这个特质和下面的类开始：

    trait Extra {
        String extra() { "I'm an extra method" }            
    }
    class Something {                                       
        String doSomething() { 'Something' }                
    }

-   Extra 特质定义了 extra 方法

-   Something 类未实现 Extra 特质

-   Something 只定义了一个方法 doSomething

那么如果我们这样做：

    def s = new Something()
    s.extra()

对 extra 的调用将失败，因为 Something 未实现 Extra 。可以使用以下语法在运行时执行此操作：

    def s = new Something() as Extra                        
    s.extra()                                               
    s.doSomething()                                         

-   使用 as 关键字在运行时将对象强制为特质

-   然后可以在对象上调用 extra

-   并且 doSomething 仍然可以调用

当将对象强制为特质时，操作的结果与原来的实例不是同一个实例。被强制的对象将实现原始对象实现的特质和接口，但不会是原始类的实例。

### 一次实现多个特质

如果您需要一次实现多个特质，您可以使用 withTraits 方法而不是 as 关键字：

    trait A { void methodFromA() {} }
    trait B { void methodFromB() {} }
    
    class C {}
    
    def c = new C()
    c.methodFromA()                     
    c.methodFromB()                     
    def d = c.withTraits A, B           
    d.methodFromA()                     
    d.methodFromB()                     

-   调用 methodFromA 将失败，因为 C 未实现 A

-   调用 methodFromB 将失败，因为 C 未实现 B

-   withTrait 将把 c 包装成实现 A 和 B 的东西

-   methodFromA 现在将通过，因为 d 实现了 A

-   methodFromB 现在将通过，因为 d 也实现了 B

当将一个对象强制为多个特质时，操作的结果与原来的实例不是同一个实例。被强制的对象将实现原始对象实现的特质和接口，但不会是原始类的实例。

## 链式行为

Groovy 支持可堆叠特质的概念。这个想法是，如果当前特质无法处理消息，则将一个特质委托给另一个特质。为了说明这一点，让我们想象一个像这样的消息处理程序接口：

    interface MessageHandler {
        void on(String message, Map payload)
    }

然后，您可以通过应用小行为来编写消息处理程序。例如，让我们以特质的形式定义一个默认处理程序：

    trait DefaultHandler implements MessageHandler {
        void on(String message, Map payload) {
            println "Received $message with payload $payload"
        }
    }

然后任何类都可以通过实现该特质来继承默认处理程序的行为：

    class SimpleHandler implements DefaultHandler {}

现在，如果您想记录除了默认处理程序之外的所有消息怎么办？一种选择是这样写：

    class SimpleHandlerWithLogging implements DefaultHandler {
        void on(String message, Map payload) {                                  
            println "Seeing $message with payload $payload"                     
            DefaultHandler.super.on(message, payload)                           
        }
    }

-   显式实现 on 方法

-   执行日志记录

-   继续执行 DefaultHandler 特质中的行为

这是可行的，但这种方法有缺点：

1.  日志逻辑绑定到"具体"处理程序

2.  我们在 on 方法中显式引用了 DefaultHandler ，这意味着如果我们碰巧更改了类实现的特质，代码将会被破坏

作为替代方案，我们可以编写另一个特质，其责任仅限于日志记录：

    trait LoggingHandler implements MessageHandler {                            
        void on(String message, Map payload) {
            println "Seeing $message with payload $payload"                     
            super.on(message, payload)                                          
        }
    }

-   日志处理程序本身就是一个处理程序

-   打印收到的消息

-   然后 super 使其将调用委托给链中的下一个特质

那么我们的类可以重写为：

    class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
    def loggingHandler = new HandlerWithLogger()
    loggingHandler.on('test logging', [:])

这将打印：

    Seeing test logging with payload [:]
    Received test logging with payload [:]

由于优先级规则意味着 LoggerHandler 获胜，因为它是最后声明的，因此对 on 的调用将使用 LoggingHandler 的实现。但后者调用了 super ，这意味着链中的下一个特质。在这里，下一个特质是 DefaultHandler 因此两者都会被调用：

如果我们添加第三个处理程序，该处理程序负责处理以 say 开头的消息，那么这种方法的好处就变得更加明显：

    trait SayHandler implements MessageHandler {
        void on(String message, Map payload) {
            if (message.startsWith("say")) {                                    
                println "I say ${message - 'say'}!"
            } else {
                super.on(message, payload)                                      
            }
        }
    }

-   处理程序特定的先决条件

-   如果不满足前提条件，则将消息传递给链中的下一个处理程序

然后我们的最终处理程序如下所示：

    class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
    def h = new Handler()
    h.on('foo', [:])
    h.on('sayHello', [:])

这意味着

-   消息将首先通过日志处理程序

-   日志处理程序调用 super ，它将委托给下一个处理程序，即 SayHandler

-   如果消息以 say 开头，则处理程序将使用该消息

-   如果没有， say 处理程序将委托给链中的下一个处理程序

这种方法非常强大，因为它允许您编写彼此不认识的处理程序，但又可以按照您想要的顺序组合它们。例如，如果我们执行代码，它将打印：

    Seeing foo with payload [:]
    Received foo with payload [:]
    Seeing sayHello with payload [:]
    I say Hello!

但是如果我们将日志处理程序移至链中的第二个，则输出会有所不同：

    class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
    h = new AlternateHandler()
    h.on('foo', [:])
    h.on('sayHello', [:])

打印:

    Seeing foo with payload [:]
    Received foo with payload [:]
    I say Hello!

原因是，现在，由于 SayHandler 在不调用 super 的情况下使用消息，因此不再调用日志记录处理程序。

### Trait 内 super 的语义

如果一个类实现了多个特质并且发现了对 super 的调用，则：

1.  如果该类实现了另一个特质，则调用将委托给链中的下一个特质

2.  如果链中没有剩余的特质了，则 super 引用实现类的超类（this）

例如，由于以下行为，可以装饰最终类：

    trait Filtering {                                       
        StringBuilder append(String str) {                  
            def subst = str.replace('o','')                 
            super.append(subst)                             
        }
        String toString() { super.toString() }              
    }
    def sb = new StringBuilder().withTraits Filtering       
    sb.append('Groovy')
    assert sb.toString() == 'Grvy'                          

-   定义一个名为 Filtering 的特质，应该在运行时应用于 StringBuilder

-   重新定义 append 方法

-   删除字符串中的所有"o"

-   然后委托给 super

-   如果调用 toString ，则委托给 super.toString

-   StringBuilder 实例上 Filtering 特质的运行时实现

-   已附加的字符串不再包含字母 o

在这个例子中，当遇到 super.append 时，目标对象没有实现其他trait，所以调用的方法是原来的 append 方法，也就是说来自 StringBuilder 。同样的技巧也用于 toString ，以便生成的代理对象的字符串表示形式委托给 StringBuilder 实例的 toString 。

## 高级功能

### SAM 类型强制

如果一个特质定义了单个抽象方法，那么它就是 SAM（单个抽象方法）类型强制的候选者。例如，想象一下以下特质：

    trait Greeter {
        String greet() { "Hello $name" }        
        abstract String getName()               
    }

-   greet 方法不是抽象方法，调用抽象方法 getName

-   getName 是一个抽象方法

由于 getName 是 Greeter 特质中的单个抽象方法，因此您可以编写：

    Greeter greeter = { 'Alice' }               

-   闭包"成为" getName 单个抽象方法的实现

or even:

    void greet(Greeter g) { println g.greet() } 
    greet { 'Alice' }                           

-   greet 方法接受 SAM 类型 Greeter 作为参数

-   我们可以直接调用它, 并传递闭包

### 与 Java 8 默认方法的差异

在 Java 8 中，接口可以具有default方法。如果一个类实现了一个接口并且没有重写该default方法，则会使用接口的default方法。特质与此类似，但有一个主要区别：**如果特质和父类上有相同的方法, 那么默认使用特质上的**.

如果您想覆盖已实现的方法的行为，此功能可用于以非常精确的方式组合行为。

为了说明这个概念，让我们从这个简单的例子开始：

    import groovy.test.GroovyTestCase
    import groovy.transform.CompileStatic
    import org.codehaus.groovy.control.CompilerConfiguration
    import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
    import org.codehaus.groovy.control.customizers.ImportCustomizer
    
    class SomeTest extends GroovyTestCase {
        def config
        def shell
    
        void setup() {
            config = new CompilerConfiguration()
            shell = new GroovyShell(config)
        }
        void testSomething() {
            assert shell.evaluate('1+1') == 2
        }
        void otherTest() { /* ... */ }
    }

在此示例中，我们创建一个简单的测试用例，它使用两个属性（config 和 shell）并在多个测试方法中使用这些属性。现在假设您想要测试相同的内容，但使用另一个不同的编译器配置。一种选择是创建 SomeTest 的子类：

    class AnotherTest extends SomeTest {
        void setup() {
            config = new CompilerConfiguration()
            config.addCompilationCustomizers( ... )
            shell = new GroovyShell(config)
        }
    }

它有效，但是如果您实际上有多个测试类，并且您想要测试所有这些测试类的新配置怎么办？然后你必须为每个测试类创建一个不同的子类：

    class YetAnotherTest extends SomeTest {
        void setup() {
            config = new CompilerConfiguration()
            config.addCompilationCustomizers( ... )
            shell = new GroovyShell(config)
        }
    }

然后你看到的是，两个测试的 setup 方法是相同的。那么，我们的办法就是创造一个特质：

    trait MyTestSupport {
        void setup() {
            config = new CompilerConfiguration()
            config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
            shell = new GroovyShell(config)
        }
    }

然后在子类中使用它：

    class AnotherTest extends SomeTest implements MyTestSupport {}
    class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
    ...

它将允许我们显着减少样板代码，并降低在我们决定更改设置代码时忘记更改设置代码的风险。**即使 setup 已经在父类中实现，由于测试类在其接口列表中声明了特质，因此默认使用特质中的行为**！

当您无法访问父类源代码时，此功能特别有用。它可用于模拟方法或强制子类中方法的特定实现。它允许您重构代码，将被覆盖的逻辑保留在单个特质中，并通过实现它来继承新的行为。当然，另一种方法是在您将使用新代码的每个地方重写该方法。

值得注意的是，如果您使用运行时特质，则特质中的方法始终优先于原始对象的方法：

    class Person {
        String name                                         
    }
    trait Bob {
        String getName() { 'Bob' }                          
    }
    
    def p = new Person(name: 'Alice')
    assert p.name == 'Alice'                                
    def p2 = p as Bob                                       
    assert p2.name == 'Bob'                                 

-   Person 类定义了 name 属性，该属性产生 getName 方法

-   Bob 是一个特质，它将 getName 定义为返回 Bob

-   默认对象将返回 Alice

-   p2 在运行时将 p 强制转换为 Bob

-   getName 返回 Bob，因为 getName 来自特质

Again, don't forget that dynamic trait coercion returns a distinct object which only implements the original interfaces, as well as the traits.

## 与 mixins 的区别

Mixins 在概念上存在一些差异，因为它们在 Groovy 中可用。请注意，我们谈论的是运行时 mixin，而不是 \@Mixin 注解，@Mixin 注解已被弃用。

首先，特质中定义的方法在字节码中可见：

-   在内部，该特质表示为一个接口（没有默认或静态方法）和几个辅助类

-   这意味着实现特质的对象有效地实现了接口

-   这些方法在 Java 中是可见的

-   它们与类型检查和静态编译兼容

相反，通过 mixin 添加的方法仅在运行时可见：

    class A { String methodFromA() { 'A' } }        
    class B { String methodFromB() { 'B' } }        
    A.metaClass.mixin B                             
    def o = new A()
    assert o.methodFromA() == 'A'                   
    assert o.methodFromB() == 'B'                   
    assert o instanceof A                           
    assert !(o instanceof B)                        

-   类 A 定义 methodFromA

-   类 B 定义 methodFromB

-   将B混入A中

-   我们可以调用 methodFromA

-   我们也可以调用 methodFromB

-   该对象是 A 的实例

-   但它不是 B 的实例

最后一点实际上非常重要，它说明了 mixin 比 Trait 具有优势的地方：实例不会被修改，因此如果您将某个类混合到另一个类中，则不会生成第三个类，and methods which respond to A will continue responding to A even if mixed in.

## 静态的方法、属性和字段

以下说明需谨慎。静态成员支持正在进行中，并且仍处于试验阶段。以下信息仅适用于 {groovyVersion}。

可以在特质中定义静态方法，但它有许多限制： \* 具有静态方法的特质无法进行静态编译或类型检查。所有静态方法、属性和字段都是动态访问的（这是 JVM 的限制）。 \* 静态方法不会出现在每个特质生成的接口中。 \* 该特质被视为实现类的模板，这意味着每个实现类将获得自己的静态方法、属性和字段。因此，在特质上声明的静态成员不属于 Trait ，而是属于其实现类。 \* You should typically not mix static and instance methods of the same signature. The normal rules for applying traits apply (including multiple inheritance conflict resolution). If the method chosen is static but some implemented trait has an instance variant, a compilation error will occur. If the method chosen is the instance variant, the static variant will be ignored (the behavior is similar to static methods in Java interfaces for this case). 通常不应混合具有相同签名的静态方法和实例方法。应用特质的正常规则适用（包括多重继承冲突解决）。如果选择的方法是静态的，但某些实现的特质具有实例变体，则会发生编译错误。如果选择的方法是实例变体，则静态变体将被忽略（在这种情况下，其行为类似于 Java 接口中的静态方法）。

让我们从一个简单的例子开始：

    trait TestHelper {
        public static boolean CALLED = false        
        static void init() {                        
            CALLED = true                           
        }
    }
    class Foo implements TestHelper {}
    Foo.init()                                      
    assert Foo.TestHelper__CALLED                   

-   静态字段在特质中声明

-   特质中还声明了一个静态方法

-   静态字段在特质内更新

-   静态方法 init 可供实现类使用

-   重新映射静态场以避免钻石问题

与往常一样，不建议使用公共字段。不管怎样，如果你想要这个，你必须明白下面的代码会失败：

    Foo.CALLED = true

因为特质本身没有定义静态字段 CALLED。同样，如果您有两个不同的实现类，则每个类都会获得一个不同的静态字段：

    class Bar implements TestHelper {}              
    class Baz implements TestHelper {}              
    Bar.init()                                      
    assert Bar.TestHelper__CALLED                   
    assert !Baz.TestHelper__CALLED                  

-   类 Bar 实现该特质

-   类 Baz 也实现了该特质

-   init 仅在 Bar 上调用

-   Bar 上的静态字段 CALLED 已更新

-   但 Baz 上的静态字段 CALLED 不是，因为它是不同的

## 状态继承的陷阱

我们已经看到特质是有状态的。特质可以定义字段或属性，但是当类实现特质时，它会根据每个特质获取这些字段/属性。因此，请考虑以下示例：

    trait IntCouple {
        int x = 1
        int y = 2
        int sum() { x+y }
    }

该特质定义了两个属性， x 和 y ，以及一个 sum 方法。现在让我们创建一个实现该特质的类：

    class BaseElem implements IntCouple {
        int f() { sum() }
    }
    def base = new BaseElem()
    assert base.f() == 3

调用 f 的结果是 3 ，因为 f 委托给特质中的 sum ，它具有状态。但如果我们改写这个呢？

    class Elem implements IntCouple {
        int x = 3                                       
        int y = 4                                       
        int f() { sum() }                               
    }
    def elem = new Elem()

-   覆盖属性 x

-   覆盖属性 y

-   从特质调用 sum

如果您调用 elem.f() ，预期输出是什么？其实是：

    assert elem.f() == 3

原因是 sum 方法访问特质的字段。因此它使用特质中定义的 x 和 y 值。如果您想使用实现类中的值，则需要使用 getter 和 setter 来取消引用字段，如下所示：

    trait IntCouple {
        int x = 1
        int y = 2
        int sum() { getX()+getY() }
    }
    
    class Elem implements IntCouple {
        int x = 3
        int y = 4
        int f() { sum() }
    }
    def elem = new Elem()
    assert elem.f() == 7

## Self types

### 特质的类型限制

有时您会想编写一个只能应用于某种类型的特质。例如，您可能希望在一个类上应用一个特质，该特质扩展了另一个超出您控制范围的类，并且仍然能够调用这些方法。为了说明这一点，让我们从这个例子开始：

    class CommunicationService {
        static void sendMessage(String from, String to, String message) {       
            println "$from sent [$message] to $to"
        }
    }
    
    class Device { String id }                                                  
    
    trait Communicating {
        void sendMessage(Device to, String message) {
            CommunicationService.sendMessage(id, to.id, message)                
        }
    }
    
    class MyDevice extends Device implements Communicating {}                   
    
    def bob = new MyDevice(id:'Bob')
    def alice = new MyDevice(id:'Alice')
    bob.sendMessage(alice,'secret')                                             

-   A `Service` class, beyond your control (in a library, ...​) defines a `sendMessage` method

-   A `Device` class, beyond your control (in a library, ...​)

-   Defines a communicating trait for devices that can call the service

-   Defines `MyDevice` as a communicating device

-   The method from the trait is called, and `id` is resolved

很明显， Communicating 特质只能应用于 Device 。然而，没有明确的契约表明这一点，因为特质不能扩展类。然而，代码编译并运行得很好，因为特质方法中的 id 将被动态解析。问题是没有什么可以阻止该特质应用于任何不是 Device 的类。任何具有 id 属性的类都可以工作，而任何不具有 id 属性的类都会导致运行时错误。

如果您想启用类型检查或在特质上应用 \@CompileStatic ，问题会更加复杂：因为特质不知道自己是 Device ，类型检查器会抱怨说它找不到 id 属性。

一种可能性是在特质中显式添加 getId 方法，但这并不能解决所有问题。如果一个方法需要 this 作为参数，并且实际上要求它是 Device 该怎么办？

    class SecurityService {
        static void check(Device d) { if (d.id==null) throw new SecurityException() }
    }

如果您希望能够在特质中调用 this ，那么您将明确需要将 this 转换为 Device 。如果到处显式转换为 this ，这很快就会变得不可读。

### \@SelfType注解

为了使这个契约明确，并使类型检查器了解其自身的类型，Groovy 提供了一个 \@SelfType 注解，它将：

-   让您声明实现此特质的类必须继承或实现的类型

-   如果不满足这些类型约束，则抛出编译时错误

因此，在前面的示例中，我们可以使用 \@groovy.transform.SelfType 注解来修复该特质：

    @SelfType(Device)
    @CompileStatic
    trait Communicating {
        void sendMessage(Device to, String message) {
            SecurityService.check(this)
            CommunicationService.sendMessage(id, to.id, message)
        }
    }

现在，如果您尝试在不是 Device 的类上实现此特质，则会出现编译时错误：

    class MyDevice implements Communicating {} // forgot to extend Device

错误将是：

    class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'

总之，自我类型是声明对特质的约束的有效方式，而不必直接在特质中声明契约或必须在各处使用强制转换，从而保持关注点的分离尽可能紧密。

### 与 Sealed 注解（孵化中）的差异

Both `@Sealed` and `@SelfType` restrict classes which use a trait but in orthogonal ways. Consider the following example:

    interface HasHeight { double getHeight() }
    interface HasArea { double getArea() }
    
    @SelfType([HasHeight, HasArea])                       
    @Sealed(permittedSubclasses=[UnitCylinder,UnitCube])  
    trait HasVolume {
        double getVolume() { height * area }
    }
    
    final class UnitCube implements HasVolume, HasHeight, HasArea {
        // for the purposes of this example: h=1, w=1, l=1
        double height = 1d
        double area = 1d
    }
    
    final class UnitCylinder implements HasVolume, HasHeight, HasArea {
        // for the purposes of this example: h=1, diameter=1
        // radius=diameter/2, area=PI * r^2
        double height = 1d
        double area = Math.PI * 0.5d**2
    }
    
    assert new UnitCube().volume == 1d
    assert new UnitCylinder().volume == 0.7853981633974483d

-   All usages of the `HasVolume` trait must implement or extend both `HasHeight` and `HasArea`

-   Only `UnitCube` or `UnitCylinder` can use the trait

For the degenerate case where a single class implements a trait, e.g.:

    final class Foo implements FooTrait {}

Then, either:

    @SelfType(Foo)
    trait FooTrait {}

or:

    @Sealed(permittedSubclasses='Foo') 
    trait FooTrait {}

-   Or just `@Sealed` if `Foo` and `FooTrait` are in the same source file

could express this constraint. Generally, the former of these is preferred.

## 局限性

### 与 AST 转换的兼容性

Traits 与 AST 转换不是正式兼容。其中一些（例如 \@CompileStatic ）将应用于特质本身（而不是实现类），而其他一些将应用于实现类和特质。绝对不能保证 AST 转换会像在常规类上一样在特质上运行，因此使用它需要您自担风险！

### 前缀和后缀操作

在特质中，不允许使用前缀和后缀操作更新特质的字段：

    trait Counting {
        int x
        void inc() {
            x++                             
        }
        void dec() {
            --x                             
        }
    }
    class Counter implements Counting {}
    def c = new Counter()
    c.inc()

-   x 在特质中定义，不允许后缀增量

-   x 在特质中定义，不允许前缀递减

解决方法是使用 += 运算符。

# Record类 (孵化中)

Record类是一种特殊的类，可用于对普通数据聚合进行建模。它们提供了比普通类更少的紧凑语法。 Groovy 已经具有 AST 转换，例如 \@Immutable 和 \@Canonical ，它们已经大大减少了仪式，但Record已经在 Java 中引入，并且 Groovy 中的Record类被设计为与 Java Record类保持一致。

例如，假设我们要创建代表电子邮件的 Message 的Record类。出于本示例的目的，我们将此类消息简化为仅包含发件人电子邮件地址、收件人电子邮件地址和消息正文。我们可以如下定义这样的Record类：

    record Message(String from, String to, String body) { }

我们将以与普通类相同的方式使用Record类，如下所示：

    def msg = new Message('me@myhost.com', 'you@yourhost.net', 'Hello!')
    assert msg.toString() == 'Message[from=me@myhost.com, to=you@yourhost.net, body=Hello!]'

简化的仪式使我们免于定义显式字段、getter 和 toString 、 equals 和 hashCode 方法。事实上，它是以下粗略等效的简写：

    final class Message extends Record {
        private final String from
        private final String to
        private final String body
        private static final long serialVersionUID = 0
    
        /* constructor(s) */
    
        final String toString() { /*...*/ }
    
        final boolean equals(Object other) { /*...*/ }
    
        final int hashCode() { /*...*/ }
    
        String from() { from }
        // other getters ...
    }

请注意Record类的getter的特殊命名约定。它们与字段同名（而不是常见的 JavaBean 惯例，大写并带有"get"前缀）。

就像在 Java 中一样，您可以通过编写自己的方法来覆盖通常隐式提供的方法：

    record Point3D(int x, int y, int z) {
        String toString() {
            "Point3D[coords=$x,$y,$z]"
        }
    }
    
    assert new Point3D(10, 20, 30).toString() == 'Point3D[coords=10,20,30]'

您还可以以正常方式对Record类使用泛型。例如，考虑以下 Coord Record类定义：

    record Coord<T extends Number>(T v1, T v2){
        double distFromOrigin() { Math.sqrt(v1()**2 + v2()**2 as double) }
    }

它可以按如下方式使用：

    def r1 = new Coord<Integer>(3, 4)
    assert r1.distFromOrigin() == 5
    def r2 = new Coord<Double>(6d, 2.5d)
    assert r2.distFromOrigin() == 6.5d

## Record类的特殊功能

### 紧凑的构造函数

记录有一个隐式构造函数。这可以通过提供您自己的构造函数来覆盖 - 如果您这样做，您需要确保设置所有字段。

然而，为了简洁起见，可以使用紧凑的构造函数语法。

对于这种特殊情况，仍然提供正常的隐式构造函数，但通过紧凑构造函数定义中提供的语句进行了扩充：

    public record Warning(String message) {
        public Warning {
            Objects.requireNonNull(message)
            message = message.toUpperCase()
        }
    }
    
    def w = new Warning('Help')
    assert w.message() == 'HELP'

### 序列化

Groovy native records类遵循适用于 Java record的可序列化性的https://docs.oracle.com/en/java/javase/16/docs/specs/records-serialization.html\[特殊约定\]。 Groovy record-like 的类（下面讨论）遵循普通的 Java 类可序列化约定。

Groovy *native* records follow the

for serializability which apply to Java records. Groovy *record-like* classes (discussed below) follow normal Java class serializability conventions.

## Groovy 对Record类的增强

### 参数默认值

Groovy 支持构造函数参数的默认值。此功能也适用于记录，如以下记录定义所示，该定义具有 y 和 color 的默认值：

    record ColoredPoint(int x, int y = 0, String color = 'white') {}

Arguments when left off (dropping one or more arguments from the right) are replaced with their defaults values as shown in the following example:

    assert new ColoredPoint(5, 5, 'black').toString() == 'ColoredPoint[x=5, y=5, color=black]'
    assert new ColoredPoint(5, 5).toString() == 'ColoredPoint[x=5, y=5, color=white]'
    assert new ColoredPoint(5).toString() == 'ColoredPoint[x=5, y=0, color=white]'

此处理遵循构造函数默认参数的常规 Groovy 约定，本质上自动为构造函数提供以下签名：

    ColoredPoint(int, int, String)
    ColoredPoint(int, int)
    ColoredPoint(int)

也可以使用命名参数（默认值也适用于此）：

    assert new ColoredPoint(x: 5).toString() == 'ColoredPoint[x=5, y=0, color=white]'
    assert new ColoredPoint(x: 0, y: 5).toString() == 'ColoredPoint[x=0, y=5, color=white]'

您可以禁用默认参数处理，如下所示：

    @TupleConstructor(defaultsMode=DefaultsMode.OFF)
    record ColoredPoint2(int x, int y, String color) {}
    assert new ColoredPoint2(4, 5, 'red').toString() == 'ColoredPoint2[x=4, y=5, color=red]'

这将按照 Java 的默认值生成一个构造函数。如果在这种情况下省略参数，将会出现错误。

您可以强制所有属性具有默认值，如下所示：

    @TupleConstructor(defaultsMode=DefaultsMode.ON)
    record ColoredPoint3(int x, int y = 0, String color = 'white') {}
    assert new ColoredPoint3(y: 5).toString() == 'ColoredPoint3[x=0, y=5, color=white]'

任何没有显式初始值的属性/字段都将被赋予参数类型的默认值（null，0, false）。

我们之前描述了 Message 记录并显示了它的粗略等效项。 Groovy 实际上会经历一个中间阶段，其中 record 关键字被 class 关键字和随附的 \@RecordType 注释替换：

    @RecordType
    class Message {
        String from
        String to
        String body
    }

然后，@RecordType 本身被处理为元注解（注解集合器），并扩展为其组成的子注解，如 \@TupleConstructor、@POJO、@RecordBase 等。在某种意义上，这是一个可以经常忽略的实现细节。然而，如果您希望自定义或配置记录实现，您可能希望回退到 \@RecordType 风格，或者用其中一个组成子注解来增强您的记录类。

### 自定义toString

根据 Java，您可以通过编写自己的方法来自定义记录的 toString 方法。如果您更喜欢更具声明性的样式，您也可以使用 Groovy 的 \@ToString 转换来覆盖默认记录 toString 。例如，可以按如下方式记录三维点：

    package threed
    
    import groovy.transform.ToString
    
    @ToString(ignoreNulls=true, cache=true, includeNames=true,
              leftDelimiter='[', rightDelimiter=']', nameValueSeparator='=')
    record Point(Integer x, Integer y, Integer z=null) { }
    
    assert new Point(10, 20).toString() == 'threed.Point[x=10, y=20]'

自定义 toString:

-   includeNames=true, 包含包名和类名, 默认为false

-   cache=true, 缓存toString的值, 因为我们不会改变Record中的值

-   ignoreNulls=true, 忽略null值

对于二维点，我们可以有类似的定义：

    package twod
    
    import groovy.transform.ToString
    
    @ToString(ignoreNulls=true, cache=true, includeNames=true,
              leftDelimiter='[', rightDelimiter=']', nameValueSeparator='=')
    record Point(Integer x, Integer y) { }
    
    assert new Point(10, 20).toString() == 'twod.Point[x=10, y=20]'

我们可以在这里看到，如果没有包名称，它将具有与前面的示例相同的 toString。

### 获取Record中所有属性的值

我们可以从记录中获取组件值作为列表，如下所示：

    record Point(int x, int y, String color) { }
    
    def p = new Point(100, 200, 'green')
    def (x, y, c) = p.toList()
    assert x == 100
    assert y == 200
    assert c == 'green'

您可以使用 \@RecordOptions(toList=false) 禁用此功能。

### 获取Record中所有属性对应的map

我们可以从记录中获取组件值作为映射，如下所示：

    record Point(int x, int y, String color) { }
    
    def p = new Point(100, 200, 'green')
    assert p.toMap() == [x: 100, y: 200, color: 'green']

您可以使用 \@RecordOptions(toMap=false) 禁用此功能。

### 获取Record中属性的个数

我们可以像这样获取记录中的组件数量：

    record Point(int x, int y, String color) { }
    
    def p = new Point(100, 200, 'green')
    assert p.size() == 3

您可以使用 \@RecordOptions(size=false) 禁用此功能。

### 从Record中获取第n个属性

我们可以使用 Groovy 的正常位置索引来获取记录中的特定组件，如下所示：

    record Point(int x, int y, String color) { }
    
    def p = new Point(100, 200, 'green')
    assert p[1] == 200

您可以使用 \@RecordOptions(getAt=false) 禁用此功能。

## 可选的 Groovy 功能

### Copying

创建某些更改了属性的Record副本可能很有用。这可以使用带有命名参数的可选 copyWith 方法来完成。

复制的Record类的属性是根据提供的参数设置的。

对于未设置的属性，使用原Record的（浅）副本。以下是您可以如何使用 copyWith 作为 Fruit 记录：

    @RecordOptions(copyWith=true)
    record Fruit(String name, double price) {}
    def apple = new Fruit('Apple', 11.6)
    assert 'Apple' == apple.name()
    assert 11.6 == apple.price()
    
    def orange = apple.copyWith(name: 'Orange')
    assert orange.toString() == 'Fruit[name=Orange, price=11.6]'

可以通过将 RecordOptions#copyWith 注释属性设置为 false 来禁用 copyWith 功能。

### 深度不可变

与 Java 一样，记录默认提供浅层不变性。 Groovy 的 \@Immutable 转换对一系列可变数据类型执行防御性复制。记录可以利用这种防御性复制来获得深度不变性，如下所示：

    @ImmutableProperties
    record Shopping(List items) {}
    
    def items = ['bread', 'milk']
    def shop = new Shopping(items)
    items << 'chocolate'
    assert shop.items() == ['bread', 'milk']

这些示例说明了 Groovy 记录功能背后的原理，提供了三个级别的便利性：

-   使用 record 关键字以获得最大程度的简洁性

-   使用注释支持简单的定制

-   当需要完全控制时允许通过正常方法实现

### 获取Record属性对应的tuple

您可以获取记录的组成部分作为类型化元组：

    import groovy.transform.*
    
    @RecordOptions(components=true)
    record Point(int x, int y, String color) { }
    
    @CompileStatic
    def method() {
        def p1 = new Point(100, 200, 'green')
        def (int x1, int y1, String c1) = p1.components()
        assert x1 == 100
        assert y1 == 200
        assert c1 == 'green'
    
        def p2 = new Point(10, 20, 'blue')
        def (x2, y2, c2) = p2.components()
        assert x2 * 10 == 100
        assert y2 ** 2 == 400
        assert c2.toUpperCase() == 'BLUE'
    
        def p3 = new Point(1, 2, 'red')
        assert p3.components() instanceof Tuple3
    }
    
    method()

Groovy 的 TupleN 类数量有限。如果您的记录中有大量属性，则可能无法使用此功能。

## 与 Java 的其他差异

Groovy 支持创建 *record-like* 的Record类以及native records。*record-like* 的Record类不会扩展 Java 的 Record 类，并且此类不会被 Java 视为Record，但会具有类似的属性。

\@RecordOptions 注释（ \@RecordType 的一部分）支持 mode 注释属性，该属性可以采用三个值之一（ AUTO 是默认值） ）：

NATIVE

:   生成一个与 Java 类似的类。在 JDK16 之前的 JDK 上编译时会产生错误。

EMULATE

:   为所有 JDK 版本生成 *record-like* 的Record类。

AUTO

:   Produces a native record for JDK16+ and emulates the record otherwise.

Whether you use the `record` keyword or the `@RecordType` annotation is independent of the mode.

# 密封的层次结构 (incubating)

密封类、接口和特征限制了哪些子类可以扩展/实现它们。在密封类出现之前，类层次结构设计者有两个主要选择：

-   将class设置为final, 不允许继承

-   将class设置为public, 非final, 运行任何人继承

与这些全有或全无的选择相比，密封类提供了一个中间立场。

例如，假设我们要创建一个仅包含圆形和正方形的形状层次结构。我们还希望形状接口能够引用层次结构中的实例。我们可以按如下方式创建层次结构：

    sealed interface ShapeI permits Circle,Square { }
    final class Circle implements ShapeI { }
    final class Square implements ShapeI { }

Groovy 还支持替代注解语法。我们认为关键字样式更好，但如果您的编辑器尚不支持 Groovy 4，您可以选择注解样式。

    @Sealed(permittedSubclasses=[Circle,Square]) interface ShapeI { }
    final class Circle implements ShapeI { }
    final class Square implements ShapeI { }

我们可以有一个 ShapeI 类型的引用，由于 permits 子句，它可以指向 Circle 或 Square ，并且，由于我们的类是 final ，我们知道将来不会将其他类添加到我们的层次结构中。

一般来说，我们可能希望立即锁定类层次结构的某些部分，就像我们在这里将子类标记为 final 但其他时候我们可能希望允许进一步控制继承。

    sealed class Shape permits Circle,Polygon,Rectangle { }
    
    final class Circle extends Shape { }
    
    class Polygon extends Shape { }
    non-sealed class RegularPolygon extends Polygon { }
    final class Hexagon extends Polygon { }
    
    sealed class Rectangle extends Shape permits Square{ }
    final class Square extends Rectangle { }
    @Sealed(permittedSubclasses=[Circle,Polygon,Rectangle]) class Shape { }
    
    final class Circle extends Shape { }
    
    class Polygon extends Shape { }
    @NonSealed class RegularPolygon extends Polygon { }
    final class Hexagon extends Polygon { }
    
    @Sealed(permittedSubclasses=Square) class Rectangle extends Shape { }
    final class Square extends Rectangle { }

 \
在此示例中， Shape 允许的子类是 Circle 、 Polygon 和 Rectangle 。 Circle 是 final ，因此层次结构的该部分无法扩展。

Polygon 是隐式非密封， RegularPolygon 显式标记为 non-sealed 。这意味着我们可以通过子类进行任何进一步的扩展，如 `Polygon → RegularPolygon` 和 `RegularPolygon → Hexagon` 所示。

`Rectangle` 是密封的，并且仅允许 Square 子类。

密封类对于创建需要包含实例特定数据的类似枚举的相关类非常有用。例如，我们可能有以下枚举：

    enum Weather { Rainy, Cloudy, Sunny }
    def forecast = [Weather.Rainy, Weather.Sunny, Weather.Cloudy]
    assert forecast.toString() == '[Rainy, Sunny, Cloudy]'

但我们现在还希望将天气特定数据添加到天气预报中。我们可以按如下方式改变我们的抽象：

    sealed abstract class Weather { }
    @Immutable(includeNames=true) class Rainy extends Weather { Integer expectedRainfall }
    @Immutable(includeNames=true) class Sunny extends Weather { Integer expectedTemp }
    @Immutable(includeNames=true) class Cloudy extends Weather { Integer expectedUV }
    def forecast = [new Rainy(12), new Sunny(35), new Cloudy(6)]
    assert forecast.toString() == '[Rainy(expectedRainfall:12), Sunny(expectedTemp:35), Cloudy(expectedUV:6)]'

在指定代数(Algebraic)或抽象数据类型(Abstract Data Types) (ADT) 时，密封层次结构也很有用，如下例所示：

    import groovy.transform.*
    
    sealed interface Tree<T> {}
    @Singleton final class Empty implements Tree {
        String toString() { 'Empty' }
    }
    @Canonical final class Node<T> implements Tree<T> {
        T value
        Tree<T> left, right
    }
    
    Tree<Integer> tree = new Node<>(42, new Node<>(0, Empty.instance, Empty.instance), Empty.instance)
    assert tree.toString() == 'Node(42, Node(0, Empty, Empty), Empty)'

密封层次结构与Record类也可以配合使用，如以下示例所示：

    sealed interface Expr {}
    record ConstExpr(int i) implements Expr {}
    record PlusExpr(Expr e1, Expr e2) implements Expr {}
    record MinusExpr(Expr e1, Expr e2) implements Expr {}
    record NegExpr(Expr e) implements Expr {}
    
    def threePlusNegOne = new PlusExpr(new ConstExpr(3), new NegExpr(new ConstExpr(1)))
    assert threePlusNegOne.toString() == 'PlusExpr[e1=ConstExpr[i=3], e2=NegExpr[e=ConstExpr[i=1]]]'

## 与 Java 的差异

-   Java provides no default modifier for subclasses of sealed classes and requires that one of `final`, `sealed` or `non-sealed` be specified. Groovy defaults to *non-sealed* but you can still use `non-sealed/@NonSealed` if you wish. We anticipate the style checking tool CodeNarc will eventually have a rule that looks for the presence of `non-sealed` so developers wanting that stricter style will be able to use CodeNarc and that rule if they want.

-   目前，Groovy 不会检查 permittedSubclasses 中提到的所有类在编译时是否可用并与基本密封类一起编译。这可能会在 Groovy 的未来版本中发生变化。

Groovy支持 native封闭类, 也支持通过注解将class标记为封闭类

\@SealedOptions 注解支持 mode 注解属性，该属性可以采用三个值之一（ AUTO 为默认值）：

NATIVE

:   Produces a class similar to what Java would do. Produces an error when compiling on JDKs earlier than JDK17.

EMULATE

:   Indicates the class is sealed using the `@Sealed` annotation. This mechanism works with the Groovy compiler for JDK8+ but is not recognised by the Java compiler.

AUTO

:   Produces a native record for JDK17+ and emulates the record otherwise.

Whether you use the `sealed` keyword or the `@Sealed` annotation is independent of the mode.
