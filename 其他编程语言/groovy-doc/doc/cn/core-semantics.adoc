//////////////////////////////////////////

  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.

//////////////////////////////////////////
ifndef::core-object-orientation[]
:core-object-orientation: core-object-orientation.adoc
endif::[]
ifndef::core-operators[]
:core-operators: core-operators.adoc
endif::[]
ifndef::xml-userguide[]
:xml-userguide: xml-userguide.adoc
endif::[]
ifndef::core-syntax[]
:core-syntax: core-syntax.adoc
endif::[]

= 语义学

本章介绍 Groovy 编程语言的语义。

== 语句

=== 变量定义

可以使用变量的类型（如 String ）或使用关键字 def （或 var ）后跟变量名称来定义变量：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=variable_definition_example,indent=0]
----

当您不想给出显式类型时， def 和 var 充当类型占位符，即替换类型名称。由于您在编译时不关心类型或者依赖于类型推断（具有 Groovy 的静态性质）

变量定义必须具有类型或占位符。如果省略，类型名称将被视为引用现有变量（可能是之前声明的）

对于脚本，未声明的变量被假定来自脚本绑定。在其他情况下，您将得到丢失的属性（动态 Groovy）或编译时错误（静态 Groovy）。如果您将 def 和 var 视为 Object 的别名，您立刻就会明白。

变量定义可以提供一个初始值，在这种情况下，就像将声明和赋值（我们接下来将介绍）合二为一。

[NOTE]
变量定义类型可以通过使用泛型来细化，例如 List<String> names 。要了解有关泛型支持的更多信息，请阅读<<{core-object-orientation}#generics,generics section>>部分。


=== 变量赋值

您可以为变量赋值以供以后使用。请尝试以下操作：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=variable_assignment_example,indent=0]
----

==== 多重赋值

Groovy 支持多重赋值，即可以一次赋值多个变量，例如：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_example,indent=0]
----

如果您愿意，您可以提供类型作为声明的一部分：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_with_types,indent=0]
----

除了在声明变量时使用之外，它也适用于现有变量：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_with_existing_variables,indent=0]
----

该语法适用于数组和列表，以及返回其中任意一个的方法：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_with_arrays_and_lists,indent=0]
----

==== 上溢和下溢

如果左侧有太多变量，多余的变量将用 null 填充：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_overflow,indent=0]
----

如果右侧有太多变量，则多余的变量将被忽略：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=multiple_assignment_underflow,indent=0]
----

==== 使用多重赋值进行对象解构

在描述 Groovy 运算符的部分中，已经介绍了<<{core-operators}#subscript-operator,下标>> 的情况，解释了如何重写 getAt() / putAt() 方法。
In the section describing Groovy's operators,
the case of the <<{core-operators}#subscript-operator,subscript operator>> has been covered,
explaining how you can override the `getAt()`/`putAt()` method.

通过这种技术，我们可以组合多个赋值和下标运算符方法来实现对象解构。

考虑以下不可变的 Coordinates 类，其中包含一对经度和纬度双精度值，并注意我们对 getAt() 方法的实现：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=coordinates-class,indent=0]
----

现在让我们实例化这个类并解构它的经度和纬度：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=destructuring,indent=0]
----
<1> 我们创建 Coordinates 类的实例
<2> 然后，我们使用多重赋值来获取单独的经度和纬度值
<3> 我们可以断言他们的值。

=== 控制结构
==== 条件结构
===== if / else

Groovy 支持 Java 中常见的 if - else 语法

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=if_else_example,indent=0]
----

Groovy 还支持普通的 Java“嵌套”if then else if 语法：

[source,groovy]
----
if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}
----

===== switch / case

Groovy 中的 switch 语句向后兼容 Java 代码；因此有必要在每个case结束时使用 `break` 。

其中一个区别是 Groovy switch 语句可以处理任何类型的 switch 值，并且可以执行不同类型的匹配。

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=switch_case_example,indent=0]
----

Switch 支持以下类型的比较：

* Class case values match if the switch value is an instance of the class
* Regular expression case values match if the `toString()` representation of the switch value matches the regex
* Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)
* Closure case values match if the calling the closure returns a result which is true according to the <<the-groovy-truth,Groovy truth>>
* If none of the above are used then the case value matches if the case value equals the switch value

NOTE: When using a closure case value, the default `it` parameter is actually the switch value (in our example, variable `x`).

Groovy 还支持 switch 表达式，如以下示例所示：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=switch_expression,indent=0]
----

==== 循环结构
===== 经典的for循环

Groovy 支持标准的 Java/C for 循环

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=classic_for_loop_example,indent=0]
----

===== 增强的经典 Java 风格的 for 循环

现在支持使用逗号分隔表达式的 Java 经典 for 循环的更复杂的形式。例子：

[source,groovy]
--------------------------------------
def facts = []
def count = 5
for (int fact = 1, i = 1; i <= count; i++, fact *= i) {
    facts << fact
}
assert facts == [1, 2, 6, 24, 120]
--------------------------------------

===== 与for循环结合的多重赋值

Groovy 从 Groovy 1.6 开始就支持多重赋值语句：

[source,groovy]
--------------------------------------
// multi-assignment with types
def (String x, int y) = ['foo', 42]
assert "$x $y" == 'foo 42'
--------------------------------------

这些现在可以出现在 for 循环中：

[source,groovy]
--------------------------------------
// multi-assignment goes loopy
def baNums = []
for (def (String u, int v) = ['bar', 42]; v < 45; u++, v++) {
    baNums << "$u $v"
}
assert baNums == ['bar 42', 'bas 43', 'bat 44']
--------------------------------------

===== for in 循环

Groovy 中的 for 循环要简单得多，并且适用于任何类型的数组、集合、Map 等。

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=groovy_for_loop_example,indent=0]
----

[NOTE]
Groovy 还支持带有冒号的 Java 冒号变体： `for (char c : text) {}`

===== while 循环

Groovy 像 Java 一样支持常见的 `while {...}` 循环：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=while_loop_example,indent=0]
----

===== do/while 循环

现在支持 Java 类 do/while 循环。例子：


[source,groovy]
--------------------------------------
// classic Java-style do..while loop
def count = 5
def fact = 1
do {
    fact *= count--
} while(count > 1)
assert fact == 120
--------------------------------------

==== 异常处理

异常处理与Java相同。

==== try / catch / finally

您可以指定 try-catch-finally 、 try-catch 或 try-finally 。

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=try_catch_example,indent=0]
----

我们可以将代码放在匹配的“try”子句后面的“finally”子句中，这样无论“try”子句中的代码是否抛出异常，finally子句中的代码都将始终执行：

[source,groovy]
----
include::../../test/SemanticsTest.groovy[tags=try_catch_finally_example,indent=0]
----

==== 多重捕获

使用多 catch 块（自 Groovy 2.0 起），我们能够定义多个要由同一 catch 块捕获和处理的异常：

[source,groovy]
----
try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}
----

==== Try with resources

Groovy 通常为自动资源管理 (ARM) 提供 Java 7 的 try -with-resources 语句的更好替代方案。现在，迁移到 Groovy 但仍想使用旧样式的 Java 程序员支持该语法：

[source,groovy]
--------------------------------------
class FromResource extends ByteArrayInputStream {
    @Override
    void close() throws IOException {
        super.close()
        println "FromResource closing"
    }

    FromResource(String input) {
        super(input.toLowerCase().bytes)
    }
}

class ToResource extends ByteArrayOutputStream {
    @Override
    void close() throws IOException {
        super.close()
        println "ToResource closing"
    }
}

def wrestle(s) {
    try (
            FromResource from = new FromResource(s)
            ToResource to = new ToResource()
    ) {
        to << from
        return to.toString()
    }
}

def wrestle2(s) {
    FromResource from = new FromResource(s)
    try (from; ToResource to = new ToResource()) { // Enhanced try-with-resources in Java 9+
        to << from
        return to.toString()
    }
}

assert wrestle("ARM was here!").contains('arm')
assert wrestle2("ARM was here!").contains('arm')
--------------------------------------
产生以下输出：
--------------------------------------
ToResource closing
FromResource closing
ToResource closing
FromResource closing
--------------------------------------


=== 断言

与 Groovy 与 Java 共享 assert 关键字不同，后者在 Groovy 中的行为非常不同。首先，Groovy 中的断言始终会执行，与 JVM 的 -ea 标志无关。它使其成为单元测试的一流选择。

断言分为 3 部分：

----
assert [left expression] == [right expression] : (optional message)
----

断言的结果与 Java 中得到的结果非常不同。如果断言为真，那么什么也不会发生。如果断言为假，则它提供所断言表达式的每个子表达式的值的可视化表示。例如：

[source,groovy]
----
include::../../test/semantics/PowerAssertTest.groovy[tags=assert_code_1,indent=0]
----

将产生：

----
Caught: Assertion failed:

include::../../test/semantics/PowerAssertTest.groovy[tags=assert_error_1,indent=0]
----

当表达式更复杂时，断言变得非常有趣，如下例所示：

[source,groovy]
----
include::../../test/semantics/PowerAssertTest.groovy[tags=assert_code_2,indent=0]
----

这将打印每个子表达式的值：

[source,groovy]
----
include::../../test/semantics/PowerAssertTest.groovy[tags=assert_error_2,indent=0]
----

如果您不想要像上面那样漂亮的打印错误消息，您可以通过更改断言的可选消息部分来回退到自定义错误消息，如下例所示：

[source,groovy]
----
include::../../test/semantics/PowerAssertTest.groovy[tags=assert_code_3,indent=0]
----

这将打印以下错误消息：

[source,groovy]
----
include::../../test/semantics/PowerAssertTest.groovy[tags=assert_error_3,indent=0]
----


=== 标签语句

任何语句都可以与标签相关联。标签不会影响代码的语义，可用于使代码更易于阅读，如下例所示：

[source,groovy]
----
include::../../test/semantics/LabelsTest.groovy[tags=test_labels,indent=0]
----

尽管没有更改带标签语句的语义，但可以使用 break 指令中的标签作为跳转目标，如下例所示。然而，即使允许这样做，这种编码风格通常也被认为是一种不好的做法：

[source,groovy]
----
include::../../test/semantics/LabelsTest.groovy[tags=label_bad_practice,indent=0]
----

需要明白的是，默认情况下标签对代码的语义没有影响，但是它们属于抽象语法树 (AST)，因此 AST 转换可以使用该信息对代码执行转换，因此导致不同的语义。 Spock 框架尤其这样做是为了使测试更容易。

== 表达式

表达式是 Groovy 程序的构建块，用于引用现有值并执行代码来创建新值。

Groovy 支持许多与 Java 相同类型的表达式，包括：

[cols="a,a"]
.Expressions like Java
|===
| 表达式 |描述
| `foo` | the name of a variable, field, parameter, ...
| `this`, `super`, `it` | special names
| `true`, `10`, `"bar"` | literals
| `String.class` | Class literal
| `(` _expression_ `)`| parenthesised expressions
| `foo++`, `~bar` | Unary link:core-operators.html[operator] expressions
| `foo + bar`, `bar * baz` | Binary link:core-operators.html[operator] expressions
| `foo ? bar : baz` | Ternary link:core-operators.html[operator] expressions
| `(Integer x, Integer y) -> x + y` | Lambda expressions
|
[source,groovy]
----
assert 'bar' == switch('foo') {
  case 'foo' -> 'bar'
}
----
| switch expressions
|===

Groovy 还有一些自己的特殊表达式：

[cols="a,a"]
.Special expressions
|===
| Example expression(s) |Description
| `String` | Abbreviated class literal (when not ambiguous)
| `{ x, y -> x + y }` | Closure expressions
| `[1, 3, 5]` | literal list expressions
| `[a:2, b:4, c:6]` | literal map expressions
|===

Groovy 还扩展了 Java 中用于成员访问的普通点表示法。 Groovy 通过指定某些感兴趣数据的层次结构中的路径，为访问层次结构数据结构提供特殊支持。这些 Groovy 路径表达式称为 GPath 表达式。

[[gpath_expressions]]
=== GPath 表达式

GPath 是集成到 Groovy 中的路径表达式语言，它允许识别部分嵌套结构化数据。从这个意义上说，它与 XPath 对于 XML 具有相似的目标和范围。 GPath 通常用于处理 XML 的上下文中，但它实际上适用于任何对象图。 XPath 使用类似文件系统的路径表示法，即由斜杠分隔各部分的树层次结构 / ，GPath 使用点对象表示法来执行对象导航。

例如，您可以指定感兴趣的对象或元素的路径：

* `a.b.c` -> 对于 XML，获取 a 内 b 内的所有 c 元素
* `a.b.c` -> 对于 POJO，获取 a 的所有 b 属性的 c 属性（有点像 a.getB().getC() 在 JavaBean 中）

在这两种情况下，GPath 表达式都可以被视为对象视图的查询。对于 POJO，对象视图常是由通过对象实例化和组合编写的程序构建的；对于 XML 处理，对象视图是 parsing XML 文本的结果，通常使用 XmlParser 或 XmlSlurper 等类。有关在 Groovy 中使用 XML 的更多详细信息，请参阅<<{xml-userguide}#processing-xml,解析 XML>>。


[TIP]
====
当查询从 XmlParser 或 XmlSlurper 生成的对象视图时，GPath 表达式可以引用使用 @ 表示法的元素上定义的属性：

* `a["@href"]` -> map-like表示法 : 所有 a 元素的 href 属性
* `a.'@href'`  -> 属性表示法 : 另一种表达方式
* `a.@href`    -> 直接表示法 : 另一种表达方式
====

==== 对象导航

让我们看一个简单对象图上的 GPath 表达式的示例，该对象图是使用 java 反射获得的。假设您位于一个类的非静态方法中，该方法具有另一个名为 aMethodFoo 的方法

[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_on_reflection_1,indent=0]
----

以下 GPath 表达式将获取该方法的名称：

[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_on_reflection_2,indent=0]
----

更准确地说，上面的 GPath 表达式生成一个 String 列表，每个字符串都是 this 上现有方法的名称，其中该名称以 Foo 结尾。

现在，考虑到该类中还定义了以下方法：

[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_on_reflection_3,indent=0]
----

那么以下 GPath 表达式将获取 (1) 和 (3) 的名称，但不会获取 (2) 或 (0) 的名称：

[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_on_reflection_4,indent=0]
----

==== 表达式解构

我们可以分解表达式 this.class.methods.name.grep(~/.*Bar/) 以了解 GPath 的计算方式：

`this.class`:: 属性访问器相当于 Java 中的 this.getClass() ，生成一个 Class 对象。
`this.class.methods`:: 属性访问器，相当于 this.getClass().getMethods() ，生成 Method 对象的数组。
`this.class.methods.name`:: 对数组的每个元素应用属性访问器并生成结果列表。
`this.class.methods.name.grep(...)`:: 对 this.class.methods.name 生成的列表的每个元素调用方法 grep 并生成结果列表。

WARNING: 像 this.class.methods 这样的子表达式会生成一个数组，因为这就是在 Java 中调用 this.getClass().getMethods() 会生成的结果。 GPath 表达式没有约定，其中 s 表示列表或类似内容。

GPath 表达式的一项强大功能是，将对集合的属性访问转换为对集合的每个元素的属性访问，并将结果收集到集合中。因此，表达式 this.class.methods.name 在Java中可以表达如下：
[source,java]
----
List<String> methodNames = new ArrayList<String>();
for (Method method : this.getClass().getMethods()) {
   methodNames.add(method.getName());
}
return methodNames;
----

数组访问表示法也可以用在存在集合的 GPath 表达式中：
[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_array_access_1,indent=0]
----

NOTE: GPath 表达式中的数组访问是从零开始的

==== 用于 XML 导航的 GPath

下面是一个包含 XML 文档和各种形式的 GPath 表达式的示例：
[source,groovy]
----
include::../../test/semantics/GPathTest.groovy[tags=gpath_on_xml_1,indent=0]
----

<1> root 下有一个 level 节点
<2> root/level 下有两个 sublevel 节点
<3> 有一个元素 sublevel 具有属性 id ，其值为 1
<4> root/level 下的第二个 sublevel 元素的第一个 keyVal 元素的 key 元素的文本值为 'anotherKey'
有关 XML GPath 表达式的更多详细信息，请参阅 XML 用户指南<<{xml-userguide}#processing-xml,XML User Guide>>。


== Promotion and coercion

=== Number promotion

The rules of number promotion are specified in the section on <<{core-syntax}#_math_operations,math operations>>.


[[closure-coercion]]
=== Closure to type coercion
==== 将闭包分配给 SAM 类型
A SAM type is a type which defines a single abstract method. This includes:

[source,groovy]
.Functional interfaces
----
include::../../test/CoercionTest.groovy[tags=filter_sam_type,indent=0]
----

[source,groovy]
.Abstract classes with single abstract method
----
include::../../test/CoercionTest.groovy[tags=greeter_sam_type,indent=0]
----

Any closure can be converted into a SAM type using the `as` operator:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=assertions_explicit_closure_to_sam,indent=0]
----

However, the `as Type` expression is optional since Groovy 2.2.0. You can omit it and simply write:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam,indent=0]
----

which means you are also allowed to use method pointers, as shown in the following example:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam_and_method_pointer,indent=0]
----

==== Calling a method accepting a SAM type with a closure

The second and probably more important use case for closure to SAM type coercion is calling a method which accepts
a SAM type. Imagine the following method:

[source,groovy]
-----
include::../../test/CoercionTest.groovy[tags=method_accepting_filter,indent=0]
-----

Then you can call it with a closure, without having to create an explicit implementation of the interface:

[source,groovy]
-----
include::../../test/CoercionTest.groovy[tags=method_call_with_explicit_coercion,indent=0]
-----

But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:

[source,groovy]
-----
include::../../test/CoercionTest.groovy[tags=method_call_with_implicit_coercion,indent=0]
-----

As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the
closure outside the parenthesis, improving the readability of your code.

==== Closure to arbitrary type coercion

In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let's define the
following interface:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=foobar_interface,indent=0]
----

You can coerce a closure into the interface using the `as` keyword:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=foobar2closure_coercion,indent=0]
----

This produces a class for which all methods are implemented using the closure:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=foobarintf_assertions,indent=0]
----

But it is also possible to coerce a closure to any class. For example, we can replace the `interface` that we defined
with `class` without changing the assertions:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=closure2foobarclass,indent=0]
----

=== Map to type coercion

Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an
alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are
interpreted as method names, while the values are the method implementation. The following example illustrates the
coercion of a map into an `Iterator`:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=coerce_map_to_iterator,indent=0]
----

Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods
that are actually called, but if a method is called that doesn't exist in the map a `MissingMethodException` or an
`UnsupportedOperationException` is thrown, depending on the arguments passed to the call,
as in the following example:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=define_x_interface,indent=0]
include::../../test/CoercionTest.groovy[tags=call_existing_method,indent=0]
include::../../test/CoercionTest.groovy[tags=call_non_existing_method,indent=0]
include::../../test/CoercionTest.groovy[tags=call_notimplemented_method,indent=0]
----

The type of the exception depends on the call itself:

* `MissingMethodException` if the arguments of the call do not match those from the interface/class
* `UnsupportedOperationException` if the arguments of the call match one of the overloaded methods of the interface/class

=== String to enum coercion

Groovy allows transparent `String` (or `GString`) to enum values coercion. Imagine you define the following enum:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=state_enum,indent=0]
----

then you can assign a string to the enum without having to use an explicit `as` coercion:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=enum_coerce_assignment,indent=0]
----

It is also possible to use a `GString` as the value:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=enum_coerce_assignment_gstring,indent=0]
----


However, this would throw a runtime error (`IllegalArgumentException`):
[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=enum_coerce_assignment_wrong,indent=0]
----

Note that it is also possible to use implicit coercion in switch statements:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=enum_switch_method,indent=0]
----

in particular, see how the `case` use string constants. But if you call a method that uses an enum with a `String`
argument, you still have to use an explicit `as` coercion:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=enum_switch_test,indent=0]
----

=== Custom type coercion

It is possible for a class to define custom coercion strategies by implementing the `asType` method. Custom coercion
is invoked using the `as` operator and is never implicit. As an example,
imagine you defined two classes, `Polar` and `Cartesian`, like in the following example:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::../../test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
include::../../test/CoercionTest.groovy[tags=cartesian_class,indent=0]
----

And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define
the `asType` method in the `Polar` class:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=polar_class_astype,indent=0]
----

which allows you to use the `as` coercion operator:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=polar_astype_assert,indent=0]
----

Putting it all together, the `Polar` class looks like this:
[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::../../test/CoercionTest.groovy[tags=polar_class_astype,indent=4]
include::../../test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
----

but it is also possible to define `asType` outside of the `Polar` class, which can be practical if you want to define
custom coercion strategies for "closed" classes or classes for which you don't own the source code, for example using
a metaclass:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=polar_metaclass_astype,indent=0]
----

=== Class literals vs variables and the as operator

Using the `as` keyword is only possible if you have a static reference to a class, like in the following code:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=as_keyword,indent=0]
----

But what if you get the class by reflection, for example by calling `Class.forName`?

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=clazz_greeter_header,indent=0]
----

Trying to use the reference to the class with the `as` keyword would fail:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=incorrect_as_usage,indent=0]
----

It is failing because the `as` keyword only works with class literals. Instead, you need to call the `asType` method:

[source,groovy]
----
include::../../test/CoercionTest.groovy[tags=fixed_as_usage,indent=0]
----

== 可省略的

=== 可选的括号

如果至少有一个参数并且没有歧义，方法调用可以省略括号：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=optional_parentheses,indent=0]
----

无参数的方法调用或不明确的方法调用需要括号：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=required_parentheses,indent=0]
----

=== 可选的分号

在 Groovy 中，如果该行仅包含单个语句，则可以省略该行末尾的分号。

这意味着：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=single_statement_with_semicolon,indent=0]
----

可以更惯用地写为：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=single_statement_without_semicolon,indent=0]
----

一行中的多个语句需要分号来分隔它们：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=statements_separated_by_semicolon,indent=0]
----

=== 可选的return关键字

在 Groovy 中，返回方法或闭包主体中计算的最后一个表达式。这意味着 return 关键字是可选的。

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=return_keyword,indent=0]
----

可以缩短为：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=omitted_return_keyword,indent=0]
----

=== 可选的public关键字

默认情况下，Groovy 类和方法是 public 。因此这个类：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=public_keyword,indent=0]
----

与此类相同：

[source,groovy]
----
include::../../test/semantics/OptionalityTest.groovy[tags=omitted_public,indent=0]
----

[[the-groovy-truth]]
== 表达式的真假

Groovy 通过应用以下规则来确定表达式是真还是假。

=== Boolean expressions
如果相应的布尔值为 true ，则为 True。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=boolean_truth,indent=0]
----

=== 集合和数组
非空集合和数组都是true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=collection_truth,indent=0]
----

=== Matchers
如果匹配器至少有一个匹配项，则为 true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=matcher_truth,indent=0]
----

=== 迭代器和枚举
具有下一个元素的迭代器和枚举被强制为 true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=iterator_enumeration_truth,indent=0]
----

=== Maps
非空map被评估为 true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=map_truth,indent=0]
----

=== Strings
非空字符串、GString 和 CharSequences 被强制为 true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=string_truth,indent=0]
----

=== Numbers
非零数为真。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=number_truth,indent=0]
----

=== Object References
非空对象引用被强制为 true。
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=object_truth,indent=0]
----

=== 使用 asBoolean() 方法自定义真假

为了自定义是否将对象评估为 true 还是 false, 可以实现 asBoolean() 方法：
[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=asBoolean_object,indent=0]
----

Groovy 将调用此方法将您的对象强制为布尔值，例如：

[source,groovy]
----
include::../../test/semantics/TheGroovyTruthTest.groovy[tags=asBoolean_usage,indent=0]
----

== 类型

=== 可选类型

可选类型是指即使您没有在变量上设置显式类型，程序也可以运行。作为一种动态语言，Groovy 自然地实现了该功能，例如当您声明变量时：

[source,groovy]
----
include::../../test/typing/OptionalTypingTest.groovy[tags=optionaltyping_var,indent=0]
----
<1> foo 使用显式类型声明， String
<2> 我们可以在 String 上调用 toUpperCase 方法

Groovy 会让你这样写：

[source,groovy]
----
include::../../test/typing/OptionalTypingTest.groovy[tags=optionaltyping_var_def,indent=0]
----
<1> foo 使用 def 声明
<2> 我们仍然可以调用 toUpperCase 方法，因为 aString 的类型是在运行时解析的

所以在这里使用显式类型并不重要。当您将此功能与<<static-type-checking,静态类型检查>>结合起来时，它特别有趣，因为类型检查器执行类型推断。

同样，Groovy 并不强制要求在方法中声明参数的类型：

[source,groovy]
----
include::../../test/typing/OptionalTypingTest.groovy[tags=optionaltyping_orig,indent=0]
----

可以使用 def 作为返回类型和参数类型进行重写，以便利用鸭子类型，如下例所示：

[source,groovy]
----
include::../../test/typing/OptionalTypingTest.groovy[tags=optionaltyping_def,indent=0]
----
<1> 返回类型和参数类型都使用 def
<2> 它使得可以使用 String 的方法
<3> 但也可以使用 int ，因为定义了 plus 方法


TIP: 建议在适用于任何类型的方法上使用 def 关键字，但从技术上讲，我们可以使用 Object 代替，结果是相同的：*在 Groovy 中， def 严格等同于使用 Object* 。

最后, 可以从返回类型和描述符中完全删除该类型。但是，如果您想从返回类型中删除它，则需要为该方法添加显式修饰符，以便编译器可以区分方法声明和方法调用，如下例所示：

[source,groovy]
----
include::../../test/typing/OptionalTypingTest.groovy[tags=optionaltyping_notype,indent=0]
----
<1> 如果我们想省略返回类型，则必须设置显式修饰符。
<2> 仍然可以使用 String 的方法
<3> 还有 int

TIP: 在公共 API 的方法参数或方法返回类型中，省略类型通常被认为是一种不好的做法。虽然在局部变量中使用 def 并不是真正的问题，因为变量的可见性仅限于方法本身，而在方法参数上设置时， def 将转换为 < b2> 出现在方法签名中，使得用户很难知道参数的预期类型。这意味着您应该将此限制于明确依赖鸭子类型的情况。

[[static-type-checking]]
=== 静态类型检查

默认情况下，Groovy 在编译时执行最少的类型检查. 由于它主要是一种动态语言，因此在编译期执行常规编译器都会执行的检查是不可能的. 通过运行时元编程添加的方法可能会改变类或对象的运行时行为。让我们在下面的例子中说明原因：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_intro,indent=0]
----
<1> Person 类仅定义两个属性， firstName 和 lastName
<2> 我们可以创建一个 Person 的实例
<3> 并调用名为 formattedName 的方法

在动态语言中，像上面的示例这样的代码不抛出任何错误是很常见的。怎么会这样？在 Java 中，这通常会在编译时失败。然而，在 Groovy 中，它不会在编译时失败，也不会在运行时失败。事实上，要使其在运行时工作，一种可能性是依赖运行时元编程。因此，只需在 Person 类的声明之后添加这一行就足够了：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_intro_magic,indent=0]
----

这意味着一般来说，在 Groovy 中，您不能对对象的声明类型之外的类型做出任何假设，即使您知道它，您也无法在编译时确定将调用哪个方法。从编写 DSL 到测试，它引起了很多兴趣，这将在本手册的其他部分中讨论。

然而，如果您的程序不依赖于动态功能，并且您来自静态世界（特别是来自 Java 思维方式），那么在编译时没有捕获此类“错误”可能会令人惊讶。正如我们在前面的示例中所看到的，编译器无法确定这是一个错误。为了让它意识到这一点，您必须显式指示编译器您正在切换到类型检查模式。这可以通过使用 @groovy.transform.TypeChecked 注释类或方法来完成。

当类型检查被激活时，编译器会执行更多的工作：

* 类型推断被激活，这意味着即使您在局部变量上使用 def ，类型检查器也将能够从赋值中推断变量的类型

* 方法调用在编译时解析，这意味着如果未在类上声明方法，编译器将抛出错误
* 一般来说，你习惯在静态语言中查找的所有编译时错误都会出现：找不到方法、找不到属性、方法调用的类型不兼容、数字精度错误……

在本节中，我们将描述类型检查器在各种情况下的行为，并描述 @TypeChecked 的限制。

==== @TypeChecked 注释

===== 在编译时激活类型检查

groovy.transform.TypeChecked 注释启用类型检查。它可以放在一个类中：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=typechecked_class,indent=0]
----

或者在一个方法上：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=typechecked_method,indent=0]
----

在第一种情况下，注释类的所有方法、属性、字段、内部类等都将进行类型检查，而在第二种情况下，只有方法和它包含的潜在闭包或匿名内部类将进行类型检查。

===== 跳过类型检查

类型检查的范围可以受到限制。例如，如果一个类经过类型检查，您可以通过使用 @TypeChecked(TypeCheckingMode.SKIP) 注释来指示类型检查器跳过该方法：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_skip,indent=0]
----
<1> GreetingService 类被标记为类型检查
<2> 所以 greeting 方法会自动进行类型检查
<3> 但 doGreet 被标记为 SKIP
<4> 类型检查器不会抱怨这里缺少属性

在前面的示例中， SentenceBuilder 依赖于动态代码。没有真正的 Hello 方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法标记有 TypeCheckingMode.SKIP ，因此会跳过此方法的类型检查，因此即使类的其余部分经过类型检查，代码也会编译。

以下部分描述了 Groovy 中类型检查的语义。

==== 类型检查赋值

当且仅当满足以下条件时， A 类型的对象 o 才可以分配给 T 类型的变量：

* `T` equals `A`

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_equals,indent=0]
----
====

* 或 T 是 String 、 boolean 、 Boolean 或 Class 之一

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_specialcase,indent=0]
----
====

*或 o 为 null 并且 T 是引用类型

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_null,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_null2prim,indent=0]
----
====

* 或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型
+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_fail,indent=0]
----
====

* 或 T 是一个数组， A 是一个collection或stream，并且 A 的元素类型可分配给 T 的元素类型
+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_list,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_list_fail,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_set,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_stream,indent=0]
----
====

* 或者 T 是 A 的父类

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_superclass,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_superclass_fail,indent=0]
----
====

* 或者 T 是 A 实现的接口


+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_interface,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_interface_fail,indent=0]
----
====

* 或 T 或 A 是原始类型，它们的装箱类型是可分配的

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_prim,indent=0]
----
====

* 或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_closure_coercion,indent=0]
----
====

* 或 T 和 A 派生自 java.lang.Number 并符合下表


[cols="1,1,2a"]
.Number types (java.lang.XXX)
[[number-assignment]]
|===
|T |A |Examples

|Double
|Any but BigDecimal or BigInteger
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_double,indent=0]
----

|Float
|Any type but BigDecimal, BigInteger or Double
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_float,indent=0]
----

|Long
|Any type but BigDecimal, BigInteger, Double or Float
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_long,indent=0]
----

|Integer
|Any type but BigDecimal, BigInteger, Double, Float or Long
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_int,indent=0]
----

|Short
|Any type but BigDecimal, BigInteger, Double, Float, Long or Integer
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_short,indent=0]
----

|Byte
|Byte
| [source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_byte,indent=0]
----

|===

==== List 和 map 构造器

可以将List字面量或Map字面量 A 赋值给 T 类型的变量，前提是：

* A 是一个List字面量， T 有一个构造函数，其参数与List字面量中元素的类型匹配
* A 是一个Map字面量， T 有一个无参数构造函数, 并且对于 `Map` 中的每个key, 都有一个与之对应的属性

例如，如下：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_classic,indent=0]
----

您可以使用 “list constructor” ：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_list,indent=0]
----

或者 "map constructor":

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_map,indent=0]
----

如果您使用 map 构造函数，则会对map的键进行额外检查，以检查是否定义了同名的属性。例如，以下内容将在编译时失败：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_ctor_fail,indent=0]
----
<1> 类型检查器将在编译时抛出错误 No such property: age for class: Person

==== 方法检查

在类型检查模式下，方法在编译时解析。解析通过名称和参数进行。返回类型与方法选择无关。入参和出参按照以下规则进行匹配：

当且仅当满足以下条件时， A 类型的实参 o 才可用于 T 类型的形参：

* `T` equals `A`

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_equals,indent=0]
----
====

* 或 T 是 String ， A 是 GString

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_specialcase,indent=0]
----
====

* 或 o 为 null 并且 T 是引用类型

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_null,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_null2prim,indent=0]
----
====

* 或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_array,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_array_fail,indent=0]
----
====

* 或者 T 是 A 的父类

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_superclass,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_superclass_fail,indent=0]
----
====

* 或者 T 是 A 实现的接口

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_interface,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_interface_fail,indent=0]
----
====

* 或 T 或 A 是原始类型，它们的包装类型是可分配的

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_argparam_prim,indent=0]
----
====

* 或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）

+

[.result]
====
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=stc_arg_closure_coercion,indent=0]
----
====

* 或 T 和 A 派生自 java.lang.Number 并符合与<<number-assignment,数字赋值>>相同的规则

如果在编译时未找到具有适当名称和参数的方法，则会引发错误。以下示例说明了与“正常”Groovy 的区别：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=method_not_type_checked,indent=0]
----
<1> printLine 是一个错误，但由于我们处于动态模式，因此在编译时不会捕获该错误

上面的示例Groovy能够正常编译。但是，如果您尝试创建 MyService 的实例并调用 doSomething 方法，那么它将在运行时失败，因为 printLine 不存在。当然，我们已经展示了 Groovy 如何使其成为完全有效的调用，例如通过捕获 MethodMissingException 或实现自定义元类，但如果您知道自己不属于这种情况， 可以使用 @TypeChecked 来开启检查

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=method_type_checked,indent=0]
----
<1> printLine 这次是编译时错误

只需添加 @TypeChecked 将触发编译时方法解析。类型检查器将尝试在 MyService 类上查找接受 String 的方法 printLine ，但找不到。编译将失败并显示以下消息：

`Cannot find matching method MyService#printLine(java.lang.String)`

====
IMPORTANT: 了解类型检查器背后的逻辑很重要：它是编译时检查，因此根据定义，类型检查器不知道您所做的任何类型的运行时元编程。这意味着如果您激活类型检查，任何在关闭类型检查时正常编译的代码都可能编译失败。如果您想到鸭子类型，则尤其如此：


[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=ducktyping_failure,indent=0]
----
<1> 我们定义一个 Duck 类，它定义一个 quack 方法
<2> 我们定义了另一个 QuackingBird 类，它也定义了 quack 方法
<3> quacker 是松散类型的，由于该方法是 @TypeChecked ，我们将获得编译时错误
<4> 但在没有类型检查的Groovy中, 这会通过

有可能的解决方法，例如引入接口，但基本上，通过激活类型检查，您可以获得类型安全，但会失去该语言的一些功能。幸运的是 Groovy 引入一些功能，例如流类型，以缩小类型检查和非类型检查 Groovy 之间的差距。
====

[[type-inference]]
==== 类型推断

===== 原则
当代码用 @TypeChecked 注释时，编译器会执行类型推断。它不仅仅依赖于静态类型，还使用各种技术来推断变量的类型、返回类型、字面量……，以便即使您激活类型检查器，代码也尽可能保持干净。

最简单的例子是推断变量的类型：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=simple_var_type_inference,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=simple_var_type_inference_fail,indent=0]
----
<1> 使用 def 关键字声明变量
<2> 类型检查器允许调用 toUpperCase
<3> 调用 upper 将在编译时失败

对 toUpperCase 的调用有效的原因是 message 的类型被推断为 String 。

===== 类型推断中的变量和字段

值得注意的是，虽然编译器对局部变量执行类型推断，但它不会对字段执行任何类型的推断，总是回退到字段的声明类型。为了说明这一点，让我们看一下这个例子：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=typeinference_field_vs_local_variable,indent=0]
----
<1> someUntypedField 使用 def 作为声明类型
<2> someTypedField 使用 String 作为声明类型
<3> 我们可以将任何内容分配给 someUntypedField
<4> 但调用 toUpperCase 在编译时失败，因为该字段没有类型
<5> 我们可以将 String 分配给 String 类型的字段
<6> 这次允许 toUpperCase
<7> 如果我们将 String 分配给局部变量
<8> 允许在局部变量上调用 toUpperCase(因为会类型推断)

为什么会有这样的差异？原因是线程安全。在编译时，我们无法对字段的类型做出任何保证。任何线程都可以随时访问任何字段，并且在方法中为字段分配某种类型的变量的那一刻和之后使用该行的时间之间，另一个线程可能已经更改了该字段的内容。局部变量的情况并非如此：我们知道它们是否“转义”，因此我们可以确保变量的类型随着时间的推移保持不变（或不变）。请注意，即使字段是最终字段，JVM 也不对其做出保证，因此无论字段是否为最终字段，类型检查器的行为都不会有所不同。

TIP: 这就是我们建议使用类型化字段的原因之一。虽然由于类型推断，对局部变量使用 def 是完全没问题的，但字段的情况并非如此，字段也属于类的公共 API，因此类型很重要。

===== 集合字面量类型推断

Groovy 提供了各种类型字面量的语法。 Groovy 中有集合字面量：

* lists, using the `[]` literal
* maps, using the `[:]` literal
* range，使用 from..to （包含）、 from..<to （右排除）、 from<..to （左排除）和 from<..<to （完全排除）

字面量的推断类型取决于字面量的元素，如下表所示：

[cols="2a,3a"]
|===
|Literal| Inferred type

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=empty_list_literal_inference,indent=0]
----
|`java.util.List`

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=list_literal_inference_simple,indent=0]
----
|`java.util.List<String>`

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=list_literal_inference_gstring,indent=0]
----
|`java.util.List<GString>` be careful, a `GString` is *not* a `String`!

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=empty_map_literal_inference,indent=0]
----
|`java.util.LinkedHashMap`

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=map_literal_inference_simple,indent=0]
----
|`java.util.LinkedHashMap<String,String>`

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=map_literal_inference_gstring,indent=0]
----
|`java.util.LinkedHashMap<GString,String>` be careful, the key is a `GString`!

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=intRange_literal_inference,indent=0]
----
|`groovy.lang.IntRange`

|[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=charRange_literal_inference,indent=0]
----
|`groovy.lang.Range<String>` : uses the type of the bounds to infer the component type of the range

|===

正如您所看到的，除了 IntRange 明显的例外，推断类型使用泛型来描述集合的内容。如果集合包含不同类型的元素，类型检查器仍然执行元素的类型推断，但使用<<section-lub,最小上限>>的概念。


[[section-lub]]
===== 最小上限

在 Groovy 中， A 和 B 两种类型的最小上限被定义为以下类型：

* A 和 B 的公共超类
* A 和 B 实现的共同接口
* 如果 A 或 B 是原始类型并且 A 不等于 B ，则 A 和 B 是其包装类型的最小上限

如果 A 和 B 只有一 (1) 个公共接口，并且它们的公共超类是 Object ，那么两者的 LUB 就是公共接口。

最小上限表示可以分配 A 和 B 的最小类型。例如，如果 A 和 B 都是 String ，那么两者的 LUB（最小上限）也是 String 。

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_simple,indent=0]
----
<1> String 和 String 的LUB是 String
<2> ArrayList 和 LinkedList 的 LUB 是它们共同的超类型， AbstractList
<3> ArrayList 和 List 的LUB是它们唯一的公共接口， List
<4> 两个相同接口的LUB就是接口本身
<5> Bottom1 和 Bottom2 的 LUB 是它们的超类 Top
<6> 两种没有共同点的类型的LUB是 Object

在这些示例中，LUB 始终可表示为普通的、JVM 支持的类型。但 Groovy 在内部将 LUB 表示为一种可能更复杂的类型，并且您无法使用它来定义变量。为了说明这一点，让我们继续这个例子：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_complex,indent=0]
----

Bottom 和 SerializableFooImpl 的最小上限是多少？它们没有共同的超类（除了 Object ），但它们共享 2 个接口（ Serializable 和 Foo ），因此它们的最小上限是表示两个接口（ Serializable 和 Foo ）的联合的类型。这种类型无法在源代码中定义，但 Groovy 知道它。

在集合类型推断（以及一般的泛型类型推断）的上下文中，这变得很方便，因为组件的类型被推断为最小上限。我们可以在以下示例中说明为什么这很重要：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_collection_inference,indent=0]
----
<1> Greeter 接口定义了一个方法， greet
<2> Salute 接口定义了一个方法， salute
<3> 类 A 实现了 Greeter 和 Salute
<4> 与 B 相同
<5> 但 B 定义了一个额外的 exit 方法
<6> list 的类型被推断为“ A 和 `B` 的 LUB 列表”
<7> 因此可以通过 Greeter 接口调用 A 和 B 上定义的 greet
<8> 并且可以通过 Salute 接口调用 A 和 B 上定义的 salute
<9> 然而调用 exit 是一个编译时错误，因为它不属于 A 和 B 的LUB（仅在 B 中定义） ）

错误消息将如下所示：

----
[Static type checking] - Cannot find matching method Greeter or Salute#exit()
----

这表明 exit 方法既没有定义在 Greeter 上，也没有定义在 Salute 上，这两个接口定义在 A 和 B 。

===== instanceof

在正常的、非类型检查的 Groovy 中，您可以编写如下内容：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=instanceof_inference,indent=0]
----
<1> 使用 instanceof 来保护方法调用
<2> 调用

该方法调用之所以有效，是因为动态调度（该方法是在运行时选择的）。 Java 中的等效代码需要在调用 greeting 方法之前将 o 转换为 Greeter ，因为方法是在编译时选择的：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=instanceof_java_equiv,indent=0]
----

然而，在 Groovy 中，即使您在 doSomething 方法上添加 @TypeChecked （从而激活类型检查），也不需要强制转换。编译器嵌入了instanceof 推理，使强制转换成为可选的。

[[section-flow-typing]]
===== 流类型

流类型是 Groovy 类型检查模式中的一个重要概念，也是类型推断的扩展。这个想法是编译器能够推断代码流中变量的类型，而不仅仅是在初始化时：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flowtyping_basics,indent=0]
----
<1> 首先，使用 def 声明 o 并分配一个 String
<2> 编译器推断 o 是 String ，因此允许调用 toUpperCase
<3> o 被重新分配为 double
<4> 调用 Math.sqrt 通过编译，因为编译器知道此时 o 是 double

因此类型检查器知道变量的具体类型随着时间的推移而变化。特别是，如果您将最后一个分配替换为：
[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flowtyping_basics_fail,indent=0]
----

现在，类型检查器将在编译时失败，因为当调用 toUpperCase 时，它知道 o 是 double ，因此这是一个类型错误。

It is important to understand that it is not the fact of declaring a variable with `def` that triggers type inference.
流类型适用于任何类型的任何变量。使用显式类型声明变量只会限制可以分配给该变量的内容：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints,indent=0]
----
<1> list 被声明为未经检查的 List 并分配了一个“String”列表文字
<2> 由于流类型，该行通过了编译：类型检查器知道 list 此时是 List<String>
<3> 但你不能将 String 分配给 List 所以这是一个类型检查错误

您还可以注意到，即使声明变量时没有泛型信息，类型检查器也知道组件类型是什么。因此，这样的代码将编译失败：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints_failure,indent=0]
----
<1> list 被推断为 List<String>
<2> 因此将 int 添加到 List<String> 是一个编译时错误

修复此问题需要在声明中添加显式泛型类型：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints_fixed,indent=0]
----
<1> list 声明为 List<? extends Serializable> 并用空列表初始化
<2> 添加到列表中的元素符合列表的声明类型
<3> 因此允许将 int 添加到 List<? extends Serializable>

引入流类型是为了减少经典 Groovy 和静态 Groovy 之间的语义差异。特别是考虑一下 Java 中这段代码的行为：

[source,java]
----
include::../../test/typing/TypeCheckingJavaTest.java[tags=java_method_selection_head,indent=0]
include::../../test/typing/TypeCheckingJavaTest.java[tags=java_method_selection_body,indent=0]
----
<1> o 被声明为 Object 并分配了 String
<2> 我们用 o 调用 compute 方法
<3> 并打印结果

在 Java 中，此代码将输出 Nope ，因为方法选择是在编译时基于声明的类型完成的。因此，即使 o 在运行时是 String ，它仍然是调用的 Object 版本，因为 o 已被声明为一个 Object 。简而言之，在Java中，声明类型是最重要的，无论是变量类型、参数类型还是返回类型。

在 Groovy 中，我们可以这样写：

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=groovy_method_selection,indent=0]
----

但这一次，它将返回 6 ，因为该方法是在运行时根据实际参数类型选择的。因此在运行时， o 是 String ，因此使用 String 变体。请注意，此行为与类型检查无关，这是 Groovy 一般的工作方式：动态调度。

In type checked Groovy, we want to make sure the type checker selects the same method *at compile time*, that the runtime
would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow
typing. With flow typing, `o` is _inferred_ as a `String` when the `compute` method is called, so the version which takes
a `String` and returns an `int` is chosen. This means that we can infer the return type of the method to be an `int`, and
not a `String`. This is important for subsequent calls and type safety.

So in type checked Groovy, flow typing is a very important concept, which also implies that if `@TypeChecked` is applied,
methods are selected based on the _inferred types_ of the arguments, not on the declared types. This doesn't ensure 100%
type safety, because the type checker _may_ select a wrong method, but it ensures the closest semantics to dynamic Groovy.


===== 高级类型推断

使用<<section-flow-typing,流类型>>和<<section-lub,最小上限推断>>的组合来执行高级类型推理并确保多种情况下的类型安全。特别是，程序控制结构可能会改变变量的推断类型：


[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=flow_lub_ifelse_header,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=flow_lub_ifelse_test,indent=0]
----
<1> 如果 someCondition 为 true，则为 o 分配 Top
<2> 如果 someCondition 为 false，则为 o 分配 Bottom
<3> 调用 methodFromTop 是安全的
<4> 但调用 methodFromBottom 则不然，所以这是一个编译时错误


When the type checker visits an `if/else` control structure, it checks all variables which are assigned in `if/else` branches
and computes the <<section-lub,least upper bound>> of all assignments. This type is the type of the inferred variable
after the `if/else` block, so in this example, `o` is assigned a `Top` in the `if` branch and a `Bottom` in the `else`
branch. The <<section-lub,LUB>> of those is a `Top`, so after the conditional branches, the compiler infers `o` as being
a `Top`. Calling `methodFromTop` will therefore be allowed, but not `methodFromBottom`.

The same reasoning exists with closures and in particular closure shared variables. A closure shared variable is a variable
which is defined outside of a closure, but used inside a closure, as in this example:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=closure_shared_variable_definition,indent=0]
----
<1> a variable named `text` is declared
<2> `text` is used from inside a closure. It is a _closure shared variable_.

Groovy allows developers to use those variables without requiring them to be final. This means that a closure shared
variable can be reassigned inside a closure:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=closure_shared_variable_ex1,indent=0]
----

The problem is that a closure is an independent block of code that can be executed (or not) at *any* time. In particular,
`doSomething` may be asynchronous, for example. This means that the body of a closure doesn't belong to the main control
flow. For that reason, the type checker also computes, for each closure shared variable, the <<section-lub,LUB>> of all
assignments of the variable, and will use that `LUB` as the inferred type outside of the scope of the closure, like in
this example:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=closure_shared_variable_ex2,indent=0]
----
<1> a closure-shared variable is first assigned a `Top`
<2> inside the closure, it is assigned a `Bottom`
<3> `methodFromTop` is allowed
<4> `methodFromBottom` is a compilation error

Here, it is clear that when `methodFromBottom` is called, there's no guarantee, at compile-time or runtime that the
type of `o` will _effectively_ be a `Bottom`. There are chances that it will be, but we can't make sure, because it's
asynchronous. So the type checker will only allow calls on the <<section-lub,least upper bound>>, which is here a `Top`.

==== Closures and type inference

The type checker performs special inference on closures, resulting on additional checks on one side and improved fluency
on the other side.

===== Return type inference

The first thing that the type checker is capable of doing is inferring the _return type_ of a closure. This is simply
 illustrated in the following example:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=closure_return_type_inf,indent=0]
----
<1> a closure is defined, and it returns a string (more precisely a `GString`)
<2> we call the closure and assign the result to a variable
<3> the type checker inferred that the closure would return a string, so calling `length()` is allowed

As you can see, unlike a method which declares its return type explicitly, there's no need to declare the return type
of a closure: its type is inferred from the body of the closure.

.Closures vs methods
****
It's worth noting that return type inference is only applicable to closures. While the type checker could do the
same on a method, it is in practice not desirable: _in general_, methods can be overridden and it is not statically
possible to make sure that the method which is called is not an overridden version. So flow typing would actually
think that a method returns something, while in reality, it could return something else, like illustrated in the
following example:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=method_return_type_matters,indent=0]
----
<1> class `A` defines a method `compute` which effectively returns a `String`
<2> this will fail compilation because the return type of `compute` is `def`(aka `Object`)
<3> class `B` extends `A` and redefines `compute`, this type returning an `int`

As you can see, if the type checker relied on the inferred return type of a method, with <<section-flow-typing,flow typing>>,
the type checker could determine that it is ok to call `toUpperCase`. It is in fact an *error*, because a subclass can
override `compute` and return a different object. Here, `B#compute` returns an `int`, so someone calling `computeFully`
on an instance of `B` would see a runtime error. The compiler prevents this from happening by using the declared return
type of methods instead of the inferred return type.

For consistency, this behavior is the same for *every* method, even if they are static or final.
****

===== Parameter type inference

In addition to the return type, it is possible for a closure to infer its parameter types from the context. There are
two ways for the compiler to infer the parameter types:

* through _implicit SAM type coercion_
* through API metadata

To illustrate this, lets start with an example that will fail compilation due to the inability for the type checker
to infer the parameter types:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_failure,indent=0]
----
<1> the `inviteIf` method accepts a `Person` and a `Closure`
<2> we call it with a `Person` and a `Closure`
<3> yet `it` is not statically known as being a `Person` and compilation fails

In this example, the closure body contains `it.age`. With dynamic, not type checked code, this would work, because the
type of `it` would be a `Person` at runtime. Unfortunately, at compile-time, there's no way to know what is the type
of `it`, just by reading the signature of `inviteIf`.

====== Explicit closure parameters

To be short, the type checker doesn't have enough contextual information on the `inviteIf` method to determine statically
the type of `it`. This means that the method call needs to be rewritten like this:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_workaround,indent=0]
----
<1> the type of `it` needs to be declared explicitly

By explicitly declaring the type of the `it` variable, you can work around the problem and make this code statically
checked.

====== Parameters inferred from single-abstract method types

For an API or framework designer, there are two ways to make this more elegant for users, so that they don't have to
declare an explicit type for the closure parameters. The first one, and easiest, is to replace the closure with a
SAM type:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_workaround_sam,indent=0]
----
<1> declare a `SAM` interface with an `apply` method
<2> `inviteIf` now uses a `Predicate<Person>` instead of a `Closure<Boolean>`
<3> there's no need to declare the type of the `it` variable anymore
<4> `it.age` compiles properly, the type of `it` is inferred from the `Predicate#apply` method signature

TIP: By using this technique, we leverage the _automatic coercion of closures to SAM types_ feature of Groovy.
Whether you should use a _SAM type_ or a _Closure_ really depends on what you need to do. In a lot of cases,
using a SAM interface is enough, especially if you consider functional interfaces as they are found in Java 8. However,
closures provide features that are not accessible to functional interfaces. In particular, closures can have a delegate,
and owner and can be manipulated as objects (for example, cloned, serialized, curried, ...) before being called. They can
also support multiple signatures (polymorphism). So if you need that kind of manipulation, it is preferable to switch to
the most advanced type inference annotations which are described below.

The original issue that needs to be solved when it comes to closure parameter type inference, that is to say, statically
determining the types of the arguments of a closure _without_ having to have them explicitly declared, is that the Groovy
type system inherits the Java type system, which is insufficient to describe the types of the arguments.

====== The `@ClosureParams` annotation

Groovy provides an annotation, `@ClosureParams` which is aimed at completing type information. This annotation is primarily
aimed at framework and API developers who want to extend the capabilities of the type checker by providing type inference
metadata. This is important if your library makes use of closures and that you want the maximum level of tooling support
too.

Let's illustrate this by fixing the original example, introducing the `@ClosureParams` annotation:

[source,groovy]
----
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_workaround_closureparams_imports,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_workaround_closureparams_method,indent=0]
include::../../test/typing/TypeCheckingTest.groovy[tags=cl_pt_workaround_closureparams_call,indent=0]
----
<1> the closure parameter is annotated with `@ClosureParams`
<2> it's not necessary to use an explicit type for `it`, which is inferred

The `@ClosureParams` annotation minimally accepts one argument, which is named a _type hint_. A type hint is a class which
is responsible for completing type information at compile time for the closure. In this example, the type hint being used
is `groovy.transform.stc.FirstParam` which indicated to the type checker that the closure will accept one parameter
whose type is the type of the first parameter of the method. In this case, the first parameter of the method is `Person`,
so it indicates to the type checker that the first parameter of the closure is in fact a `Person`.

A second optional argument is named _options_. Its semantics depend on the _type hint_ class. Groovy comes with
various bundled type hints, illustrated in the table below:

[cols="1a,1,4a"]
.Predefined type hints
|===
|Type hint |Polymorphic? |Description and examples

|`FirstParam` +
`SecondParam` +
`ThirdParam`
|No
|The first (resp. second, third) parameter type of the method +
[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_firstparam,indent=0]
----

[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_secondparam,indent=0]
----

[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_thirdparam,indent=0]
----

|`FirstParam.FirstGenericType` +
`SecondParam.FirstGenericType` +
`ThirdParam.FirstGenericType`
|No
|The first generic type of the first (resp. second, third) parameter of the method +
[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_firstgt,indent=0]
----

Variants for `SecondGenericType` and `ThirdGenericType` exist for all `FirstParam`, `SecondParam` and `ThirdParam`
type hints.

|`SimpleType`
|No
|A type hint for which the type of closure parameters comes from the options string. +
[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_simpletype,indent=0]
----

This type hint supports a *single* signature and each of the parameter is specified as a value of the _options_ array
using a fully-qualified type name or a primitive type.

|`MapEntryOrKeyValue`
|Yes
|A dedicated type hint for closures that either work on a `Map.Entry` single parameter, or two parameters corresponding
to the key and the value. +
[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_mapentry,indent=0]
----

This type hint *requires* that the first argument is a `Map` type, and infers the closure parameter types from the map
actual key/value types.

|`FromAbstractTypeMethods`
|Yes
|Infers closure parameter types from the abstract method of some type. A signature is inferred for *each* abstract method. +
[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_from_abstract_type,indent=0]
----

If there are multiple signatures like in the example above, the type checker will *only* be able to infer the types of
the arguments if the arity of each method is different. In the example above, `firstSignature` takes 2 arguments and
`secondSignature` takes 1 argument, so the type checker can infer the argument types based on the number of arguments.
But see the optional resolver class attribute discussed next.

|`FromString`
|Yes
|Infers the closure parameter types from the `options` argument. The `options` argument consists of an array of comma-separated
non-primitive types. Each element of the array corresponds to a single signature, and each comma in an element separate
parameters of the signature. In short, this is the most generic type hint, and each string of the `options` map is *parsed*
as if it was a signature literal. While being very powerful, this type hint must be avoided if you can because it increases
the compilation times due to the necessity of parsing the type signatures.

A single signature for a closure accepting a `String`:

[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_from_string_1,indent=0]
----

A polymorphic closure, accepting either a `String` or a `String, Integer`:

[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_from_string_2,indent=0]
----

A polymorphic closure, accepting either a `T` or a pair `T,T`:

[source,groovy]
----
include::../../test/typing/TypeCheckingHintsTest.groovy[tags=typehint_from_string_3,indent=0]
----

|===

TIP: Even though you use `FirstParam`, `SecondParam` or `ThirdParam` as a type hint, it doesn't strictly mean that the
argument which will be passed to the closure *will* be the first (resp. second, third) argument of the method call. It
only means that the *type* of the parameter of the closure will be the *same* as the type of the first (resp.  second,
 third) argument of the method call.

In short, the lack of the `@ClosureParams` annotation on a method accepting a `Closure` will *not* fail compilation. If
 present (and it can be present in Java sources as well as Groovy sources), then the type checker has *more* information
 and can perform additional type inference. This makes this feature particularly interesting for framework developers.

A third optional argument is named _conflictResolutionStrategy_. It can reference a class (extending from
`ClosureSignatureConflictResolver`) that can perform additional resolution of parameter types if more than
one are found after initial inference calculations are complete. Groovy comes with a default type resolver
which does nothing, and another which selects the first signature if multiple are found. The resolver is
only invoked if more than one signature is found and is by design a post processor. Any statements which need
injected typing information must pass one of the parameter signatures determined through type hints. The
resolver then picks among the returned candidate signatures.

===== `@DelegatesTo`

The `@DelegatesTo` annotation is used by the type checker to infer the type of the delegate. It allows the API designer
to instruct the compiler what is the type of the delegate and the delegation strategy. The `@DelegatesTo` annotation is
discussed in a link:core-domain-specific-languages.html#section-delegatesto[specific section].

=== Static compilation

==== Dynamic vs static

In the <<static-type-checking,type checking section>>, we have seen that Groovy provides optional type checking thanks to the
`@TypeChecked` annotation. The type checker runs at compile time and performs a static analysis of dynamic code. The
program will behave exactly the same whether type checking has been enabled or not. This means that the `@TypeChecked`
annotation is neutral in regard to the semantics of a program. Even though it may be necessary to add type information
in the sources so that the program is considered type safe, in the end, the semantics of the program are the same.

While this may sound fine, there is actually one issue with this: type checking of dynamic code, done at compile time, is
by definition only correct if no runtime specific behavior occurs. For example, the following program passes type checking:

[[typechecked-defeated]]
[source,groovy]
----
include::../../test/typing/StaticCompilationIntroTest.groovy[tags=intro_typesafe,indent=0]
----

There are two `compute` methods. One accepts a `String` and returns an `int`, the other accepts an `int` and returns
a `String`. If you compile this, it is considered type safe: the inner `compute('foobar')` call will return an `int`,
and calling `compute` on this `int` will in turn return a `String`.

Now, before calling `test()`, consider adding the following line:

[source,groovy]
----
include::../../test/typing/StaticCompilationIntroTest.groovy[tags=intro_typesafe_magic,indent=0]
----

Using runtime metaprogramming, we're actually modifying the behavior of the `compute(String)` method, so that instead of
returning the length of the provided argument, it will return a `Date`. If you execute the program, it will fail at
runtime. Since this line can be added from anywhere, in any thread, there's absolutely no way for the type checker to
statically make sure that no such thing happens. In short, the type checker is vulnerable to monkey patching. This is
just one example, but this illustrates the concept that doing static analysis of a dynamic program is inherently wrong.

The Groovy language provides an alternative annotation to `@TypeChecked` which will actually make sure that the methods
which are inferred as being called *will* effectively be called at runtime. This annotation turns the Groovy compiler
into a *static compiler*, where all method calls are resolved at compile time *and* the generated bytecode makes sure
that this happens: the annotation is `@groovy.transform.CompileStatic`.

[[compilestatic-annotation]]
==== The `@CompileStatic` annotation

The `@CompileStatic` annotation can be added anywhere the `@TypeChecked` annotation can be used, that is to say on
a class or a method. It is not necessary to add both `@TypeChecked` and `@CompileStatic`, as `@CompileStatic` performs
everything `@TypeChecked` does, but in addition triggers static compilation.

Let's take the <<typechecked-defeated,example which failed>>, but this time let's replace the `@TypeChecked` annotation
with `@CompileStatic`:

[source,groovy]
----
include::../../test/typing/StaticCompilationIntroTest.groovy[tags=intro_typesafe_compilestatic,indent=0]
include::../../test/typing/StaticCompilationIntroTest.groovy[tags=intro_typesafe_magic,indent=0]
test()
----

This is the *only* difference. If we execute this program, this time, there is no runtime error. The `test` method
became immune to monkey patching, because the `compute` methods which are called in its body are linked at compile
time, so even if the metaclass of `Computer` changes, the program still behaves *as expected by the type checker*.

==== Key benefits

There are several benefits of using `@CompileStatic` on your code:

* type safety
* immunity to <<compilestatic-annotation,monkey patching>>
* performance improvements

The performance improvements depend on the kind of program you are executing. If it is I/O bound, the difference between
statically compiled code and dynamic code is barely noticeable. On highly CPU intensive code, since the bytecode which
is generated is very close, if not equal, to the one that Java would produce for an equivalent program, the performance
is greatly improved.

TIP: Using the _invokedynamic_ version of Groovy, which is accessible to people using JDK 7 and above, the performance
of the dynamic code should be very close to the performance of statically compiled code. Sometimes, it can even be faster!
There is only one way to determine which version you should choose: measuring. The reason is that depending on your program
*and* the JVM that you use, the performance can be significantly different. In particular, the _invokedynamic_ version of
Groovy is very sensitive to the JVM version in use.

include::_type-checking-extensions.adoc[leveloffset=+1]

