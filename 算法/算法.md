## 插入排序

![](images\849589-20171015225645277-1151100000.gif)

## 选择排序

![](images\849589-20171015224719590-1433219824.gif)

## 冒泡排序

![](images\849589-20171015223238449-2146169197.gif)

## 快排

![](images\TIM截图20190514140240.jpg)

## 希尔排序

#### 希尔排序的原理

希尔排序的基本思想是：把待排序的数列按照一定的增量分割成多个子数列。但是这个子数列不是连续的，而是通过前面提到的增量，按照一定相隔的增量进行分割的，然后对各个子数列进行插入排序，接着增量逐渐减小，然后仍然对每部分进行插入排序，在减小到1之后直接使用插入排序处理数列。

需要特别强调，这里选择增量的要求是每次都要减少，直至最后一次变为1为止。

下面，我们通过一个实例来理解其实现原理。

在本实例中的首选增量为 n/2，n 为待排序的数列的长度，并且每次的增量都为上一次的 1/2。待排序的数列为 588、392、898、115、306、62、909、902、789、234，有 10 个数。我们首选增量为 10/2 即 5，进行如图所示的分块。

![](images\2-1Q0041102534I.jpg)


由于增量为 5，所以把原待排序的数列按照增量划分为 5 组，每组实际上都是以增量为间隔的数组(下标为0的元素对应下标为 5 的元素，1 对应 6、2 对应 7，等等）。

之后对每组进行插入排序，其实就是将后一个元素与前一个元素进行比较，看看是否需要交换（当然，还是应该按照插入排序的步骤来进行，就是把后一个元素拿出来，与前一个元素进行比较，看看是否需要移动前面的元素，如果需要移动，则把第 1 个元素后移，然后把拿出来的元素放到前面去；若不需要移动，则不需要进行其他操作)

分别对每组元素进行插入排序之后的结果如图 2 所示。

![img](images\2-1Q0041103344L.jpg)
				图 2 对 5 组数据进行插入排序操作后的结果

我们发现，实际上在这组数列中只有两组数据进行了移动操作。至此，第 1 趟排序完成。现在的待排序的数列变成了 62、392、898、115、234、588、909、902、789、306。接下来我们该缩减增量了，按照之前的规则，这次的增量应该是 5/2，也就是 2，于是出现了如图 3 所示的划分结果。

![img](images\2-1Q004110404Y7.jpg)
图 3 增量为 2 时的第 2 趟划分

现在的待排序的数列的增量为 2，所以每隔一个元素进行分组（也就是数组下标为 0、2、4、6、8 的元素为一组，数组下标为 1、3、5、7、9 的元素为一组），当前的数列被划分为两组，继续对每组数列进行插入排序。

这里就不再复述插入排序的步骤了，大家应该可以轻易地完成对两组数据的插入排序了。第 2 趟排序的结果如图 4 所示。现在的待排序的数列变为 62、115、234、306、789、392、898、588、909、902。

![img](images\2-1Q004110443230.jpg)
图 4 第 2 趟排序的结果

我们发现，每趟排序都会使数组整体更趋于有序了。

接下来对增量继续按照规则除以 2，得到 1，说明这时该对上一趟完成排序的数列进行直接插入排序了。第3趟排序的结果就是最终结果：62、115、234、306、392、588、789、898、902、909，至此希尔排序结束。