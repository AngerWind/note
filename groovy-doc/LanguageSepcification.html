<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>语法</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_语法">1. 语法</a>
<ul class="sectlevel2">
<li><a href="#_注释">1.1. 注释</a>
<ul class="sectlevel3">
<li><a href="#_单行注释">1.1.1. 单行注释</a></li>
<li><a href="#_多行注释">1.1.2. 多行注释</a></li>
<li><a href="#_文档注释">1.1.3. 文档注释</a></li>
<li><a href="#_shebang行">1.1.4. shebang行</a></li>
</ul>
</li>
<li><a href="#_关键字">1.2. 关键字</a></li>
<li><a href="#_标识符">1.3. 标识符</a>
<ul class="sectlevel3">
<li><a href="#_普通标识符">1.3.1. 普通标识符</a></li>
<li><a href="#_带引号的标识符">1.3.2. 带引号的标识符</a></li>
</ul>
</li>
<li><a href="#all-strings">1.4. 字符串</a>
<ul class="sectlevel3">
<li><a href="#_单引号字符串">1.4.1. 单引号字符串</a></li>
<li><a href="#_字符串连接">1.4.2. 字符串连接</a></li>
<li><a href="#_三单引号字符串">1.4.3. 三单引号字符串</a>
<ul class="sectlevel4">
<li><a href="#_转义特殊字符串">1.4.3.1. 转义特殊字符串</a></li>
<li><a href="#_unicode转义序列">1.4.3.2. Unicode转义序列</a></li>
</ul>
</li>
<li><a href="#_双引号字符串">1.4.4. 双引号字符串</a>
<ul class="sectlevel4">
<li><a href="#_字符串插值">1.4.4.1. 字符串插值</a></li>
<li><a href="#_插值闭包表达式的特殊情况">1.4.4.2. 插值闭包表达式的特殊情况</a></li>
<li><a href="#_与java的互操作性">1.4.4.3. 与Java的互操作性</a></li>
<li><a href="#_gstring和string的hashcodes">1.4.4.4. GString和String的hashCodes</a></li>
</ul>
</li>
<li><a href="#_三双引号字符串">1.4.5. 三双引号字符串</a></li>
<li><a href="#_斜杠字符串">1.4.6. 斜杠字符串</a>
<ul class="sectlevel4">
<li><a href="#_特殊情况">1.4.6.1. 特殊情况</a></li>
</ul>
</li>
<li><a href="#_美元符斜杠字符串">1.4.7. 美元符斜杠字符串</a></li>
<li><a href="#_字符串汇总表">1.4.8. 字符串汇总表</a></li>
<li><a href="#_字符">1.4.9. 字符</a></li>
</ul>
</li>
<li><a href="#_数字">1.5. 数字</a>
<ul class="sectlevel3">
<li><a href="#_整型字面量">1.5.1. 整型字面量</a>
<ul class="sectlevel4">
<li><a href="#_非十进制表示法">1.5.1.1. 非十进制表示法</a></li>
</ul>
</li>
<li><a href="#_小数">1.5.2. 小数</a></li>
<li><a href="#_数字中的下划线">1.5.3. 数字中的下划线</a></li>
<li><a href="#_数字类型后缀">1.5.4. 数字类型后缀</a></li>
<li><a href="#_数学运算">1.5.5. 数学运算</a>
<ul class="sectlevel4">
<li><a href="#integer_division">1.5.5.1. 除法运算符</a></li>
<li><a href="#power_operator">1.5.5.2. 幂运算</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_布尔类型">1.6. 布尔类型</a></li>
<li><a href="#_lists">1.7. Lists</a></li>
<li><a href="#_arrays">1.8. Arrays</a>
<ul class="sectlevel3">
<li><a href="#_java风格的数组初始化">1.8.1. Java风格的数组初始化</a></li>
</ul>
</li>
<li><a href="#_maps">1.9. Maps</a></li>
</ul>
</li>
<li><a href="#groovy-operators">2. 操作符</a>
<ul class="sectlevel2">
<li><a href="#_算术运算符">2.1. 算术运算符</a>
<ul class="sectlevel3">
<li><a href="#_普通算术运算符">2.1.1. 普通算术运算符</a></li>
<li><a href="#_一元运算符">2.1.2. 一元运算符</a></li>
<li><a href="#_赋值算术运算符">2.1.3. 赋值算术运算符</a></li>
</ul>
</li>
<li><a href="#_关系运算符">2.2. 关系运算符</a></li>
<li><a href="#logical_operators">2.3. 逻辑运算符</a>
<ul class="sectlevel3">
<li><a href="#_优先级">2.3.1. 优先级</a></li>
<li><a href="#_短路">2.3.2. 短路</a></li>
</ul>
</li>
<li><a href="#_按位和移位运算符">2.4. 按位和移位运算符</a>
<ul class="sectlevel3">
<li><a href="#_按位运算符">2.4.1. 按位运算符</a></li>
<li><a href="#_移位运算符">2.4.2. 移位运算符</a></li>
</ul>
</li>
<li><a href="#_条件运算符">2.5. 条件运算符</a>
<ul class="sectlevel3">
<li><a href="#_非_运算符">2.5.1. 非 运算符</a></li>
<li><a href="#_三元运算符">2.5.2. 三元运算符</a></li>
<li><a href="#_elvis_操作符">2.5.3. Elvis 操作符</a></li>
<li><a href="#_elvis_赋值运算符">2.5.4. Elvis 赋值运算符</a></li>
</ul>
</li>
<li><a href="#_对象运算符">2.6. 对象运算符</a>
<ul class="sectlevel3">
<li><a href="#_安全导航运算符">2.6.1. 安全导航运算符</a></li>
<li><a href="#_字段直接访问操作符">2.6.2. 字段直接访问操作符</a></li>
<li><a href="#method-pointer-operator">2.6.3. 方法指针运算符</a></li>
<li><a href="#method-reference-operator">2.6.4. 方法引用运算符</a></li>
</ul>
</li>
<li><a href="#_正则表达式运算符">2.7. 正则表达式运算符</a>
<ul class="sectlevel3">
<li><a href="#_模式运算符">2.7.1. 模式运算符</a></li>
<li><a href="#_find_运算符">2.7.2. Find 运算符</a></li>
<li><a href="#_match_运算符">2.7.3. Match 运算符</a></li>
<li><a href="#_find_和_match_运算符的比较">2.7.4. Find 和 Match 运算符的比较</a></li>
</ul>
</li>
<li><a href="#_其他操作符">2.8. 其他操作符</a>
<ul class="sectlevel3">
<li><a href="#_线程操作符">2.8.1. 线程操作符</a>
<ul class="sectlevel4">
<li><a href="#_展开方法参数">2.8.1.1. 展开方法参数</a></li>
<li><a href="#_展开列表元素">2.8.1.2. 展开列表元素</a></li>
<li><a href="#_扩展map中的元素">2.8.1.3. 扩展map中的元素</a></li>
</ul>
</li>
<li><a href="#_范围运算符">2.8.2. 范围运算符</a></li>
<li><a href="#_spaceship_操作符">2.8.3. Spaceship 操作符</a></li>
<li><a href="#subscript-operator">2.8.4. 下标运算符</a></li>
<li><a href="#_安全索引运算符">2.8.5. 安全索引运算符</a></li>
<li><a href="#_成员_运算符">2.8.6. 成员 运算符</a></li>
<li><a href="#_和_运算符">2.8.7. <code>==</code> 和 <code>===</code> 运算符</a></li>
<li><a href="#_类型强制转换运算符">2.8.8. 类型强制转换运算符</a></li>
<li><a href="#_操作符">2.8.9. &lt;&gt; 操作符</a></li>
<li><a href="#_call_运算符">2.8.10. Call 运算符</a></li>
</ul>
</li>
<li><a href="#_运算符优先级">2.9. 运算符优先级</a></li>
<li><a href="#Operator-Overloading">2.10. 运算符重载</a></li>
</ul>
</li>
<li><a href="#_程序结构">3. 程序结构</a>
<ul class="sectlevel2">
<li><a href="#_包名">3.1. 包名</a></li>
<li><a href="#_imports">3.2. Imports</a>
<ul class="sectlevel3">
<li><a href="#_默认导入">3.2.1. 默认导入</a></li>
<li><a href="#_简单导入">3.2.2. 简单导入</a></li>
<li><a href="#_导入">3.2.3. * 导入</a></li>
<li><a href="#_static_导入">3.2.4. Static 导入</a></li>
<li><a href="#_静态导入别名">3.2.5. 静态导入别名</a></li>
<li><a href="#_静态星号导入">3.2.6. 静态星号导入</a></li>
<li><a href="#_导入别名">3.2.7. 导入别名</a></li>
<li><a href="#_命名空间冲突">3.2.8. 命名空间冲突</a></li>
</ul>
</li>
<li><a href="#_脚本与类">3.3. 脚本与类</a>
<ul class="sectlevel3">
<li><a href="#_motivation_for_scripts">3.3.1. Motivation for scripts</a></li>
<li><a href="#_script_class">3.3.2. <code>Script</code> class</a></li>
<li><a href="#_方法">3.3.3. 方法</a></li>
<li><a href="#_变量">3.3.4. 变量</a></li>
<li><a href="#_convenience_variations">3.3.5. Convenience variations</a></li>
</ul>
</li>
<li><a href="#_jep_445_compatible_scripts">3.4. JEP 445 compatible scripts</a>
<ul class="sectlevel3">
<li><a href="#_与java_jep_445行为的差异">3.4.1. 与Java JEP 445行为的差异</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_object_orientation">4. Object orientation</a>
<ul class="sectlevel2">
<li><a href="#_类型">4.1. 类型</a>
<ul class="sectlevel3">
<li><a href="#_基本类型">4.1.1. 基本类型</a></li>
<li><a href="#_引用类型">4.1.2. 引用类型</a></li>
<li><a href="#generics">4.1.3. 泛型</a></li>
</ul>
</li>
<li><a href="#_类">4.2. 类</a>
<ul class="sectlevel3">
<li><a href="#_普通类">4.2.1. 普通类</a></li>
<li><a href="#_内部类">4.2.2. 内部类</a>
<ul class="sectlevel4">
<li><a href="#_匿名内部类">4.2.2.1. 匿名内部类</a></li>
<li><a href="#_抽象类">4.2.2.2. 抽象类</a></li>
</ul>
</li>
<li><a href="#_继承">4.2.3. 继承</a></li>
<li><a href="#superclass">4.2.4. 父类</a></li>
<li><a href="#interfaces">4.2.5. Interfaces</a></li>
</ul>
</li>
<li><a href="#_类成员">4.3. 类成员</a>
<ul class="sectlevel3">
<li><a href="#_构造函数">4.3.1. 构造函数</a>
<ul class="sectlevel4">
<li><a href="#_位置参数">4.3.1.1. 位置参数</a></li>
<li><a href="#_命名参数">4.3.1.2. 命名参数</a></li>
</ul>
</li>
<li><a href="#_方法_2">4.3.2. 方法</a>
<ul class="sectlevel4">
<li><a href="#_方法定义">4.3.2.1. 方法定义</a></li>
<li><a href="#_命名参数_2">4.3.2.2. 命名参数</a></li>
<li><a href="#_默认参数">4.3.2.3. 默认参数</a></li>
<li><a href="#_可变参数">4.3.2.4. 可变参数</a></li>
<li><a href="#_方法选择算法">4.3.2.5. 方法选择算法</a></li>
<li><a href="#_声明异常">4.3.2.6. 声明异常</a></li>
</ul>
</li>
<li><a href="#_字段和属性">4.3.3. 字段和属性</a>
<ul class="sectlevel4">
<li><a href="#fields">4.3.3.1. 字段</a></li>
<li><a href="#properties">4.3.3.2. 属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_注解">4.4. 注解</a>
<ul class="sectlevel3">
<li><a href="#ann-definition">4.4.1. 定义注解</a>
<ul class="sectlevel4">
<li><a href="#ann-placement">4.4.1.1. 使用注解的位置</a></li>
<li><a href="#_注解中成员的值">4.4.1.2. 注解中成员的值</a></li>
<li><a href="#_保留策略">4.4.1.3. 保留策略</a></li>
<li><a href="#_closure_annotation_parameters">4.4.1.4. Closure annotation parameters</a></li>
</ul>
</li>
<li><a href="#_meta_annotations">4.4.2. Meta-annotations</a>
<ul class="sectlevel4">
<li><a href="#_声明元注解">4.4.2.1. 声明元注解</a></li>
<li><a href="#meta-ann-behavior">4.4.2.2. 元注解的行为</a></li>
<li><a href="#meta-ann-members">4.4.2.3. 元注解的参数</a></li>
<li><a href="#handling_duplicate_annotations">4.4.2.4. 处理元注解中的重复注解</a></li>
<li><a href="#meta-ann-processor">4.4.2.5. 自定义元注解处理器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_特质">4.5. 特质</a>
<ul class="sectlevel3">
<li><a href="#_方法_3">4.5.1. 方法</a>
<ul class="sectlevel4">
<li><a href="#_public_方法">4.5.1.1. Public 方法</a></li>
<li><a href="#_abstract_methods">4.5.1.2. Abstract methods</a></li>
<li><a href="#_private_方法">4.5.1.3. Private 方法</a></li>
<li><a href="#_final_方法">4.5.1.4. Final 方法</a></li>
</ul>
</li>
<li><a href="#_this的含义">4.5.2. this的含义</a></li>
<li><a href="#_接口">4.5.3. 接口</a></li>
<li><a href="#_属性">4.5.4. 属性</a></li>
<li><a href="#_字段">4.5.5. 字段</a>
<ul class="sectlevel4">
<li><a href="#_private字段">4.5.5.1. Private字段</a></li>
<li><a href="#_public字段">4.5.5.2. Public字段</a></li>
</ul>
</li>
<li><a href="#_行为的组合">4.5.6. 行为的组合</a></li>
<li><a href="#_重写default方法">4.5.7. 重写default方法</a></li>
<li><a href="#_特质的继承">4.5.8. 特质的继承</a>
<ul class="sectlevel4">
<li><a href="#_简单继承">4.5.8.1. 简单继承</a></li>
<li><a href="#_多重继承">4.5.8.2. 多重继承</a></li>
</ul>
</li>
<li><a href="#_鸭子类型与特质">4.5.9. 鸭子类型与特质</a>
<ul class="sectlevel4">
<li><a href="#_动态代码">4.5.9.1. 动态代码</a></li>
<li><a href="#_特质中的动态方法">4.5.9.2. 特质中的动态方法</a></li>
</ul>
</li>
<li><a href="#_多重继承的冲突">4.5.10. 多重继承的冲突</a>
<ul class="sectlevel4">
<li><a href="#_默认冲突解决方案">4.5.10.1. 默认冲突解决方案</a></li>
<li><a href="#_user_conflict_resolution">4.5.10.2. User conflict resolution</a></li>
</ul>
</li>
<li><a href="#_特质的运行时实现">4.5.11. 特质的运行时实现</a>
<ul class="sectlevel4">
<li><a href="#_在运行时实现特质">4.5.11.1. 在运行时实现特质</a></li>
<li><a href="#_一次实现多个特质">4.5.11.2. 一次实现多个特质</a></li>
</ul>
</li>
<li><a href="#_链式行为">4.5.12. 链式行为</a>
<ul class="sectlevel4">
<li><a href="#_trait_内_super_的语义">4.5.12.1. Trait 内 super 的语义</a></li>
</ul>
</li>
<li><a href="#_高级功能">4.5.13. 高级功能</a>
<ul class="sectlevel4">
<li><a href="#_sam_类型强制">4.5.13.1. SAM 类型强制</a></li>
<li><a href="#_与_java_8_默认方法的差异">4.5.13.2. 与 Java 8 默认方法的差异</a></li>
</ul>
</li>
<li><a href="#_与_mixins_的区别">4.5.14. 与 mixins 的区别</a></li>
<li><a href="#_静态的方法属性和字段">4.5.15. 静态的方法、属性和字段</a></li>
<li><a href="#_状态继承的陷阱">4.5.16. 状态继承的陷阱</a></li>
<li><a href="#_self_types">4.5.17. Self types</a>
<ul class="sectlevel4">
<li><a href="#_特质的类型限制">4.5.17.1. 特质的类型限制</a></li>
<li><a href="#traits-selftype">4.5.17.2. @SelfType注解</a></li>
<li><a href="#_与_sealed_注解孵化中的差异">4.5.17.3. 与 Sealed 注解（孵化中）的差异</a></li>
</ul>
</li>
<li><a href="#_局限性">4.5.18. 局限性</a>
<ul class="sectlevel4">
<li><a href="#_与_ast_转换的兼容性">4.5.18.1. 与 AST 转换的兼容性</a></li>
<li><a href="#_前缀和后缀操作">4.5.18.2. 前缀和后缀操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_record类_孵化中">4.6. Record类 (孵化中)</a>
<ul class="sectlevel3">
<li><a href="#_record类的特殊功能">4.6.1. Record类的特殊功能</a>
<ul class="sectlevel4">
<li><a href="#_紧凑的构造函数">4.6.1.1. 紧凑的构造函数</a></li>
<li><a href="#_序列化">4.6.1.2. 序列化</a></li>
</ul>
</li>
<li><a href="#_groovy_对record类的增强">4.6.2. Groovy 对Record类的增强</a>
<ul class="sectlevel4">
<li><a href="#_参数默认值">4.6.2.1. 参数默认值</a></li>
<li><a href="#_自定义tostring">4.6.2.2. 自定义toString</a></li>
<li><a href="#_获取record中所有属性的值">4.6.2.3. 获取Record中所有属性的值</a></li>
<li><a href="#_获取record中所有属性对应的map">4.6.2.4. 获取Record中所有属性对应的map</a></li>
<li><a href="#_获取record中属性的个数">4.6.2.5. 获取Record中属性的个数</a></li>
<li><a href="#_从record中获取第n个属性">4.6.2.6. 从Record中获取第n个属性</a></li>
</ul>
</li>
<li><a href="#_可选的_groovy_功能">4.6.3. 可选的 Groovy 功能</a>
<ul class="sectlevel4">
<li><a href="#_copying">4.6.3.1. Copying</a></li>
<li><a href="#_深度不可变">4.6.3.2. 深度不可变</a></li>
<li><a href="#_获取record属性对应的tuple">4.6.3.3. 获取Record属性对应的tuple</a></li>
</ul>
</li>
<li><a href="#_与_java_的其他差异">4.6.4. 与 Java 的其他差异</a></li>
</ul>
</li>
<li><a href="#_密封的层次结构_incubating">4.7. 密封的层次结构 (incubating)</a>
<ul class="sectlevel3">
<li><a href="#_与_java_的差异">4.7.1. 与 Java 的差异</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_closures">5. Closures</a>
<ul class="sectlevel2">
<li><a href="#_语法_2">5.1. 语法</a>
<ul class="sectlevel3">
<li><a href="#_定义闭包">5.1.1. 定义闭包</a></li>
<li><a href="#closure-as-object">5.1.2. 闭包作为对象</a></li>
<li><a href="#_调用闭包">5.1.3. 调用闭包</a></li>
</ul>
</li>
<li><a href="#_参数">5.2. 参数</a>
<ul class="sectlevel3">
<li><a href="#_普通参数">5.2.1. 普通参数</a></li>
<li><a href="#implicit-it">5.2.2. 隐式参数</a></li>
<li><a href="#_可变参数_2">5.2.3. 可变参数</a></li>
</ul>
</li>
<li><a href="#_委托delegation策略">5.3. 委托(Delegation)策略</a>
<ul class="sectlevel3">
<li><a href="#_groovy_闭包与_lambda_表达式">5.3.1. Groovy 闭包与 lambda 表达式</a></li>
<li><a href="#closure-owner">5.3.2. Owner, delegate 和 this</a>
<ul class="sectlevel4">
<li><a href="#closure-this">5.3.2.1. 闭包中的this</a></li>
<li><a href="#_闭包的owner属性">5.3.2.2. 闭包的Owner属性</a></li>
<li><a href="#_闭包的delegate">5.3.2.3. 闭包的Delegate</a></li>
<li><a href="#_delegation策略">5.3.2.4. Delegation策略</a></li>
<li><a href="#_delegation策略_in_the_presence_of_metaprogramming">5.3.2.5. Delegation策略 in the presence of metaprogramming</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gstring_中的闭包">5.4. GString 中的闭包</a></li>
<li><a href="#_闭包强制转换">5.5. 闭包强制转换</a></li>
<li><a href="#_函数式编程">5.6. 函数式编程</a>
<ul class="sectlevel3">
<li><a href="#_柯里化">5.6.1. 柯里化</a>
<ul class="sectlevel4">
<li><a href="#_左柯里化">5.6.1.1. 左柯里化</a></li>
<li><a href="#_右柯里化">5.6.1.2. 右柯里化</a></li>
<li><a href="#_基于索引的柯里化">5.6.1.3. 基于索引的柯里化</a></li>
</ul>
</li>
<li><a href="#_记忆化">5.6.2. 记忆化</a></li>
<li><a href="#_闭包组合">5.6.3. 闭包组合</a></li>
<li><a href="#_trampoline">5.6.4. Trampoline</a></li>
<li><a href="#_方法指针">5.6.5. 方法指针</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_语义学">6. 语义学</a>
<ul class="sectlevel2">
<li><a href="#_语句">6.1. 语句</a>
<ul class="sectlevel3">
<li><a href="#_变量定义">6.1.1. 变量定义</a></li>
<li><a href="#_变量赋值">6.1.2. 变量赋值</a>
<ul class="sectlevel4">
<li><a href="#_多重赋值">6.1.2.1. 多重赋值</a></li>
<li><a href="#_上溢和下溢">6.1.2.2. 上溢和下溢</a></li>
<li><a href="#_使用多重赋值进行对象解构">6.1.2.3. 使用多重赋值进行对象解构</a></li>
</ul>
</li>
<li><a href="#_控制结构">6.1.3. 控制结构</a>
<ul class="sectlevel4">
<li><a href="#_条件结构">6.1.3.1. 条件结构</a></li>
<li><a href="#_循环结构">6.1.3.2. 循环结构</a></li>
<li><a href="#_异常处理">6.1.3.3. 异常处理</a></li>
<li><a href="#_try_catch_finally">6.1.3.4. try / catch / finally</a></li>
<li><a href="#_多重捕获">6.1.3.5. 多重捕获</a></li>
<li><a href="#_try_with_resources">6.1.3.6. Try with resources</a></li>
</ul>
</li>
<li><a href="#_断言">6.1.4. 断言</a></li>
<li><a href="#_标签语句">6.1.5. 标签语句</a></li>
</ul>
</li>
<li><a href="#_表达式">6.2. 表达式</a>
<ul class="sectlevel3">
<li><a href="#gpath_expressions">6.2.1. GPath 表达式</a>
<ul class="sectlevel4">
<li><a href="#_对象导航">6.2.1.1. 对象导航</a></li>
<li><a href="#_表达式解构">6.2.1.2. 表达式解构</a></li>
<li><a href="#_用于_xml_导航的_gpath">6.2.1.3. 用于 XML 导航的 GPath</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_promotion_and_coercion">6.3. Promotion and coercion</a>
<ul class="sectlevel3">
<li><a href="#_number_promotion">6.3.1. Number promotion</a></li>
<li><a href="#closure-coercion">6.3.2. Closure to type coercion</a>
<ul class="sectlevel4">
<li><a href="#_将闭包分配给_sam_类型">6.3.2.1. 将闭包分配给 SAM 类型</a></li>
<li><a href="#_calling_a_method_accepting_a_sam_type_with_a_closure">6.3.2.2. Calling a method accepting a SAM type with a closure</a></li>
<li><a href="#_closure_to_arbitrary_type_coercion">6.3.2.3. Closure to arbitrary type coercion</a></li>
</ul>
</li>
<li><a href="#_map_to_type_coercion">6.3.3. Map to type coercion</a></li>
<li><a href="#_string_to_enum_coercion">6.3.4. String to enum coercion</a></li>
<li><a href="#_custom_type_coercion">6.3.5. Custom type coercion</a></li>
<li><a href="#_class_literals_vs_variables_and_the_as_operator">6.3.6. Class literals vs variables and the as operator</a></li>
</ul>
</li>
<li><a href="#_可省略的">6.4. 可省略的</a>
<ul class="sectlevel3">
<li><a href="#_可选的括号">6.4.1. 可选的括号</a></li>
<li><a href="#_可选的分号">6.4.2. 可选的分号</a></li>
<li><a href="#_可选的return关键字">6.4.3. 可选的return关键字</a></li>
<li><a href="#_可选的public关键字">6.4.4. 可选的public关键字</a></li>
</ul>
</li>
<li><a href="#the-groovy-truth">6.5. 表达式的真假</a>
<ul class="sectlevel3">
<li><a href="#_boolean_expressions">6.5.1. Boolean expressions</a></li>
<li><a href="#_集合和数组">6.5.2. 集合和数组</a></li>
<li><a href="#_matchers">6.5.3. Matchers</a></li>
<li><a href="#_迭代器和枚举">6.5.4. 迭代器和枚举</a></li>
<li><a href="#_maps_2">6.5.5. Maps</a></li>
<li><a href="#_strings">6.5.6. Strings</a></li>
<li><a href="#_numbers">6.5.7. Numbers</a></li>
<li><a href="#_object_references">6.5.8. Object References</a></li>
<li><a href="#_使用_asboolean_方法自定义真假">6.5.9. 使用 asBoolean() 方法自定义真假</a></li>
</ul>
</li>
<li><a href="#_类型_2">6.6. 类型</a>
<ul class="sectlevel3">
<li><a href="#_可选类型">6.6.1. 可选类型</a></li>
<li><a href="#static-type-checking">6.6.2. 静态类型检查</a>
<ul class="sectlevel4">
<li><a href="#_typechecked_注释">6.6.2.1. @TypeChecked 注释</a></li>
<li><a href="#_类型检查赋值">6.6.2.2. 类型检查赋值</a></li>
<li><a href="#_list_和_map_构造器">6.6.2.3. List 和 map 构造器</a></li>
<li><a href="#_方法检查">6.6.2.4. 方法检查</a></li>
<li><a href="#type-inference">6.6.2.5. 类型推断</a></li>
<li><a href="#_closures_and_type_inference">6.6.2.6. Closures and type inference</a></li>
</ul>
</li>
<li><a href="#_static_compilation">6.6.3. Static compilation</a>
<ul class="sectlevel4">
<li><a href="#_dynamic_vs_static">6.6.3.1. Dynamic vs static</a></li>
<li><a href="#compilestatic-annotation">6.6.3.2. The <code>@CompileStatic</code> annotation</a></li>
<li><a href="#_key_benefits">6.6.3.3. Key benefits</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_类型检查扩展">6.7. 类型检查扩展</a>
<ul class="sectlevel3">
<li><a href="#_编写类型检查扩展">6.7.1. 编写类型检查扩展</a>
<ul class="sectlevel4">
<li><a href="#_更智能的类型检查器">6.7.1.1. 更智能的类型检查器</a></li>
<li><a href="#Typecheckingextensions-Howdoesitwork">6.7.1.2. <code>extensions</code> 属性</a></li>
<li><a href="#_应用于类型检查的dsl">6.7.1.3. 应用于类型检查的DSL</a></li>
<li><a href="#Typecheckingextensions-TheAPI">6.7.1.4. Type checking extensions API</a></li>
<li><a href="#Typecheckingextensions-Workingwithextensions">6.7.1.5. Working with extensions</a></li>
</ul>
</li>
<li><a href="#_advanced_type_checking_extensions">6.7.2. Advanced type checking extensions</a>
<ul class="sectlevel4">
<li><a href="#_precompiled_type_checking_extensions">6.7.2.1. Precompiled type checking extensions</a></li>
<li><a href="#_using_grab_in_a_type_checking_extension">6.7.2.2. Using @Grab in a type checking extension</a></li>
<li><a href="#_sharing_or_packaging_type_checking_extensions">6.7.2.3. Sharing or packaging type checking extensions</a></li>
<li><a href="#_global_type_checking_extensions">6.7.2.4. Global type checking extensions</a></li>
<li><a href="#_type_checking_extensions_and_compilestatic">6.7.2.5. Type checking extensions and @CompileStatic</a></li>
<li><a href="#mixed-mode">6.7.2.6. Mixed mode compilation</a></li>
<li><a href="#ast-xform-as-extension">6.7.2.7. Transforming the AST in an extension</a></li>
<li><a href="#_examples">6.7.2.8. Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_语法"><a class="link" href="#_语法">1. 语法</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将覆盖Groovy编程语言的语法。 Groovy语言的语法是由JAVA语言的语法衍生出来, 但具体结构上会有所增强，同时容许一定的简化。</p>
</div>
<div class="sect2">
<h3 id="_注释"><a class="link" href="#_注释">1.1. 注释</a></h3>
<div class="sect3">
<h4 id="_单行注释"><a class="link" href="#_单行注释">1.1.1. 单行注释</a></h4>
<div class="paragraph">
<p>单行注释以 <code>//</code> 开始，同时它可以出现在行的任何地方。 在 <code>//</code> 之后的字符, 一直到行尾都是注释的部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// a standalone single line comment</span>
println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span> <span style="color:#777">// a comment till the end of the line</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多行注释"><a class="link" href="#_多行注释">1.1.2. 多行注释</a></h4>
<div class="paragraph">
<p>一个多行的注释以 <code>/*</code> 开头，同时它可以出现在行的任何地方。</p>
</div>
<div class="paragraph">
<p>在 <code>/*</code> 之后的字符将会被视作注释的一部分，包括新一行的字符, 直到第一个 <code>*/</code> 来结束注释。</p>
</div>
<div class="paragraph">
<p>多行注释因此可以被放到行尾，或者甚至在句子中间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">/* a standalone multiline comment
   spanning two lines */</span>
println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span> <span style="color:#777">/* a multiline comment starting
                   at the end of a statement */</span>
println <span style="color:#00D">1</span> <span style="color:#777">/* one */</span> + <span style="color:#00D">2</span> <span style="color:#777">/* two */</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_文档注释"><a class="link" href="#_文档注释">1.1.3. 文档注释</a></h4>
<div class="paragraph">
<p>与多行注释类似，文档注释是多行的，但是是以 <code>/**</code> 开始和以 <code>*/</code> 结尾。 在第一行GroovyDoc注释之后的行可以可选地以 `*`开头。 这些注释的组成有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型定义（类，接口，枚举，注解）</p>
</li>
<li>
<p>字段和属性定义</p>
</li>
<li>
<p>方法定义</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">/**
 * A Class description
 */</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#777">/** the name of the person */</span>
    <span style="color:#0a8;font-weight:bold">String</span> name

    <span style="color:#777">/**
     * Creates a greeting method for a certain person.
     *
     * @param otherPerson the person to greet
     * @return a greeting message
     */</span>
    <span style="color:#0a8;font-weight:bold">String</span> greet(<span style="color:#0a8;font-weight:bold">String</span> otherPerson) {
       <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>otherPerson<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy文档注释遵循与Java文档注释一样的约定。 所以你可以使用与Java文档注释一样的tags</p>
</div>
<div class="paragraph">
<p>另外, Groovy从3.0.0开始支持 <strong>运行时文档注释</strong>. 运行时文档注释可以在运行时保留.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Groovy运行时文档注释默认不启用. 可以通过添加JVM参数 <code>-Dgroovy.attach.runtime.groovydoc=true</code> 来启用它Runtime
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>运行时文档注释以 <code>/**@</code> 开始, 以 <code>*/</code> 结束, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">/**@
 * Some class groovydoc for Foo
 */</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> {
    <span style="color:#777">/**@
     * Some method groovydoc for bar
     */</span>
    <span style="color:#339;font-weight:bold">void</span> bar() {
    }
}

<span style="color:#080;font-weight:bold">assert</span> Foo.class.groovydoc.content.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Some class groovydoc for Foo</span><span style="color:#710">'</span></span>) // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> Foo.class.getMethod(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>, <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Class</span>[<span style="color:#00D">0</span>]).groovydoc.content.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Some method groovydoc for bar</span><span style="color:#710">'</span></span>) // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>获取类 <code>Foo</code> 上的运行时文档注释</p>
</li>
<li>
<p>获取方法 <code>bar</code> 上的运行时文档注释</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_shebang行"><a class="link" href="#_shebang行">1.1.4. shebang行</a></h4>
<div class="paragraph">
<p>除了单行注释外，还有一种特殊的行注释，在UNIX 系统中通常被称为  <em>shebang</em> 行，允许脚本直接从命令行运行，前提是你已安装了 Groovy 发行版并且 <code>groovy</code> 命令在 <code>PATH</code> 上可用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#34b">#!/usr/bin/env groovy</span>
println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello from the shebang line</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>#</code> 字符必须是文件的第一个字符。 任何缩进都会引起一个编译错误。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关键字"><a class="link" href="#_关键字">1.2. 关键字</a></h3>
<div class="paragraph">
<p>下面的列表列出了全部Groovy语言的保留关键字:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 保留关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">abstract</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">assert</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">break</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">case</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">catch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">const</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">continue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">def</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">do</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">else</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">enum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">extends</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">final</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">finally</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">for</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">goto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">implements</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">import</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">instanceof</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">native</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">new</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">non-sealed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">package</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">public</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">protected</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">private</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">static</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">strictfp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">super</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">switch</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">synchronized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">this</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">threadsafe</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">throw</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">throws</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">transient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">try</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">while</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>其中，<code>const</code> 、<code>goto</code> 、<code>strictfp</code> 和 <code>threadsafe</code> 目前没有在使用中。</p>
</div>
<div class="paragraph">
<p>一般情况下，保留关键字不能用作变量、字段和方法名。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>将方法名用引号括起来, 允许定义具有与关键字相同名称的方法, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// reserved keywords can be used for method names if quoted</span>
<span style="color:#080;font-weight:bold">def</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">abstract</span><span style="color:#710">&quot;</span></span>() { <span style="color:#069">true</span> }
<span style="color:#777">// when calling such methods, the name must be qualified using &quot;this.&quot;</span>
<span style="color:#950">this</span>.abstract()</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这样的名称可能会令人困惑，通常最好避免使用。
这个技巧主要是为了在特定的Java集成场景和特定<a href="../core-domain-specific-languages.html">DSL</a> 场景实现一些希望使用与关键字相同名称的“动词”和“名词”的情况。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，Groovy 还具有以下上下文关键字：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Contextual Keywords</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">as</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">permits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">record</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sealed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">trait</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">var</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yields</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些单词只在特定上下文中成为关键字，并且在某些地方可以更自由地使用，特别是在变量、字段和方法名中。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>这些额外的宽松性允许我们使用在较早版本的Groovy中不是关键字，或者在Java中也不是关键字的单词来作为变量名, 示例如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// contextual keywords can be used for field and variable names</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#080;font-weight:bold">as</span> = <span style="color:#069">true</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">as</span>

<span style="color:#777">// contextual keywords can be used for method names</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">in</span>() { <span style="color:#069">true</span> }
<span style="color:#777">// when calling such methods, the name only needs to be qualified using &quot;this.&quot; in scenarios which would be ambiguous</span>
<span style="color:#950">this</span>.in()</code></pre>
</div>
</div>
<div class="paragraph">
<p>熟悉这些上下文关键字的Groovy程序员可能仍然希望避免使用这些名称，除非有充分的理由要使用这样的名称。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>对于保留关键字的限制也适用于原始类型、布尔字面量和空字面量（这些稍后会进行讨论）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. 其他保留关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>虽然不建议，但可以使用与保留关键字相同的技巧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">null</span><span style="color:#710">&quot;</span></span>() { <span style="color:#069">true</span> }  <span style="color:#777">// not recommended; potentially confusing</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#950">this</span>.null()     <span style="color:#777">// must be qualified</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将这些单词用作方法名可能会引起混淆，通常最好避免使用。
然而，对于某些 <a href="../core-domain-specific-languages.html">DSLs</a> 来说，这可能是有用的。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_标识符"><a class="link" href="#_标识符">1.3. 标识符</a></h3>
<div class="sect3">
<h4 id="_普通标识符"><a class="link" href="#_普通标识符">1.3.1. 普通标识符</a></h4>
<div class="paragraph">
<p>标识符以字母，美元符或下划线开头。不能以数字开头</p>
</div>
<div class="paragraph">
<p>字母可以是以下的范围:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>'a' to 'z' (小写 ascii 字母)</p>
</li>
<li>
<p>'A' to 'Z' (大写 ascii 字母)</p>
</li>
<li>
<p>'\u00C0' to '\u00D6'</p>
</li>
<li>
<p>'\u00D8' to '\u00F6'</p>
</li>
<li>
<p>'\u00F8' to '\u00FF'</p>
</li>
<li>
<p>'\u0100' to '\uFFFE'</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>之后的字符可以包含字母和数字。</p>
</div>
<div class="paragraph">
<p>以下是一些有效标识符的示例（变量名）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> name
<span style="color:#080;font-weight:bold">def</span> item3
<span style="color:#080;font-weight:bold">def</span> with_underscore
<span style="color:#080;font-weight:bold">def</span> <span style="color:#F00;background-color:#FAA">$</span>dollarStart</code></pre>
</div>
</div>
<div class="paragraph">
<p>但以下的是不合法的标识符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#00D">3</span>tier
<span style="color:#080;font-weight:bold">def</span> a+b
<span style="color:#080;font-weight:bold">def</span> a<span style="color:#F00;background-color:#FAA">#</span>b</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有跟在点号后的关键字也是合法的标识符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">foo.as
foo.assert
foo.break
foo.case
foo.catch</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_带引号的标识符"><a class="link" href="#_带引号的标识符">1.3.2. 带引号的标识符</a></h4>
<div class="paragraph">
<p>带引号标识符出现在点号表达式的点号之后.
例如，<code>person.name</code> 表达式中 <code>name</code> 部分就可以通过引号引起来成为 <code>person."name"</code> 或 <code>person.'name'</code> .
有趣的是，当某些标识符包含Java语言规范中禁止的非法字符，引号引起来后在Groovy就会被容许。 例如，像一个破折号，空格，感叹号等字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> map = [:]

map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">an identifier with a space and double quotes</span><span style="color:#710">&quot;</span></span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ALLOWED</span><span style="color:#710">&quot;</span></span>
map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">with-dash-signs-and-single-quotes</span><span style="color:#710">'</span></span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ALLOWED</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">assert</span> map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">an identifier with a space and double quotes</span><span style="color:#710">&quot;</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ALLOWED</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">with-dash-signs-and-single-quotes</span><span style="color:#710">'</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ALLOWED</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在 <a href="#all-strings">strings</a> 中看到的, Groovy提供不同的字符串字面量。 所有跟着点号的字符串都是被允许的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">single quote</span><span style="color:#710">'</span></span>
map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">double quote</span><span style="color:#710">&quot;</span></span>
map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'''</span><span style="color:#D20">triple single quote</span><span style="color:#710">'''</span></span>
map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;&quot;&quot;</span><span style="color:#D20">triple double quote</span><span style="color:#710">&quot;&quot;&quot;</span></span>
map.<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">slashy string</span><span style="color:#404">/</span></span>
map.<span style="color:#F00;background-color:#FAA">$</span><span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">dollar slashy string</span><span style="color:#404">/</span></span><span style="color:#F00;background-color:#FAA">$</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如下面的例子，纯字符的字符串和Groovy的GStings（字符串插值）的区别是，计算整个标识符时，插入的字符值是被插入到最终字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> firstname = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Homer</span><span style="color:#710">&quot;</span></span>
map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Simpson-</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>firstname<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Homer Simpson</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">assert</span> map.<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Simpson-Homer</span><span style="color:#710">'</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Homer Simpson</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="all-strings"><a class="link" href="#all-strings">1.4. 字符串</a></h3>
<div class="paragraph">
<p>字符以链的形式形成的文本被称作字符串。 Groovy容许你实例化 <code>java.lang.String</code> 对象，以及在其他语言中被称作 <em>插值字符串</em> （interpolated strings）的GStrings (<code>groovy.lang.GString</code>)</p>
</div>
<div class="sect3">
<h4 id="_单引号字符串"><a class="link" href="#_单引号字符串">1.4.1. 单引号字符串</a></h4>
<div class="paragraph">
<p>单引号字符串是一系列被单引号引起来的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a single-quoted string</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
单引号括起的字符串是普通的 <code>java.lang.String</code> ，不支持插值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_字符串连接"><a class="link" href="#_字符串连接">1.4.2. 字符串连接</a></h4>
<div class="paragraph">
<p>所有Groovy的字符串都可以用 <code>+</code> 号连接起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ab</span><span style="color:#710">'</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span> + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_三单引号字符串"><a class="link" href="#_三单引号字符串">1.4.3. 三单引号字符串</a></h4>
<div class="paragraph">
<p>三引号字符串是一系列被三个单引号引起来的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'''</span><span style="color:#D20">a triple-single-quoted string</span><span style="color:#710">'''</span></span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
单引号括起的字符串是普通的 <code>java.lang.String</code> ，不支持插值。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>三引号字符串可以是多行的。 你不必将字符串分割成几块，也不必用连接符或换行符转义字符来将字符串跨行：:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> aMultilineString = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'''</span><span style="color:#D20">line one
line two
line three</span><span style="color:#710">'''</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你的代码是缩进的，比如在类里面的方法，你的字符串将会包含这些空白的缩进。 Groovy开发套件提供 <code>String#stripIndent()</code> 方法来剥离（stripping out）缩进， 同时Groovy开发套件提供 <code>String#stripMargin()</code> 方法，该方法需要一个分隔符来识别从字符串的开头开始删除的文本。</p>
</div>
<div class="paragraph">
<p>当创建如下的字符串时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> startingAndEndingWithANewline = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'''</span><span style="color:#D20">
line one
line two
line three
</span><span style="color:#710">'''</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你会发现，得到的是一个以换行符开头的字符串。可以通过反斜杠转义换行来剥离该字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> strippedFirstNewline = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'''</span><span style="color:#D20">\
</span><span style="color:#D20">line one
line two
line three
</span><span style="color:#710">'''</span></span>

<span style="color:#080;font-weight:bold">assert</span> !strippedFirstNewline.startsWith(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">\n</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_转义特殊字符串"><a class="link" href="#_转义特殊字符串">1.4.3.1. 转义特殊字符串</a></h5>
<div class="paragraph">
<p>你可以用反斜杠来转义单引号来避免终止字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">an escaped single quote: </span><span style="color:#b0b">\'</span><span style="color:#D20"> needs a backslash</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同时你可以用两个反斜杠转义转义符号本身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">an escaped escape character: </span><span style="color:#b0b">\\</span><span style="color:#D20"> needs a double backslash</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一些特殊的字符串都是用反斜杠来作为转义字符：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Escape sequence</th>
<th class="tableblock halign-left valign-top">Character</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backspace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">formfeed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">newline</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">carriage return</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">single space</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tabulation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\\</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backslash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">single quote within a single-quoted string (and optional for triple-single-quoted and double-quoted strings)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double quote within a double-quoted string (and optional for triple-double-quoted and single-quoted strings)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当涉及到后面讨论的其他类型的字符串时，我们将看到一些更多的转义细节。</p>
</div>
</div>
<div class="sect4">
<h5 id="_unicode转义序列"><a class="link" href="#_unicode转义序列">1.4.3.2. Unicode转义序列</a></h5>
<div class="paragraph">
<p>对于不存在你键盘上的字符，你可以使用Unicode转义序列：反斜杠，然后是u，然后4个十六进制数字。</p>
</div>
<div class="paragraph">
<p>例如，欧元货币符号可以表示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The Euro currency symbol: \u20AC</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_双引号字符串"><a class="link" href="#_双引号字符串">1.4.4. 双引号字符串</a></h4>
<div class="paragraph">
<p>双引号字符串是一系列被双引号引起来的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a double-quoted string</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
如果没有插值表示式的话，双引号字符串就是 <code>java.lang.String</code>  ， 但如果有插值存在的话，双引号字符串就是一个 <code>groovy.lang.GString</code> 实例。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
为了转义一个双引号，你可以用反斜杠符号："A double quote: \"".
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_字符串插值"><a class="link" href="#_字符串插值">1.4.4.1. 字符串插值</a></h5>
<div class="paragraph">
<p>除了单引号和三引号字符串,任何Groovy表达式都可以插值到所有的字符串里。
插值就是当计算字符串的值时，用值替换掉字符串中的占位符。</p>
</div>
<div class="paragraph">
<p>占位符表达式被 ${} 包围。在涉及到明确的点表达式时，大括号可以省略，也就是在这些情况下我们可以只使用 $ 前缀。</p>
</div>
<div class="paragraph">
<p>当一个GString被传递到一个需要String参数的方法时, 在占位符中的表达式会被转换为他的字符串值 (通过在表达式上调用 <code>toString()</code>), 然后将整个String传递到方法中</p>
</div>
<div class="paragraph">
<p>在这里，我们有一个带占位符的字符串，这个占位符引用一个本地变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span> <span style="color:#777">// a plain string</span>
<span style="color:#080;font-weight:bold">def</span> greeting = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">assert</span> greeting.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello Guillaume</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然而任何的Groovy表达式都是有效的，正如我们看到的这个例子，它带有一个算术表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> sum = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The sum of 2 and 3 equals </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span><span style="color:#00D">2</span> + <span style="color:#00D">3</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> sum.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The sum of 2 and 3 equals 5</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
不但表达式在${}占位符里面是合法的。语句也同样是合法的，但语句的值为 <code>null</code> 。
所以如果有多个语句在占位符里面，最后的那个语句应该返回一个有意义的值，以便替换整个占位符的值。
例如， "The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}" 是可以工作的，但一个好的做法通常是在GString里面的占位符内的表达式应该尽量简单。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除了 ${} 占位符之外，我们还可以使用独立的 $ 符号作为点表达式的前缀:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> person = [<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">36</span>]
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>person</span><span style="color:#D20">.name is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>person</span><span style="color:#D20">.age years old</span><span style="color:#710">&quot;</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume is 36 years old</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，只有形式为 <code>a.b</code> 、<code>a.b.c</code> 等的点表达式是有效的。</p>
</div>
<div class="paragraph">
<p>Expressions containing parentheses like method calls,
curly braces for closures, dots which aren&#8217;t part of a property expression or arithmetic operators would be invalid.</p>
</div>
<div class="paragraph">
<p>给定如下的变量定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> number = <span style="color:#60E">3.14</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的句子会抛出一个 <code>groovy.lang.MissingPropertyException</code> 异常，因为Groovy认为你试图访问这个数字的 <code>toString</code> 这个不存在的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">shouldFail(MissingPropertyException) {
    println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>number</span><span style="color:#D20">.toString()</span><span style="color:#710">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
你可以将 <code>"$number.toString()"</code> 想象为被解析器解释执行为 <code>"${number.toString}()"</code> .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>类似地，如果表达式存在歧义，你需要保留大括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> thing = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">treasure</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The x-coordinate of the treasure is represented by treasure.x</span><span style="color:#710">'</span></span> ==
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The x-coordinate of the </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>thing</span><span style="color:#D20"> is represented by </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>thing</span><span style="color:#D20">.x</span><span style="color:#710">&quot;</span></span>   <span style="color:#777">// &lt;= Not allowed: ambiguous!!</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The x-coordinate of the treasure is represented by treasure.x</span><span style="color:#710">'</span></span> ==
        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The x-coordinate of the </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>thing</span><span style="color:#D20"> is represented by </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>thing<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">.x</span><span style="color:#710">&quot;</span></span>  <span style="color:#777">// &lt;= Curly braces required</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要在 GString 中转义 <code>$</code> 或 <code>${}</code> 占位符，使它们显示而不发生插值，只需要使用 <code>\</code> 反斜杠字符来转义美元符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">$5</span><span style="color:#710">'</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\$</span><span style="color:#D20">5</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">${name}</span><span style="color:#710">'</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#b0b">\$</span><span style="color:#D20">{name}</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_插值闭包表达式的特殊情况"><a class="link" href="#_插值闭包表达式的特殊情况">1.4.4.2. 插值闭包表达式的特殊情况</a></h5>
<div class="paragraph">
<p>到目前为止，我们已经看到，我们可以插任意值到 <code>${}</code> 占位符，但这里有一个特殊情况就是闭包表达式。 当占位符包含一个箭头，<code>${→}</code> ,这个表达式事实上是一个闭包表达式&#8201;&#8212;&#8201;你可以把它看作是一个带有美元符前缀的闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> sParameterLessClosure = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">1 + 2 == </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>-&gt; <span style="color:#00D">3</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> sParameterLessClosure == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1 + 2 == 3</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">def</span> sOneParamClosure = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">1 + 2 == </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span> w -&gt; w &lt;&lt; <span style="color:#00D">3</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> sOneParamClosure == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1 + 2 == 3</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这个闭包是一个不带参数的无参闭包。</p>
</li>
<li>
<p>在这里，闭包接受一个 <code>java.io.StringWriter</code> 参数，你可以用 <code>&lt;&lt;</code> 左移运算符添加内容。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在任一情况下，这两个占位符都是嵌套的闭包。</p>
</div>
<div class="paragraph">
<p>从表面上看，它看起来像是一种定义要插值的表达式的更详细的方式，但闭包比单纯的表达式有一个有趣的优点：惰性求值。</p>
</div>
<div class="paragraph">
<p>让我们考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> number = <span style="color:#00D">1</span> // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> eagerGString = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>number<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> lazyGString = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span> -&gt; number <span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">assert</span> eagerGString == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == 1</span><span style="color:#710">&quot;</span></span> // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> lazyGString ==  <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == 1</span><span style="color:#710">&quot;</span></span> // <b class="conum">(3)</b>

number = <span style="color:#00D">2</span> // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> eagerGString == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == 1</span><span style="color:#710">&quot;</span></span> // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> lazyGString ==  <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value == 2</span><span style="color:#710">&quot;</span></span> // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们定义一个包含 1 的 number 变量，然后将其插入两个 GString 中，作为 eagerGString 中的表达式和 lazyGString 中的闭包。</p>
</li>
<li>
<p>我们期望结果字符串包含与 eagerGString 相同的字符串值 1。</p>
</li>
<li>
<p>对于 lazyGString 也是如此</p>
</li>
<li>
<p>然后我们将变量的值更改为新数字</p>
</li>
<li>
<p>对于简单的插值表达式，该值实际上是在创建 GString 时绑定的。</p>
</li>
<li>
<p>但使用闭包表达式时，每次将 GString 强制转换为 String 时都会调用闭包，从而生成包含新数值的更新字符串。</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
带有多个参数的嵌入式闭包表达式将在运行时生成异常。只允许带有零个或一个参数的闭包。
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_与java的互操作性"><a class="link" href="#_与java的互操作性">1.4.4.3. 与Java的互操作性</a></h5>
<div class="paragraph">
<p>当一个方法（无论是用 Java 还是 Groovy 实现）需要一个 java.lang.String ，但我们传递一个 groovy.lang.GString 实例时，GString 的 toString() 方法会自动且透明地执行叫。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> takeString(<span style="color:#0a8;font-weight:bold">String</span> message) {         // <b class="conum">(4)</b>
    <span style="color:#080;font-weight:bold">assert</span> message <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">String</span>        // <b class="conum">(5)</b>
    <span style="color:#080;font-weight:bold">return</span> message
}

<span style="color:#080;font-weight:bold">def</span> message = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The message is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">hello</span><span style="color:#710">'</span></span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>   // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> message <span style="color:#080;font-weight:bold">instanceof</span> GString           // <b class="conum">(2)</b>

<span style="color:#080;font-weight:bold">def</span> result = takeString(message)            // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> result <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">String</span>
<span style="color:#080;font-weight:bold">assert</span> result == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The message is hello</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们创建一个 GString 变量</p>
</li>
<li>
<p>我们仔细检查它是 GString 的实例</p>
</li>
<li>
<p>然后我们将该 GString 传递给以 String 作为参数的方法</p>
</li>
<li>
<p>takeString() 方法的签名明确表示其唯一参数是字符串</p>
</li>
<li>
<p>我们还验证该参数确实是一个 String 而不是 GString。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_gstring和string的hashcodes"><a class="link" href="#_gstring和string的hashcodes">1.4.4.4. GString和String的hashCodes</a></h5>
<div class="paragraph">
<p>尽管可以使用插值字符串代替普通 Java 字符串，但它们在特定方面与字符串不同：它们的 hashCode 不同。普通 Java 字符串是不可变的，而 GString 的结果字符串表示形式可能会有所不同，具体取决于其插值。即使对于相同的结果字符串，GString 和 String 也不具有相同的 hashCode。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">one: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span><span style="color:#00D">1</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>.hashCode() != <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">one: 1</span><span style="color:#710">&quot;</span></span>.hashCode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>GString 和 String 具有不同的 hashCode 值，应避免使用 GString 作为 Map 键，特别是当我们尝试使用 String 而不是 GString 检索关联值时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> key = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> m = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>key<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">letter </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>key<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>]     // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> m[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>] == <span style="color:#069">null</span>                   // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>该映射是使用一个初始对创建的，其键是 GString</p>
</li>
<li>
<p>当我们尝试使用 String 键获取值时，我们将找不到它，因为 String 和 GString 具有不同的 hashCode 值</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_三双引号字符串"><a class="link" href="#_三双引号字符串">1.4.5. 三双引号字符串</a></h4>
<div class="paragraph">
<p>三重双引号字符串的行为类似于双引号字符串，此外它们是多行的，就像三重单引号字符串一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> template = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;&quot;&quot;</span><span style="color:#D20">
    Dear Mr </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">,

    You're the winner of the lottery!

    Yours sincerly,

    Dave
</span><span style="color:#710">&quot;&quot;&quot;</span></span>

<span style="color:#080;font-weight:bold">assert</span> template.toString().contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
双引号和单引号都不需要在三重双引号字符串中进行转义。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_斜杠字符串"><a class="link" href="#_斜杠字符串">1.4.6. 斜杠字符串</a></h4>
<div class="paragraph">
<p>除了通常的带引号的字符串之外，Groovy 还提供斜杠字符串，它使用 / 作为开始和结束分隔符。斜杠字符串对于定义正则表达式和模式特别有用，因为不需要转义反斜杠。</p>
</div>
<div class="paragraph">
<p>斜杠字符串的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> fooPattern = <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">.*foo.*</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> fooPattern == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">.*foo.*</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只有正斜杠需要用反斜杠转义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> escapeSlash = <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">The character </span><span style="color:#D20">\/</span><span style="color:#808"> is a forward slash</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> escapeSlash == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The character / is a forward slash</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>斜杠字符串是多行的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> multilineSlashy = <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">one</span></span><span style="color:#F00;background-color:#FAA">
</span>    two
    three/

<span style="color:#080;font-weight:bold">assert</span> multilineSlashy.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">\n</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Slashy 字符串可以被认为是定义 GString 的另一种方式，但具有不同的转义规则。因此它们支持插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> color = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">blue</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> interpolatedSlashy = <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">a </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>color<span style="font-weight:bold;color:#666">}</span></span><span style="color:#808"> car</span><span style="color:#404">/</span></span>

<span style="color:#080;font-weight:bold">assert</span> interpolatedSlashy == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a blue car</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_特殊情况"><a class="link" href="#_特殊情况">1.4.6.1. 特殊情况</a></h5>
<div class="paragraph">
<p>空的斜杠字符串不能用双正斜杠表示，因为 Groovy 解析器将其理解为行注释。这就是为什么以下断言实际上不会编译，因为它看起来像一个非终止语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span> == <span style="color:#777">//</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于斜线字符串主要是为了使正则表达式更容易而设计的，因此 GString 中的一些错误（例如 $() 或 $5 ）将适用于斜线字符串。</p>
</div>
<div class="paragraph">
<p>请记住，转义反斜杠不是必需的。另一种思考方式是，实际上不支持转义。斜杠字符串 <code>/\t/</code> 不会包含制表符，而是包含反斜杠，后跟字符“t”。仅允许转义正斜杠，即 <code>/\/folder/</code> 将是包含 <code>'/folder'</code> 的斜杠字符串。</p>
</div>
<div class="paragraph">
<p>转义正斜杠的结果是斜杠字符串不能以反斜杠结尾。否则将会转义斜杠字符串终止符。您可以使用特殊技巧 <code>/ends with slash ${'\'}/</code> 。但在这种情况下最好避免使用斜线。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_美元符斜杠字符串"><a class="link" href="#_美元符斜杠字符串">1.4.7. 美元符斜杠字符串</a></h4>
<div class="paragraph">
<p>美元斜线字符串是用开头 $/ 和结尾 /$ 分隔的多行 GString。转义字符是美元符号，它可以转义另一个美元或正斜杠。仅当与美元和正斜杠字符的特殊使用发生冲突时才需要对这些字符进行转义。字符 $foo 通常表示 GString 占位符，因此可以通过转义美元将这四个字符输入到美元斜线字符串中，即 $$foo 。同样，如果您希望美元斜线结束分隔符出现在字符串中，则需要对其进行转义。</p>
</div>
<div class="paragraph">
<p>这里有一些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Guillaume</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> date = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">April, 1st</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">def</span> dollarSlashy = <span style="color:#F00;background-color:#FAA">$</span><span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span></span><span style="color:#F00;background-color:#FAA">
</span>    Hello <span style="color:#F00;background-color:#FAA">$</span>name,
    today we<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">re ${date}.</span></span><span style="color:#F00;background-color:#FAA">
</span>
    <span style="color:#F00;background-color:#FAA">$</span> dollar sign
    <span style="color:#F00;background-color:#FAA">$</span><span style="color:#F00;background-color:#FAA">$</span> escaped dollar sign
    <span style="color:#F00;background-color:#FAA">\</span> backslash
    <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808"> forward slash</span></span><span style="color:#F00;background-color:#FAA">
</span>    <span style="color:#F00;background-color:#FAA">$</span>/ escaped forward slash
    <span style="color:#F00;background-color:#FAA">$</span><span style="color:#F00;background-color:#FAA">$</span><span style="color:#F00;background-color:#FAA">$</span><span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808"> escaped opening dollar slashy</span></span><span style="color:#F00;background-color:#FAA">
</span>    <span style="color:#F00;background-color:#FAA">$</span>/<span style="color:#F00;background-color:#FAA">$</span><span style="color:#F00;background-color:#FAA">$</span> escaped closing dollar slashy
<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">$</span></span><span style="color:#F00;background-color:#FAA">
</span>
<span style="color:#080;font-weight:bold">assert</span> [
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">April, 1st</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">$ dollar sign</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">$ escaped dollar sign</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\\</span><span style="color:#D20"> backslash</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/ forward slash</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/ escaped forward slash</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">$/ escaped opening dollar slashy</span><span style="color:#710">'</span></span>,
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/$ escaped closing dollar slashy</span><span style="color:#710">'</span></span>
].every { dollarSlashy.contains(<span style="color:#950">it</span>) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It was created to overcome some of the limitations of the slashy string escaping rules.
Use it when its escaping rules suit your string contents (typically if it has some slashes you don&#8217;t want to escape).</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符串汇总表"><a class="link" href="#_字符串汇总表">1.4.8. 字符串汇总表</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串格式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否支持插值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否支持多行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转义字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'&#8230;&#8203;'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check empty&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check empty&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">三单引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'''&#8230;&#8203;'''</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check empty&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"&#8230;&#8203;"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check empty&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">三双引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"""&#8230;&#8203;"""</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">斜杠字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/&#8230;&#8203;/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">美元斜杠字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$/&#8230;&#8203;/$</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon">[check&#93;</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_字符"><a class="link" href="#_字符">1.4.9. 字符</a></h4>
<div class="paragraph">
<p>与 Java 不同，Groovy 没有显式的字符文字。但是，您可以通过三种不同的方式明确将 Groovy 字符串设置为实际字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">char</span> c1 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span> // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> c1 <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Character</span>

<span style="color:#080;font-weight:bold">def</span> c2 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">B</span><span style="color:#710">'</span></span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">char</span> // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> c2 <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Character</span>

<span style="color:#080;font-weight:bold">def</span> c3 = (<span style="color:#339;font-weight:bold">char</span>)<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span> // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> c3 <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Character</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>通过在声明保存字符的变量时明确指定 char 类型</p>
</li>
<li>
<p>通过使用 as 运算符进行类型强制转换</p>
</li>
<li>
<p>通过使用强制转换为字符操作</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数字"><a class="link" href="#_数字">1.5. 数字</a></h3>
<div class="paragraph">
<p>Groovy 支持不同类型的整数文字和十进制文字，由 Java Number 类型来实现。</p>
</div>
<div class="sect3">
<h4 id="_整型字面量"><a class="link" href="#_整型字面量">1.5.1. 整型字面量</a></h4>
<div class="paragraph">
<p>整型类型与 Java 中的相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>byte</code></p>
</li>
<li>
<p><code>char</code></p>
</li>
<li>
<p><code>short</code></p>
</li>
<li>
<p><code>int</code></p>
</li>
<li>
<p><code>long</code></p>
</li>
<li>
<p><code>java.math.BigInteger</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用以下声明创建这些类型的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// primitive types</span>
<span style="color:#339;font-weight:bold">byte</span>  b = <span style="color:#00D">1</span>
<span style="color:#339;font-weight:bold">char</span>  c = <span style="color:#00D">2</span>
<span style="color:#339;font-weight:bold">short</span> s = <span style="color:#00D">3</span>
<span style="color:#339;font-weight:bold">int</span>   i = <span style="color:#00D">4</span>
<span style="color:#339;font-weight:bold">long</span>  l = <span style="color:#00D">5</span>

<span style="color:#777">// infinite precision</span>
<span style="color:#0a8;font-weight:bold">BigInteger</span> bi =  <span style="color:#00D">6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您通过使用 def 关键字来使用可选类型，则整数的类型将会有所不同：类型将根据数字的范围而变化</p>
</div>
<div class="paragraph">
<p>对于正数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> a = <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> a <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>

<span style="color:#777">// Integer.MAX_VALUE</span>
<span style="color:#080;font-weight:bold">def</span> b = <span style="color:#00D">2147483647</span>
<span style="color:#080;font-weight:bold">assert</span> b <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>

<span style="color:#777">// Integer.MAX_VALUE + 1</span>
<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#00D">2147483648</span>
<span style="color:#080;font-weight:bold">assert</span> c <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Long</span>

<span style="color:#777">// Long.MAX_VALUE</span>
<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#00D">9223372036854775807</span>
<span style="color:#080;font-weight:bold">assert</span> d <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Long</span>

<span style="color:#777">// Long.MAX_VALUE + 1</span>
<span style="color:#080;font-weight:bold">def</span> e = <span style="color:#00D">9223372036854775808</span>
<span style="color:#080;font-weight:bold">assert</span> e <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">BigInteger</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于负数也是如此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> na = -<span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> na <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>

<span style="color:#777">// Integer.MIN_VALUE</span>
<span style="color:#080;font-weight:bold">def</span> nb = -<span style="color:#00D">2147483648</span>
<span style="color:#080;font-weight:bold">assert</span> nb <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>

<span style="color:#777">// Integer.MIN_VALUE - 1</span>
<span style="color:#080;font-weight:bold">def</span> nc = -<span style="color:#00D">2147483649</span>
<span style="color:#080;font-weight:bold">assert</span> nc <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Long</span>

<span style="color:#777">// Long.MIN_VALUE</span>
<span style="color:#080;font-weight:bold">def</span> nd = -<span style="color:#00D">9223372036854775808</span>
<span style="color:#080;font-weight:bold">assert</span> nd <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Long</span>

<span style="color:#777">// Long.MIN_VALUE - 1</span>
<span style="color:#080;font-weight:bold">def</span> ne = -<span style="color:#00D">9223372036854775809</span>
<span style="color:#080;font-weight:bold">assert</span> ne <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">BigInteger</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_非十进制表示法"><a class="link" href="#_非十进制表示法">1.5.1.1. 非十进制表示法</a></h5>
<div class="paragraph">
<p>数字还可以用二进制、八进制、十六进制和小数表示。</p>
</div>
<div class="sect5">
<h6 id="_二进制"><a class="link" href="#_二进制">二进制</a></h6>
<div class="paragraph">
<p>二进制数以 0b 前缀开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> xInt = <span style="color:#00D">0</span>b10101111
<span style="color:#080;font-weight:bold">assert</span> xInt == <span style="color:#00D">175</span>

<span style="color:#339;font-weight:bold">short</span> xShort = <span style="color:#00D">0</span>b11001001
<span style="color:#080;font-weight:bold">assert</span> xShort == <span style="color:#00D">201</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">short</span>

<span style="color:#339;font-weight:bold">byte</span> xByte = <span style="color:#00D">0</span>b11
<span style="color:#080;font-weight:bold">assert</span> xByte == <span style="color:#00D">3</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">byte</span>

<span style="color:#339;font-weight:bold">long</span> xLong = <span style="color:#00D">0</span>b101101101101
<span style="color:#080;font-weight:bold">assert</span> xLong == <span style="color:#00D">2925l</span>

<span style="color:#0a8;font-weight:bold">BigInteger</span> xBigInteger = <span style="color:#00D">0</span>b111100100001
<span style="color:#080;font-weight:bold">assert</span> xBigInteger == <span style="color:#00D">3873g</span>

<span style="color:#339;font-weight:bold">int</span> xNegativeInt = -<span style="color:#00D">0</span>b10101111
<span style="color:#080;font-weight:bold">assert</span> xNegativeInt == -<span style="color:#00D">175</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_八进制"><a class="link" href="#_八进制">八进制</a></h6>
<div class="paragraph">
<p>八进制数以 0 后跟八进制数字的格式指定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> xInt = <span style="color:#40E">077</span>
<span style="color:#080;font-weight:bold">assert</span> xInt == <span style="color:#00D">63</span>

<span style="color:#339;font-weight:bold">short</span> xShort = <span style="color:#40E">011</span>
<span style="color:#080;font-weight:bold">assert</span> xShort == <span style="color:#00D">9</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">short</span>

<span style="color:#339;font-weight:bold">byte</span> xByte = <span style="color:#40E">032</span>
<span style="color:#080;font-weight:bold">assert</span> xByte == <span style="color:#00D">26</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">byte</span>

<span style="color:#339;font-weight:bold">long</span> xLong = <span style="color:#40E">0246</span>
<span style="color:#080;font-weight:bold">assert</span> xLong == <span style="color:#00D">166l</span>

<span style="color:#0a8;font-weight:bold">BigInteger</span> xBigInteger = <span style="color:#40E">01111</span>
<span style="color:#080;font-weight:bold">assert</span> xBigInteger == <span style="color:#00D">585g</span>

<span style="color:#339;font-weight:bold">int</span> xNegativeInt = -<span style="color:#40E">077</span>
<span style="color:#080;font-weight:bold">assert</span> xNegativeInt == -<span style="color:#00D">63</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_十六进制"><a class="link" href="#_十六进制">十六进制</a></h6>
<div class="paragraph">
<p>十六进制数字以 0x 后跟十六进制数字的格式指定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> xInt = <span style="color:#02b">0x77</span>
<span style="color:#080;font-weight:bold">assert</span> xInt == <span style="color:#00D">119</span>

<span style="color:#339;font-weight:bold">short</span> xShort = <span style="color:#02b">0xaa</span>
<span style="color:#080;font-weight:bold">assert</span> xShort == <span style="color:#00D">170</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">short</span>

<span style="color:#339;font-weight:bold">byte</span> xByte = <span style="color:#02b">0x3a</span>
<span style="color:#080;font-weight:bold">assert</span> xByte == <span style="color:#00D">58</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">byte</span>

<span style="color:#339;font-weight:bold">long</span> xLong = <span style="color:#02b">0xffff</span>
<span style="color:#080;font-weight:bold">assert</span> xLong == <span style="color:#00D">65535l</span>

<span style="color:#0a8;font-weight:bold">BigInteger</span> xBigInteger = <span style="color:#02b">0xaaaa</span>
<span style="color:#080;font-weight:bold">assert</span> xBigInteger == <span style="color:#00D">43690g</span>

<span style="color:#0a8;font-weight:bold">Double</span> xDouble = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Double</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">0x1.0p0</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> xDouble == <span style="color:#60E">1.0d</span>

<span style="color:#339;font-weight:bold">int</span> xNegativeInt = -<span style="color:#02b">0x77</span>
<span style="color:#080;font-weight:bold">assert</span> xNegativeInt == -<span style="color:#00D">119</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_小数"><a class="link" href="#_小数">1.5.2. 小数</a></h4>
<div class="paragraph">
<p>小数类型与 Java 中的相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>float</code></p>
</li>
<li>
<p><code>double</code></p>
</li>
<li>
<p><code>java.math.BigDecimal</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用以下声明创建这些类型的小数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// primitive types</span>
<span style="color:#339;font-weight:bold">float</span>  f = <span style="color:#60E">1.234</span>
<span style="color:#339;font-weight:bold">double</span> d = <span style="color:#60E">2.345</span>

<span style="color:#777">// infinite precision</span>
<span style="color:#0a8;font-weight:bold">BigDecimal</span> bd =  <span style="color:#60E">3.456</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>小数可以使用指数，其中 e 或 E 指数字母，后跟可选符号，以及代表指数的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">1e3</span>  ==  <span style="color:#00D">1</span>_000<span style="color:#60E">.0</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">2E4</span>  == <span style="color:#00D">20</span>_000<span style="color:#60E">.0</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">3e+1</span> ==     <span style="color:#60E">30.0</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">4E-2</span> ==      <span style="color:#60E">0.04</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">5e-1</span> ==      <span style="color:#60E">0.5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了方便精确的十进制数计算，Groovy 选择 <code>java.math.BigDecimal</code> 作为其十进制数类型。此外， <code>float</code> 和 <code>double</code> 均受支持，但需要显式类型声明、类型强制或后缀。即使 BigDecimal 是十进制数字的默认值，在采用 float 或 double 作为参数类型的方法或闭包中也会接受此类文字。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
小数不能使用二进制、八进制或十六进制表示法来表示。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_数字中的下划线"><a class="link" href="#_数字中的下划线">1.5.3. 数字中的下划线</a></h4>
<div class="paragraph">
<p>当编写长文字数字时，眼睛很难弄清楚某些数字是如何组合在一起的，例如数千个数字、单词等。通过允许您在数字文字中放置下划线，可以更容易地发现这些组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">long</span> creditCardNumber = <span style="color:#00D">1234</span>_5678_9012_3456L
<span style="color:#339;font-weight:bold">long</span> socialSecurityNumbers = <span style="color:#00D">999</span>_99_9999L
<span style="color:#339;font-weight:bold">double</span> monetaryAmount = <span style="color:#00D">12</span>_345_132<span style="color:#60E">.12</span>
<span style="color:#339;font-weight:bold">long</span> hexBytes = <span style="color:#02b">0xFF</span>_EC_DE_5E
<span style="color:#339;font-weight:bold">long</span> hexWords = <span style="color:#02b">0xFFEC</span>_DE5E
<span style="color:#339;font-weight:bold">long</span> maxLong = <span style="color:#02b">0x7fff</span>_ffff_ffff_ffffL
<span style="color:#339;font-weight:bold">long</span> alsoMaxLong = <span style="color:#00D">9</span>_223_372_036_854_775_807L
<span style="color:#339;font-weight:bold">long</span> bytes = <span style="color:#00D">0</span>b11010010_01101001_10010100_10010010</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数字类型后缀"><a class="link" href="#_数字类型后缀">1.5.4. 数字类型后缀</a></h4>
<div class="paragraph">
<p>我们可以通过给出后缀（见下表）（大写或小写）来强制数字（包括二进制、八进制和十六进制）具有特定类型。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Suffix</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code> or <code>g</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>L</code> or <code>l</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>I</code> or <code>i</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code> or <code>g</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>D</code> or <code>d</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>F</code> or <code>f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">42</span>I == <span style="color:#0a8;font-weight:bold">Integer</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">42</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">42</span>i == <span style="color:#0a8;font-weight:bold">Integer</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">42</span><span style="color:#710">'</span></span>) <span style="color:#777">// lowercase i more readable</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">123L</span> == <span style="color:#0a8;font-weight:bold">Long</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">123</span><span style="color:#710">&quot;</span></span>) <span style="color:#777">// uppercase L more readable</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">2147483648</span> == <span style="color:#0a8;font-weight:bold">Long</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">2147483648</span><span style="color:#710">'</span></span>) <span style="color:#777">// Long type used, value too large for an Integer</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">456G</span> == <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">BigInteger</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">456</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">456g</span> == <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">BigInteger</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">456</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">123.45</span> == <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">BigDecimal</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">123.45</span><span style="color:#710">'</span></span>) <span style="color:#777">// default BigDecimal type used</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">.321</span> == <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">BigDecimal</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">.321</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">1.200065D</span> == <span style="color:#0a8;font-weight:bold">Double</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1.200065</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">1.234F</span> == <span style="color:#0a8;font-weight:bold">Float</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1.234</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">1.23E23D</span> == <span style="color:#0a8;font-weight:bold">Double</span>.valueOf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1.23E23</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">0</span>b1111L.class == <span style="color:#0a8;font-weight:bold">Long</span> <span style="color:#777">// binary</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#02b">0xFF</span>i.class == <span style="color:#0a8;font-weight:bold">Integer</span> <span style="color:#777">// hexadecimal</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#40E">034</span>G.class == <span style="color:#0a8;font-weight:bold">BigInteger</span> <span style="color:#777">// octal</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数学运算"><a class="link" href="#_数学运算">1.5.5. 数学运算</a></h4>
<div class="paragraph">
<p>尽管<a href="core-operators.html#groovy-operators">操作符</a>在其他地方有更详细的介绍，但讨论数学运算的行为及其结果类型很重要。</p>
</div>
<div class="paragraph">
<p>除了除法和幂运算（如下所述），</p>
</div>
<div class="ulist">
<ul>
<li>
<p>byte 、 char 、 short 和 int 之间的二元运算结果为 int</p>
</li>
<li>
<p>涉及 long 与 byte 、 char 、 short 和 int 的二元运算结果为 long</p>
</li>
<li>
<p>涉及 BigInteger 和任何其他整数类型的二元运算结果为 BigInteger</p>
</li>
<li>
<p>涉及 BigDecimal 与 byte 、 char 、 short 、 int 和 BigInteger 的二元运算结果为 BigDecimal</p>
</li>
<li>
<p>float 、 double 和 BigDecimal 之间的二元运算结果为 double</p>
</li>
<li>
<p>两个 BigDecimal 之间的二元运算结果为 BigDecimal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下表总结了这些规则：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">byte</th>
<th class="tableblock halign-left valign-top">char</th>
<th class="tableblock halign-left valign-top">short</th>
<th class="tableblock halign-left valign-top">int</th>
<th class="tableblock halign-left valign-top">long</th>
<th class="tableblock halign-left valign-top">BigInteger</th>
<th class="tableblock halign-left valign-top">float</th>
<th class="tableblock halign-left valign-top">double</th>
<th class="tableblock halign-left valign-top">BigDecimal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>byte</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>char</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>short</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>long</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BigInteger</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>float</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>double</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BigDecimal</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
由于 Groovy 的运算符重载，通常的算术运算符可以与 BigInteger 和 BigDecimal 一起使用，这与在 Java 中您必须使用显式方法来操作这些数字不同。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="integer_division"><a class="link" href="#integer_division">1.5.5.1. 除法运算符</a></h5>
<div class="paragraph">
<p>如果任一操作数是 float 或 double （以及用于除法和赋值的 /= ）会生成 double 结果 ，否则返回 BigDecimal 结果（当两个操作数都是整数类型 short 、 char 、 byte 的任意组合时、 int 、 long 、 BigInteger 或 BigDecimal ）。</p>
</div>
<div class="paragraph">
<p>如果除法是精确的（即产生可以在相同精度和小数位数的范围内表示的结果），则使用 divide() 方法执行 BigDecimal 除法，或者使用 MathContext <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()">精度</a>为两个操作数精度的最大值加上额外精度 10，http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()[小数位数]为最大值 10 和操作数小数位数的最大值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
对于 Java 中的整数除法，您应该使用 intdiv() 方法，因为 Groovy 没有提供专用的整数除法运算符符号。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="power_operator"><a class="link" href="#power_operator">1.5.5.2. 幂运算</a></h5>
<div class="paragraph">
<p>幂运算由 ** 运算符表示，有两个参数：底数和指数。幂运算的结果取决于其操作数和运算结果（特别是如果结果可以表示为整数值）。</p>
</div>
<div class="paragraph">
<p>Groovy 的幂运算使用以下规则来确定结果类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果指数是小数</p>
<div class="ulist">
<ul>
<li>
<p>如果结果可以表示为 Integer ，则返回 Integer</p>
</li>
<li>
<p>否则，如果结果可以表示为 Long ，则返回 Long</p>
</li>
<li>
<p>否则返回 Double</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果指数是整数值</p>
<div class="ulist">
<ul>
<li>
<p>如果指数严格为负数，则返回 Integer 、 Long 或 Double （如果结果值符合该类型）</p>
</li>
<li>
<p>如果指数为正或零</p>
<div class="ulist">
<ul>
<li>
<p>如果基数是 BigDecimal ，则返回 BigDecimal 结果值</p>
</li>
<li>
<p>如果基数是 BigInteger ，则返回 BigInteger 结果值</p>
</li>
<li>
<p>如果基数是 Integer ，则如果结果值适合则返回 Integer ，否则返回 BigInteger</p>
</li>
<li>
<p>如果基数是 Long ，如果结果值适合则返回 Long ，否则返回 BigInteger</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以用几个例子来说明这些规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// base and exponent are ints and the result can be represented by an Integer</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#00D">2</span>    **   <span style="color:#00D">3</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>    <span style="color:#777">//  8</span>
<span style="color:#080;font-weight:bold">assert</span>   <span style="color:#00D">10</span>    **   <span style="color:#00D">9</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>    <span style="color:#777">//  1_000_000_000</span>

<span style="color:#777">// the base is a long, so fit the result in a Long</span>
<span style="color:#777">// (although it could have fit in an Integer)</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#00D">5L</span>   **   <span style="color:#00D">2</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Long</span>       <span style="color:#777">//  25</span>

<span style="color:#777">// the result can't be represented as an Integer or Long, so return a BigInteger</span>
<span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">100</span>    **  <span style="color:#00D">10</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">BigInteger</span> <span style="color:#777">//  10e20</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">1234</span>    ** <span style="color:#00D">123</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">BigInteger</span> <span style="color:#777">//  170515806212727042875...</span>

<span style="color:#777">// the base is a BigDecimal and the exponent a negative int</span>
<span style="color:#777">// but the result can be represented as an Integer</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#60E">0.5</span>  **  -<span style="color:#00D">2</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>    <span style="color:#777">//  4</span>

<span style="color:#777">// the base is an int, and the exponent a negative float</span>
<span style="color:#777">// but again, the result can be represented as an Integer</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#00D">1</span>    **  -<span style="color:#60E">0.3f</span> <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span>    <span style="color:#777">//  1</span>

<span style="color:#777">// the base is an int, and the exponent a negative int</span>
<span style="color:#777">// but the result will be calculated as a Double</span>
<span style="color:#777">// (both base and exponent are actually converted to doubles)</span>
<span style="color:#080;font-weight:bold">assert</span>   <span style="color:#00D">10</span>    **  -<span style="color:#00D">1</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Double</span>     <span style="color:#777">//  0.1</span>

<span style="color:#777">// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#60E">1.2</span>  **  <span style="color:#00D">10</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">BigDecimal</span> <span style="color:#777">//  6.1917364224</span>

<span style="color:#777">// the base is a float or double, and the exponent is an int</span>
<span style="color:#777">// but the result can only be represented as a Double value</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#60E">3.4f</span> **   <span style="color:#00D">5</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Double</span>     <span style="color:#777">//  454.35430372146965</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#60E">5.6d</span> **   <span style="color:#00D">2</span>    <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Double</span>     <span style="color:#777">//  31.359999999999996</span>

<span style="color:#777">// the exponent is a decimal value</span>
<span style="color:#777">// and the result can only be represented as a Double value</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#60E">7.8</span>  **   <span style="color:#60E">1.9</span>  <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Double</span>     <span style="color:#777">//  49.542708423868476</span>
<span style="color:#080;font-weight:bold">assert</span>    <span style="color:#00D">2</span>    **   <span style="color:#60E">0.1f</span> <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Double</span>     <span style="color:#777">//  1.0717734636432956</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_布尔类型"><a class="link" href="#_布尔类型">1.6. 布尔类型</a></h3>
<div class="paragraph">
<p>布尔值是一种特殊的数据类型，用于表示真假： true 和 false 。将此数据类型用于表示真/假<a href="core-operators.html#Operator-Overloading">条件</a>的简单标志。</p>
</div>
<div class="paragraph">
<p>布尔值可以存储在变量中，分配到字段中，就像任何其他数据类型一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> myBooleanVariable = <span style="color:#069">true</span>
<span style="color:#339;font-weight:bold">boolean</span> untypedBooleanVar = <span style="color:#069">false</span>
booleanField = <span style="color:#069">true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>true 和 false 是仅有的两个原始布尔值。但更复杂的布尔表达式可以使用<a href="core-operators.html#logical_operators">逻辑运算符</a>来表示。</p>
</div>
<div class="paragraph">
<p>此外，Groovy 有特殊规则（通常称为 Groovy Truth）用于将非布尔对象强制为布尔值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_lists"><a class="link" href="#_lists">1.7. Lists</a></h3>
<div class="paragraph">
<p>Groovy 使用逗号分隔的值列表（用方括号括起来）来表示列表。 Groovy 列表是普通的 JDK java.util.List ，因为 Groovy 没有定义自己的集合类。定义列表文字时使用的具体列表实现默认为 java.util.ArrayList ，除非您决定另外指定，我们稍后会看到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> numbers = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>]         // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> numbers <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">List</span>  // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> numbers.size() == <span style="color:#00D">3</span>      // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们定义一个由逗号分隔并用方括号括起来的列表数字，并将该列表分配给一个变量</p>
</li>
<li>
<p>该列表是 Java 的 java.util.List 接口的实例</p>
</li>
<li>
<p>可以使用 size() 方法查询列表的大小，并显示我们的列表包含 3 个元素</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了元素类型相同的列表，但您也可以创建包含异构类型的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> heterogeneous = [<span style="color:#00D">1</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>, <span style="color:#069">true</span>]  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们这里的列表包含一个数字、一个字符串和一个布尔值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们提到，<strong>默认情况下，列表文字实际上是 <code>java.util.ArrayList</code> 的实例，但由于使用 <code>as</code> 运算符的类型强制，可以为列表使用不同的支持类型，或者使用变量的显式类型声明：</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> arrayList = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>]
<span style="color:#080;font-weight:bold">assert</span> arrayList <span style="color:#080;font-weight:bold">instanceof</span> java.util.ArrayList

<span style="color:#080;font-weight:bold">def</span> linkedList = [<span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">LinkedList</span>    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> linkedList <span style="color:#080;font-weight:bold">instanceof</span> java.util.LinkedList

<span style="color:#0a8;font-weight:bold">LinkedList</span> otherLinked = [<span style="color:#00D">3</span>, <span style="color:#00D">4</span>, <span style="color:#00D">5</span>]          // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> otherLinked <span style="color:#080;font-weight:bold">instanceof</span> java.util.LinkedList</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们使用带有 as 运算符的强制来显式请求 java.util.LinkedList 实现</p>
</li>
<li>
<p>保存列表文字的变量是 java.util.LinkedList 类型</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可以使用 [] 下标运算符（用于读取和设置值）使用正索引或负索引访问列表的元素，以访问列表末尾的元素以及范围，并使用 &lt;&lt; leftShift 运算符将元素追加到列表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> letters = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>]

<span style="color:#080;font-weight:bold">assert</span> letters[<span style="color:#00D">0</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>     // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> letters[<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">assert</span> letters[-<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>    // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> letters[-<span style="color:#00D">2</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>

letters[<span style="color:#00D">2</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>             // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> letters[<span style="color:#00D">2</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>

letters &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">e</span><span style="color:#710">'</span></span>               // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> letters[ <span style="color:#00D">4</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">e</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> letters[-<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">e</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">assert</span> letters[<span style="color:#00D">1</span>, <span style="color:#00D">3</span>] == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>]         // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> letters[<span style="color:#00D">2</span>..<span style="color:#00D">4</span>] == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">e</span><span style="color:#710">'</span></span>]    // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>访问列表的第一个元素（从零开始计数）</p>
</li>
<li>
<p>使用负索引访问列表的最后一个元素：-1 是列表末尾的第一个元素</p>
</li>
<li>
<p>使用赋值为列表的第三个元素设置新值</p>
</li>
<li>
<p>使用 &lt;&lt; leftShift 运算符将元素追加到列表末尾</p>
</li>
<li>
<p>一次访问两个元素，返回包含这两个元素的新列表</p>
</li>
<li>
<p>使用范围访问列表中从开始到结束元素位置的一系列值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>由于列表本质上可以是异构(heterogeneous )的，因此列表还可以包含其他列表来创建多维列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> multi = [[<span style="color:#00D">0</span>, <span style="color:#00D">1</span>], [<span style="color:#00D">2</span>, <span style="color:#00D">3</span>]]     // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> multi[<span style="color:#00D">1</span>][<span style="color:#00D">0</span>] == <span style="color:#00D">2</span>          // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义数字列表</p>
</li>
<li>
<p>访问最顶层列表的第二个元素和内部列表的第一个元素</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_arrays"><a class="link" href="#_arrays">1.8. Arrays</a></h3>
<div class="paragraph">
<p><strong>Groovy 使用了 List 的表示法来表示数组，但是要创建数组，您需要通过强制或类型声明来显式定义数组的类型。</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> arrStr = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ananas</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Banana</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Kiwi</span><span style="color:#710">'</span></span>]  // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> arrStr <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span>    // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> !(arrStr <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">List</span>)

<span style="color:#080;font-weight:bold">def</span> numArr = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span>      // <b class="conum">(3)</b>

<span style="color:#080;font-weight:bold">assert</span> numArr <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span>       // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> numArr.size() == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用显式变量类型声明定义字符串数组</p>
</li>
<li>
<p>断言我们创建了一个字符串数组</p>
</li>
<li>
<p>使用 as 运算符创建一个整数数组</p>
</li>
<li>
<p>断言我们创建了一个原始整数数组</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您还可以创建多维数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> matrix3 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>[<span style="color:#00D">3</span>][<span style="color:#00D">3</span>]         // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> matrix3.size() == <span style="color:#00D">3</span>

<span style="color:#0a8;font-weight:bold">Integer</span><span style="color:#339;font-weight:bold">[]</span><span style="color:#339;font-weight:bold">[]</span> matrix2                     // <b class="conum">(2)</b>
matrix2 = [[<span style="color:#00D">1</span>, <span style="color:#00D">2</span>], [<span style="color:#00D">3</span>, <span style="color:#00D">4</span>]]
<span style="color:#080;font-weight:bold">assert</span> matrix2 <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span><span style="color:#339;font-weight:bold">[]</span><span style="color:#339;font-weight:bold">[]</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>您可以定义新数组的边界</p>
</li>
<li>
<p>或者声明一个数组而不指定其边界</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对数组元素的访问遵循与列表相同的表示法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> names = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Cédric</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Jochen</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Paul</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> names[<span style="color:#00D">0</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Cédric</span><span style="color:#710">'</span></span>     // <b class="conum">(1)</b>

names[<span style="color:#00D">2</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Blackdrag</span><span style="color:#710">'</span></span>          // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> names[<span style="color:#00D">2</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Blackdrag</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>检索数组的第一个元素</p>
</li>
<li>
<p>将数组第三个元素的值设置为新值</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_java风格的数组初始化"><a class="link" href="#_java风格的数组初始化">1.8.1. Java风格的数组初始化</a></h4>
<div class="paragraph">
<p>Groovy 始终支持使用方括号的列表/数组定义，并避免使用 Java 风格的大括号，以免与闭包定义冲突。然而，如果大括号紧跟在数组类型声明之后，则闭包定义不会产生歧义，因此 Groovy 3 及更高版本支持 Java 数组初始化表达式。</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> primes = <span style="color:#080;font-weight:bold">new</span> <span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> {<span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">5</span>, <span style="color:#00D">7</span>, <span style="color:#00D">11</span>}
<span style="color:#080;font-weight:bold">assert</span> primes.size() == <span style="color:#00D">5</span> &amp;&amp; primes.sum() == <span style="color:#00D">28</span>
<span style="color:#080;font-weight:bold">assert</span> primes.class.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[I</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">def</span> pets = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> {<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">cat</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">dog</span><span style="color:#710">'</span></span>}
<span style="color:#080;font-weight:bold">assert</span> pets.size() == <span style="color:#00D">2</span> &amp;&amp; pets.sum() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">catdog</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> pets.class.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[Ljava.lang.String;</span><span style="color:#710">'</span></span>

<span style="color:#777">// traditional Groovy alternative still supported</span>
<span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> groovyBooks = [ <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy in Action</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Making Java Groovy</span><span style="color:#710">'</span></span> ]
<span style="color:#080;font-weight:bold">assert</span> groovyBooks.every{ <span style="color:#950">it</span>.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>) }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_maps"><a class="link" href="#_maps">1.9. Maps</a></h3>
<div class="paragraph">
<p>在其他语言中有时称为字典或关联数组，它具有映射功能。</p>
</div>
<div class="paragraph">
<p>映射将键与值关联起来，用冒号分隔键和值，每个键/值对用逗号分隔，整个键和值用方括号括起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> colors = [<span style="color:#606">red</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FF0000</span><span style="color:#710">'</span></span>, <span style="color:#606">green</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#00FF00</span><span style="color:#710">'</span></span>, <span style="color:#606">blue</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#0000FF</span><span style="color:#710">'</span></span>]   // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> colors[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">red</span><span style="color:#710">'</span></span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FF0000</span><span style="color:#710">'</span></span>    // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> colors.green  == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#00FF00</span><span style="color:#710">'</span></span>    // <b class="conum">(3)</b>

colors[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">pink</span><span style="color:#710">'</span></span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FF00FF</span><span style="color:#710">'</span></span>           // <b class="conum">(4)</b>
colors.yellow  = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FFFF00</span><span style="color:#710">'</span></span>           // <b class="conum">(5)</b>

<span style="color:#080;font-weight:bold">assert</span> colors.pink == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FF00FF</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> colors[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">yellow</span><span style="color:#710">'</span></span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">#FFFF00</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">assert</span> colors <span style="color:#080;font-weight:bold">instanceof</span> java.util.LinkedHashMap</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们定义一个字符串颜色名称的映射，与其十六进制编码的 html 颜色相关联</p>
</li>
<li>
<p>我们使用下标表示法来检查与 red 键关联的内容</p>
</li>
<li>
<p>我们还可以使用属性符号来断言绿色的十六进制表示</p>
</li>
<li>
<p>类似地，我们可以使用下标符号来添加新的键/值对</p>
</li>
<li>
<p>或者通过属性符号，添加 yellow 颜色</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
When using names for the keys, we actually define string keys in the map.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Groovy 创建的map实际上是 <code>java.util.LinkedHashMap</code> 的实例。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您尝试访问map中不存在的key：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> colors.unknown == <span style="color:#069">null</span>

<span style="color:#080;font-weight:bold">def</span> emptyMap = [:]
<span style="color:#080;font-weight:bold">assert</span> emptyMap.anyKey == <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您将获得 null 。</p>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了字符串作为key，但您也可以使用其他类型的值作为键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> numbers = [<span style="color:#00D">1</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">one</span><span style="color:#710">'</span></span>, <span style="color:#00D">2</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">two</span><span style="color:#710">'</span></span>]

<span style="color:#080;font-weight:bold">assert</span> numbers[<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">one</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用数字作为键，因为数字可以明确地被识别为数字，因此 Groovy 不会像我们前面的示例中那样创建字符串键。但考虑一下您想要传递变量代替键的情况，以使该变量的值成为键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> key = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> person = [<span style="color:#606">key</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span>]      // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> !person.containsKey(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>)   // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> person.containsKey(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">key</span><span style="color:#710">'</span></span>)     // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>与 'Guillaume' 名称关联的 key 实际上是 "key" 字符串，而不是与 key 变量关联的值</p>
</li>
<li>
<p>map不包含 'name' 键</p>
</li>
<li>
<p>相反，map包含一个 'key' 键</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
您还可以传递带引号的字符串和键：[“name”：“Guillaume”]。如果您的密钥字符串不是有效的标识符，则这是强制性的，例如，如果您想创建一个包含破折号的字符串密钥，如：[“street-name”：“Main street”]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当您需要将变量值作为映射定义中的键传递时，必须用括号将变量或表达式括起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">person = [(key): <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Guillaume</span><span style="color:#710">'</span></span>]        // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> person.containsKey(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>)    // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> !person.containsKey(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">key</span><span style="color:#710">'</span></span>)    // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这次，我们用括号将 key 变量括起来，以指示解析器我们传递变量而不是定义字符串键</p>
</li>
<li>
<p>该map确实包含 name 键</p>
</li>
<li>
<p>但map不像以前那样包含 key 键</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="groovy-operators"><a class="link" href="#groovy-operators">2. 操作符</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍 Groovy 编程语言的运算符。</p>
</div>
<div class="sect2">
<h3 id="_算术运算符"><a class="link" href="#_算术运算符">2.1. 算术运算符</a></h3>
<div class="paragraph">
<p>Groovy 支持数学和其他编程语言（如 Java）中常见的算术运算符。支持所有 Java 算术运算符。让我们在下面的示例中详细了解它们。</p>
</div>
<div class="sect3">
<h4 id="_普通算术运算符"><a class="link" href="#_普通算术运算符">2.1.1. 普通算术运算符</a></h4>
<div class="paragraph">
<p>Groovy 中提供以下二元算术运算符：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">addition</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">subtraction</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">multiplication</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">division</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use <code>intdiv()</code> for integer division, and see the section about <a href="core-syntax.html#integer_division">integer division</a> for more information on the return type of the division.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">remainder</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">power</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See the section about <a href="core-syntax.html#power_operator">the power operation</a> for more information on the return type of the operation.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下是这些运算符的一些用法示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">1</span>  + <span style="color:#00D">2</span> == <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">4</span>  - <span style="color:#00D">3</span> == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">3</span>  * <span style="color:#00D">5</span> == <span style="color:#00D">15</span>
<span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">3</span>  / <span style="color:#00D">2</span> == <span style="color:#60E">1.5</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">10</span>  % <span style="color:#00D">3</span> == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span>  <span style="color:#00D">2</span> ** <span style="color:#00D">3</span> == <span style="color:#00D">8</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_一元运算符"><a class="link" href="#_一元运算符">2.1.2. 一元运算符</a></h4>
<div class="paragraph">
<p>+ 和 - 运算符也可用作一元运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> +<span style="color:#00D">3</span> == <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">assert</span> -<span style="color:#00D">4</span> == <span style="color:#00D">0</span> - <span style="color:#00D">4</span>

<span style="color:#080;font-weight:bold">assert</span> -(-<span style="color:#00D">1</span>) == <span style="color:#00D">1</span>  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>请注意使用括号将表达式括起来，以将一元减号应用于该括起来的表达式。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>就一元算术运算符而言，可以使用 ++ （递增）和&#8201;&#8212;&#8201;（递减）运算符，无论是前缀还是后缀表示法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> a = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">def</span> b = a++ * <span style="color:#00D">3</span>             // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">3</span> &amp;&amp; b == <span style="color:#00D">6</span>

<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">def</span> d = c-- * <span style="color:#00D">2</span>             // <b class="conum">(2)</b>

<span style="color:#080;font-weight:bold">assert</span> c == <span style="color:#00D">2</span> &amp;&amp; d == <span style="color:#00D">6</span>

<span style="color:#080;font-weight:bold">def</span> e = <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">def</span> f = ++e + <span style="color:#00D">3</span>             // <b class="conum">(3)</b>

<span style="color:#080;font-weight:bold">assert</span> e == <span style="color:#00D">2</span> &amp;&amp; f == <span style="color:#00D">5</span>

<span style="color:#080;font-weight:bold">def</span> g = <span style="color:#00D">4</span>
<span style="color:#080;font-weight:bold">def</span> h = --g + <span style="color:#00D">1</span>             // <b class="conum">(4)</b>

<span style="color:#080;font-weight:bold">assert</span> g == <span style="color:#00D">3</span> &amp;&amp; h == <span style="color:#00D">4</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在表达式被计算并分配给 b 后，后缀增量将增加 a</p>
</li>
<li>
<p>在表达式被计算并分配给 d 后，后缀递减将递减 c</p>
</li>
<li>
<p>在计算表达式并将其分配给 f 之前，前缀增量将递增 e</p>
</li>
<li>
<p>在计算表达式并将其分配给 h 之前，前缀递减将递减 g</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>有关布尔值上的一元非运算符，请参阅<a href="#_条件运算符">条件运算符</a>.。</p>
</div>
</div>
<div class="sect3">
<h4 id="_赋值算术运算符"><a class="link" href="#_赋值算术运算符">2.1.3. 赋值算术运算符</a></h4>
<div class="paragraph">
<p>我们上面看到的二元算术运算符也可以采用赋值形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+=</code></p>
</li>
<li>
<p><code>-=</code></p>
</li>
<li>
<p><code>*=</code></p>
</li>
<li>
<p><code>/=</code></p>
</li>
<li>
<p><code>%=</code></p>
</li>
<li>
<p><code>**=</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们看看他们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> a = <span style="color:#00D">4</span>
a += <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">7</span>

<span style="color:#080;font-weight:bold">def</span> b = <span style="color:#00D">5</span>
b -= <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">assert</span> b == <span style="color:#00D">2</span>

<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#00D">5</span>
c *= <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">assert</span> c == <span style="color:#00D">15</span>

<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#00D">10</span>
d /= <span style="color:#00D">2</span>

<span style="color:#080;font-weight:bold">assert</span> d == <span style="color:#00D">5</span>

<span style="color:#080;font-weight:bold">def</span> e = <span style="color:#00D">10</span>
e %= <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">assert</span> e == <span style="color:#00D">1</span>

<span style="color:#080;font-weight:bold">def</span> f = <span style="color:#00D">3</span>
f **= <span style="color:#00D">2</span>

<span style="color:#080;font-weight:bold">assert</span> f == <span style="color:#00D">9</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关系运算符"><a class="link" href="#_关系运算符">2.2. 关系运算符</a></h3>
<div class="paragraph">
<p>关系运算符允许在对象之间进行比较，以了解两个对象是否相同或不同，或者一个对象是否大于、小于或等于另一个。</p>
</div>
<div class="paragraph">
<p>可以使用以下运算符：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">different</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">less than</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">less than or equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greater than</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greater than or equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>===</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">identical (Since Groovy 3.0.0)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!==</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not identical (Since Groovy 3.0.0)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下是使用这些运算符进行简单数字比较的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">1</span> + <span style="color:#00D">2</span> == <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">3</span> != <span style="color:#00D">4</span>

<span style="color:#080;font-weight:bold">assert</span> -<span style="color:#00D">2</span> &lt; <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">2</span> &lt;= <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">3</span> &lt;= <span style="color:#00D">4</span>

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">5</span> &gt; <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">5</span> &gt;= -<span style="color:#00D">2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>===</code> 和 <code>!==</code> 均受支持，分别与调用 <code>is()</code> 方法和对 <code>is()</code> 方法的非 调用相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.EqualsAndHashCode</span>

<span style="color:#007">@EqualsAndHashCode</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Creature</span> { <span style="color:#0a8;font-weight:bold">String</span> type }

<span style="color:#080;font-weight:bold">def</span> cat = <span style="color:#080;font-weight:bold">new</span> Creature(<span style="color:#606">type</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">cat</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> copyCat = cat
<span style="color:#080;font-weight:bold">def</span> lion = <span style="color:#080;font-weight:bold">new</span> Creature(<span style="color:#606">type</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">cat</span><span style="color:#710">'</span></span>)

<span style="color:#080;font-weight:bold">assert</span> cat.equals(lion) <span style="color:#777">// Java logical equality</span>
<span style="color:#080;font-weight:bold">assert</span> cat == lion      <span style="color:#777">// Groovy shorthand operator</span>

<span style="color:#080;font-weight:bold">assert</span> cat.is(copyCat)  <span style="color:#777">// Groovy identity</span>
<span style="color:#080;font-weight:bold">assert</span> cat === copyCat  <span style="color:#777">// operator shorthand</span>
<span style="color:#080;font-weight:bold">assert</span> cat !== lion     <span style="color:#777">// negated operator shorthand</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logical_operators"><a class="link" href="#logical_operators">2.3. 逻辑运算符</a></h3>
<div class="paragraph">
<p>Groovy 为布尔表达式提供了三种逻辑运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&amp;&amp;</code>: 逻辑“与”</p>
</li>
<li>
<p><code>||</code>: 逻辑“或”</p>
</li>
<li>
<p><code>!</code>: 逻辑“非”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用以下示例来说明它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> !<span style="color:#069">false</span>           // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span> &amp;&amp; <span style="color:#069">true</span>     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span> || <span style="color:#069">false</span>    // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>"not" false is true</p>
</li>
<li>
<p>true "and" true is true</p>
</li>
<li>
<p>true "or" false is true</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_优先级"><a class="link" href="#_优先级">2.3.1. 优先级</a></h4>
<div class="paragraph">
<p>逻辑“非”的优先级高于逻辑“与”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (!<span style="color:#069">false</span> &amp;&amp; <span style="color:#069">false</span>) == <span style="color:#069">false</span>   // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这里，断言为真（因为括号内的表达式为假），因为“not”的优先级高于“and”，所以它只适用于第一个“假”项；</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The logical "and" has a higher priority than the logical "or".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span> || <span style="color:#069">true</span> &amp;&amp; <span style="color:#069">false</span>        // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这里，断言为真，因为“and”的优先级高于“or”，因此“or”最后执行并返回true</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_短路"><a class="link" href="#_短路">2.3.2. 短路</a></h4>
<div class="paragraph">
<p>逻辑 || 运算符支持短路：如果左操作数为 true，则它知道结果在任何情况下都为 true，因此不会计算右操作数。仅当左操作数为 false 时，才会计算右操作数。</p>
</div>
<div class="paragraph">
<p>对于逻辑 &amp;&amp; 运算符也是如此：如果左操作数为 false，则它知道在任何情况下结果都将为 false，因此它不会计算右操作数。仅当左操作数为 true 时，才会计算右操作数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">boolean</span> checkIfCalled() {   // <b class="conum">(1)</b>
    called = <span style="color:#069">true</span>
}

called = <span style="color:#069">false</span>
<span style="color:#069">true</span> || checkIfCalled()
<span style="color:#080;font-weight:bold">assert</span> !called              // <b class="conum">(2)</b>

called = <span style="color:#069">false</span>
<span style="color:#069">false</span> || checkIfCalled()
<span style="color:#080;font-weight:bold">assert</span> called               // <b class="conum">(3)</b>

called = <span style="color:#069">false</span>
<span style="color:#069">false</span> &amp;&amp; checkIfCalled()
<span style="color:#080;font-weight:bold">assert</span> !called              // <b class="conum">(4)</b>

called = <span style="color:#069">false</span>
<span style="color:#069">true</span> &amp;&amp; checkIfCalled()
<span style="color:#080;font-weight:bold">assert</span> called               // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们创建一个函数，每当调用时将 called 标志设置为 true</p>
</li>
<li>
<p>在第一种情况下，在重置被调用标志后，我们确认如果 || 的左操作数为 true，则不会调用该函数，因为 || 会短路对右操作数</p>
</li>
<li>
<p>在第二种情况下，左操作数为 false，因此调用该函数，正如我们的标志现在为 true 的事实所示</p>
</li>
<li>
<p>同样，对于 &amp;&amp; ，我们确认该函数不是使用错误的左操作数调用的</p>
</li>
<li>
<p>但该函数是用真正的左操作数调用的</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_按位和移位运算符"><a class="link" href="#_按位和移位运算符">2.4. 按位和移位运算符</a></h3>
<div class="sect3">
<h4 id="_按位运算符"><a class="link" href="#_按位运算符">2.4.1. 按位运算符</a></h4>
<div class="paragraph">
<p>Groovy 提供四种按位运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&amp;</code>: 按位“与”</p>
</li>
<li>
<p><code>|</code>: 按位“或”</p>
</li>
<li>
<p><code>^</code>: 按位“异或”</p>
</li>
<li>
<p><code>~</code>: 按位取反</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>位运算符可以应用于 byte 、 short 、 int 、 long 或 BigInteger .如果参数之一是 BigInteger ，则结果将为 BigInteger 类型；否则，如果参数之一是 long ，结果将为 long 类型；否则，结果将为 int 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> a = <span style="color:#00D">0</span>b00101010
<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">42</span>
<span style="color:#339;font-weight:bold">int</span> b = <span style="color:#00D">0</span>b00001000
<span style="color:#080;font-weight:bold">assert</span> b == <span style="color:#00D">8</span>
<span style="color:#080;font-weight:bold">assert</span> (a &amp; a) == a                     // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> (a &amp; b) == b                     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> (a | a) == a                     // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> (a | b) == a                     // <b class="conum">(4)</b>

<span style="color:#339;font-weight:bold">int</span> mask = <span style="color:#00D">0</span>b11111111                   // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> ((a ^ a) &amp; mask) == <span style="color:#00D">0</span>b00000000   // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> ((a ^ b) &amp; mask) == <span style="color:#00D">0</span>b00100010   // <b class="conum">(7)</b>
<span style="color:#080;font-weight:bold">assert</span> ((~a) &amp; mask)    == <span style="color:#00D">0</span>b11010101   // <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>按位和</p>
</li>
<li>
<p>bitwise and returns common bits</p>
</li>
<li>
<p>bitwise or</p>
</li>
<li>
<p>bitwise or returns all '1' bits</p>
</li>
<li>
<p>setting a mask to check only the last 8 bits</p>
</li>
<li>
<p>bitwise exclusive or on self returns 0</p>
</li>
<li>
<p>bitwise exclusive or</p>
</li>
<li>
<p>bitwise negation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值得注意的是，基本类型的内部表示遵循 <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html">Java Language Specification</a>。特别是，原始类型是有符号的，这意味着对于按位求反，最好使用掩码来仅检索必要的位。
在 Groovy 中，按位运算符是<a href="#Operator-Overloading">可重载</a>的，这意味着您可以为任何类型的对象定义这些运算符的行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="_移位运算符"><a class="link" href="#_移位运算符">2.4.2. 移位运算符</a></h4>
<div class="paragraph">
<p>Groovy 提供了三种位移运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;&lt;</code>: left shift</p>
</li>
<li>
<p><code>&gt;&gt;</code>: right shift</p>
</li>
<li>
<p><code>&gt;&gt;&gt;</code>: 无符号右移</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有三个运算符都适用于左侧参数类型为 byte 、 short 、 int 或 long 的情况。前两个运算符也可以应用于左侧参数类型为 BigInteger 的情况。如果左侧参数是 BigInteger ，则结果将为 BigInteger 类型；否则，如果左侧参数是 long ，则结果将为 long 类型；否则，结果将为 int 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">12</span>.equals(<span style="color:#00D">3</span> &lt;&lt; <span style="color:#00D">2</span>)           // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">24L</span>.equals(<span style="color:#00D">3L</span> &lt;&lt; <span style="color:#00D">3</span>)         // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">48G</span>.equals(<span style="color:#00D">3G</span> &lt;&lt; <span style="color:#00D">4</span>)         // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">4095</span> == -<span style="color:#00D">200</span> &gt;&gt;&gt; <span style="color:#00D">20</span>
<span style="color:#080;font-weight:bold">assert</span> -<span style="color:#00D">1</span> == -<span style="color:#00D">200</span> &gt;&gt; <span style="color:#00D">20</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">2G</span> == <span style="color:#00D">5G</span> &gt;&gt; <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> -<span style="color:#00D">3G</span> == -<span style="color:#00D">5G</span> &gt;&gt; <span style="color:#00D">1</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 equals 方法代替 == 来确认结果类型</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在 Groovy 中，位移运算符是<a href="#Operator-Overloading">可重载</a>可重载的，这意味着您可以为任何类型的对象定义这些运算符的行为。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_条件运算符"><a class="link" href="#_条件运算符">2.5. 条件运算符</a></h3>
<div class="sect3">
<h4 id="_非_运算符"><a class="link" href="#_非_运算符">2.5.1. 非 运算符</a></h4>
<div class="paragraph">
<p>“not”运算符用感叹号 ( ! ) 表示，并反转布尔表达式的结果。特别是，可以将 not 运算符与 Groovy <a href="core-semantics.html#the-groovy-truth">Groovy 真假</a>结合起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (!<span style="color:#069">true</span>)    == <span style="color:#069">false</span>                      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> (!<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>)   == <span style="color:#069">false</span>                      // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> (!<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>)      == <span style="color:#069">true</span>                       // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>true 的否定是 false</p>
</li>
<li>
<p>'foo' 是一个非空字符串，计算结果为 true ，因此求反返回 false</p>
</li>
<li>
<p>'' 是一个空字符串，计算结果为 false ，因此求反返回 true</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_三元运算符"><a class="link" href="#_三元运算符">2.5.2. 三元运算符</a></h4>
<div class="paragraph">
<p>三元运算符是一个快捷表达式，相当于为变量分配某些值的 if/else 分支。</p>
</div>
<div class="paragraph">
<p>代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">if</span> (string!=<span style="color:#069">null</span> &amp;&amp; string.length()&gt;<span style="color:#00D">0</span>) {
    result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Found</span><span style="color:#710">'</span></span>
} <span style="color:#080;font-weight:bold">else</span> {
    result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Not found</span><span style="color:#710">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">result = (string!=<span style="color:#069">null</span> &amp;&amp; string.length()&gt;<span style="color:#00D">0</span>) ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Found</span><span style="color:#710">'</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Not found</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>三元运算符也与 Groovy <a href="core-semantics.html#the-groovy-truth">Groovy 真假</a>兼容，因此您可以使其变得更加简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">result = string ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Found</span><span style="color:#710">'</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Not found</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_elvis_操作符"><a class="link" href="#_elvis_操作符">2.5.3. Elvis 操作符</a></h4>
<div class="paragraph">
<p>“Elvis 运算符”是三元运算符的缩写。一个方便的例子是，如果表达式解析为 false （如 <a href="core-semantics.html#the-groovy-truth">Groovy 真假</a> 中所示），则返回“合理的默认”值。一个简单的例子可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">displayName = user.name ? user.name : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Anonymous</span><span style="color:#710">'</span></span>   // <b class="conum">(1)</b>
displayName = user.name ?: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Anonymous</span><span style="color:#710">'</span></span>              // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用三元运算符，您必须重复要分配的值</p>
</li>
<li>
<p>使用 Elvis 运算符，如果不是 false，则使用经过测试的值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用 Elvis 运算符可以减少代码的冗长性，并降低重构时出错的风险，因为无需复制在条件和正返回值中测试的表达式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_elvis_赋值运算符"><a class="link" href="#_elvis_赋值运算符">2.5.4. Elvis 赋值运算符</a></h4>
<div class="paragraph">
<p>Groovy 3.0.0引入了Elvis运算符，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.ToString</span>

<span style="color:#007">@ToString</span>(includePackage = <span style="color:#069">false</span>)
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Element</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> atomicNumber
}

<span style="color:#080;font-weight:bold">def</span> he = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Element</span>(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Helium</span><span style="color:#710">'</span></span>)
he.with {
    name = name ?: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hydrogen</span><span style="color:#710">'</span></span>   <span style="color:#777">// existing Elvis operator</span>
    atomicNumber ?= <span style="color:#00D">2</span>           <span style="color:#777">// new Elvis assignment shorthand</span>
}
<span style="color:#080;font-weight:bold">assert</span> he.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Element(Helium, 2)</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_对象运算符"><a class="link" href="#_对象运算符">2.6. 对象运算符</a></h3>
<div class="sect3">
<h4 id="_安全导航运算符"><a class="link" href="#_安全导航运算符">2.6.1. 安全导航运算符</a></h4>
<div class="paragraph">
<p>安全导航运算符用于避免 NullPointerException 。通常，当您拥有对对象的引用时，您可能需要在访问该对象的方法或属性之前验证它不是 null 。为了避免这种情况，安全导航运算符将简单地返回 null 而不是抛出异常，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> person = Person.find { <span style="color:#950">it</span>.id == <span style="color:#00D">123</span> }    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> name = person?.name                      // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> name == <span style="color:#069">null</span>                          // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>find 将返回一个 null 实例</p>
</li>
<li>
<p>使用空安全运算符可防止 NullPointerException</p>
</li>
<li>
<p>结果是 null</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_字段直接访问操作符"><a class="link" href="#_字段直接访问操作符">2.6.2. 字段直接访问操作符</a></h4>
<div class="paragraph">
<p>通常在 Groovy 中，当您编写如下代码时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">User</span> {
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> name                 // <b class="conum">(1)</b>
    User(<span style="color:#0a8;font-weight:bold">String</span> name) { <span style="color:#950">this</span>.name = name}
    <span style="color:#0a8;font-weight:bold">String</span> getName() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Name: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span> }       // <b class="conum">(2)</b>
}
<span style="color:#080;font-weight:bold">def</span> user = <span style="color:#080;font-weight:bold">new</span> User(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> user.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Bob</span><span style="color:#710">'</span></span>              // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>公共字段 name</p>
</li>
<li>
<p>name 的 getter，返回自定义字符串</p>
</li>
<li>
<p>调用 getter</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>user.name 调用会触发对同名属性的调用，也就是说，这里是对 name 的 getter 的调用。如果您想直接使用字段而不是调用 getter，可以使用直接字段访问运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> user.@name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                   // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 <code>.@</code> 强制使用字段而不是 getter</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="method-pointer-operator"><a class="link" href="#method-pointer-operator">2.6.3. 方法指针运算符</a></h4>
<div class="paragraph">
<p>方法指针运算符 ( <code>.&amp;</code> ) 可用于在变量中存储对方法的引用，以便稍后调用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> str = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">example of method reference</span><span style="color:#710">'</span></span>            // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> fun = str.&amp;toUpperCase                         // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> upper = fun()                                  // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> upper == str.toUpperCase()                  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>str 变量包含 String</p>
</li>
<li>
<p>我们将对 str 实例上的 toUpperCase 方法的引用存储在名为 fun 的变量中</p>
</li>
<li>
<p>fun 可以像常规方法一样调用</p>
</li>
<li>
<p>我们可以检查结果是否与我们直接在 str 上调用它的结果相同</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用方法指针有很多优点。首先，这种方法指针的类型是 groovy.lang.Closure ，因此它可以在任何需要使用闭包的地方使用。特别是，适合将现有方法转换为策略模式的需要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">transform</span>(<span style="color:#0a8;font-weight:bold">List</span> elements, Closure action) {                    // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">def</span> result = <span style="color:#339;font-weight:bold">[]</span>
    elements.each {
        result &lt;&lt; action(<span style="color:#950">it</span>)
    }
    result
}
<span style="color:#0a8;font-weight:bold">String</span> describe(Person p) {                                       // <b class="conum">(2)</b>
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>p</span><span style="color:#D20">.name is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>p</span><span style="color:#D20">.age</span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">def</span> action = <span style="color:#950">this</span>.&amp;describe                                       // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> list = [
    <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>,   <span style="color:#606">age</span>: <span style="color:#00D">42</span>),
    <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Julia</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">35</span>)]                           // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> transform(list, action) == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob is 42</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Julia is 35</span><span style="color:#710">'</span></span>]    // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>transform 方法获取列表中的每个元素并调用它们的 action 闭包，返回一个新列表</p>
</li>
<li>
<p>我们定义一个函数，它接受 Person 并返回 String</p>
</li>
<li>
<p>我们在该函数上创建一个方法指针</p>
</li>
<li>
<p>我们创建要收集描述符的元素列表</p>
</li>
<li>
<p>方法指针可以用在需要 Closure 的地方</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>方法指针由接收者和方法名称绑定。参数在运行时解析，这意味着 <strong>如果有多个同名的方法，语法没有不同，只会在运行时解析要调用的适当方法</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">doSomething</span>(<span style="color:#0a8;font-weight:bold">String</span> str) { str.toUpperCase() }    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">doSomething</span>(<span style="color:#0a8;font-weight:bold">Integer</span> x) { <span style="color:#00D">2</span>*x }                   // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> reference = <span style="color:#950">this</span>.&amp;doSomething                    // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> reference(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">FOO</span><span style="color:#710">'</span></span>                     // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> reference(<span style="color:#00D">123</span>)   == <span style="color:#00D">246</span>                       // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义一个重载的 doSomething 方法，接受 String 作为参数</p>
</li>
<li>
<p>定义一个重载的 doSomething 方法，接受 Integer 作为参数</p>
</li>
<li>
<p>在 doSomething 上创建单个方法指针，而不指定参数类型</p>
</li>
<li>
<p>使用带有 String 的方法指针调用 doSomething 的 String 版本</p>
</li>
<li>
<p>使用带有 Integer 的方法指针调用 doSomething 的 Integer 版本</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了符合 Java 8 方法引用期望，在 Groovy 3 及更高版本中，您可以使用 new 作为方法名称来获取指向构造函数的方法指针：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> foo  = <span style="color:#0a8;font-weight:bold">BigInteger</span>.&amp;<span style="color:#080;font-weight:bold">new</span>
<span style="color:#080;font-weight:bold">def</span> fortyTwo = foo(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">42</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> fortyTwo == <span style="color:#00D">42G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样在 Groovy 3 及更高版本中，您可以获得指向类的实例方法的方法指针。该方法指针采用一个附加参数作为接收者实例来调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> instanceMethod = <span style="color:#0a8;font-weight:bold">String</span>.&amp;toUpperCase
<span style="color:#080;font-weight:bold">assert</span> instanceMethod(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">FOO</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了向后兼容，在这种情况下，任何恰好具有正确调用参数的静态方法都将优先于实例方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="method-reference-operator"><a class="link" href="#method-reference-operator">2.6.4. 方法引用运算符</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Groovy 3+ 中的 Parrot 解析器支持 Java 8+ 方法引用运算符。方法引用运算符 ( </dt>
<dd>
<p>) 可用于在需要功能接口的上下文中引用方法或构造函数。这与 Groovy 的方法指针运算符提供的功能有些重叠。事实上，对于动态 Groovy，方法引用运算符只是方法指针运算符的别名。对于静态 Groovy，该运算符生成的字节码与 Java 为相同上下文生成的字节码类似。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下脚本中显示了一些突出显示各种支持的方法参考案例的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.CompileStatic</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">static</span> <span style="color:#B44;font-weight:bold">java.util.stream.Collectors.toList</span>

<span style="color:#007">@CompileStatic</span>
<span style="color:#339;font-weight:bold">void</span> methodRefs() {
    <span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">6G</span> == [<span style="color:#00D">1G</span>, <span style="color:#00D">2G</span>, <span style="color:#00D">3G</span>].stream().reduce(<span style="color:#00D">0G</span>, <span style="color:#0a8;font-weight:bold">BigInteger</span>::add)                           // <b class="conum">(1)</b>

    <span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">4G</span>, <span style="color:#00D">5G</span>, <span style="color:#00D">6G</span>] == [<span style="color:#00D">1G</span>, <span style="color:#00D">2G</span>, <span style="color:#00D">3G</span>].stream().map(<span style="color:#00D">3G</span>::add).collect(toList())              // <b class="conum">(2)</b>

    <span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">1G</span>, <span style="color:#00D">2G</span>, <span style="color:#00D">3G</span>] == [<span style="color:#00D">1L</span>, <span style="color:#00D">2L</span>, <span style="color:#00D">3L</span>].stream().map(<span style="color:#0a8;font-weight:bold">BigInteger</span>::valueOf).collect(toList())  // <b class="conum">(3)</b>

    <span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">1G</span>, <span style="color:#00D">2G</span>, <span style="color:#00D">3G</span>] == [<span style="color:#00D">1L</span>, <span style="color:#00D">2L</span>, <span style="color:#00D">3L</span>].stream().map(<span style="color:#00D">3G</span>::valueOf).collect(toList())          // <b class="conum">(4)</b>
}

methodRefs()</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类实例方法引用：add(BigInteger val)是BigInteger中的实例方法</p>
</li>
<li>
<p>对象实例方法引用：add(BigInteger val)是对象3G的实例方法</p>
</li>
<li>
<p>类静态方法引用： valueOf(long val) 是类 BigInteger 的静态方法</p>
</li>
<li>
<p>对象静态方法引用： valueOf(long val) 是对象 3G 的静态方法（在正常情况下有些人认为这种风格不好）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下脚本中显示了一些突出显示各种受支持的构造函数参考案例的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@CompileStatic</span>
<span style="color:#339;font-weight:bold">void</span> constructorRefs() {
    <span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>] == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">2</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">3</span><span style="color:#710">'</span></span>].stream().map(<span style="color:#0a8;font-weight:bold">Integer</span>::valueOf).collect(toList())  // <b class="conum">(1)</b>

    <span style="color:#080;font-weight:bold">def</span> result = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>].stream().toArray(<span style="color:#0a8;font-weight:bold">Integer</span><span style="color:#339;font-weight:bold">[]</span>::<span style="color:#080;font-weight:bold">new</span>)                           // <b class="conum">(2)</b>
    <span style="color:#080;font-weight:bold">assert</span> result <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Integer</span><span style="color:#339;font-weight:bold">[]</span>
    <span style="color:#080;font-weight:bold">assert</span> result.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[1, 2, 3]</span><span style="color:#710">'</span></span>
}

constructorRefs()</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类构造函数引用</p>
</li>
<li>
<p>数组构造函数引用</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式运算符"><a class="link" href="#_正则表达式运算符">2.7. 正则表达式运算符</a></h3>
<div class="sect3">
<h4 id="_模式运算符"><a class="link" href="#_模式运算符">2.7.1. 模式运算符</a></h4>
<div class="paragraph">
<p>模式运算符 ( ~ ) 提供了一种创建 java.util.regex.Pattern 实例的简单方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> p = ~<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">foo</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> p <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Pattern</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然一般情况下，模式运算符会与斜线字符串一起使用，但它可以与 Groovy 中的任何类型的 String 一起使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">p = ~<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>                                                        // <b class="conum">(1)</b>
p = ~<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo</span><span style="color:#710">&quot;</span></span>                                                        // <b class="conum">(2)</b>
p = ~<span style="color:#F00;background-color:#FAA">$</span><span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">dollar</span><span style="color:#404">/</span></span>slashy <span style="color:#F00;background-color:#FAA">$</span> string/<span style="color:#F00;background-color:#FAA">$</span>                                   // <b class="conum">(3)</b>
p = ~<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>pattern<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>                                                 // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用单引号字符串</p>
</li>
<li>
<p>使用双引号字符串</p>
</li>
<li>
<p>美元斜杠字符串允许您使用斜杠和美元符号而无需转义它们</p>
</li>
<li>
<p>您还可以使用 GString！</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
虽然您可以将大多数字符串形式与模式、查找和匹配运算符一起使用，但我们建议大多数时间使用斜线字符串，以避免转义。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_find_运算符"><a class="link" href="#_find_运算符">2.7.2. Find 运算符</a></h4>
<div class="paragraph">
<p>您还可以使用查找运算符 =~ 直接创建 java.util.regex.Matcher 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> text = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">some text to match</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> m = text =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">match</span><span style="color:#404">/</span></span>                                           // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> m <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Matcher</span>                                       // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">if</span> (!m) {                                                         // <b class="conum">(3)</b>
    <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">RuntimeException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Oops, text not found!</span><span style="color:#710">&quot;</span></span>)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>=~ 使用右侧的模式针对 text 变量创建匹配器</p>
</li>
<li>
<p>=~ 的返回类型是 Matcher</p>
</li>
<li>
<p>相当于调用 if (!m.find(0))</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>由于 Matcher 通过调用 find 方法强制转换为 boolean ，因此 =~ 运算符与 Perl 的 =~ 运算符，当它作为谓词出现时（在 if 、 ?: 等中）。当意图是迭代指定模式的匹配（在 while 等中）时，直接在匹配器上调用 find() 或使用 iterator DGM。</p>
</div>
</div>
<div class="sect3">
<h4 id="_match_运算符"><a class="link" href="#_match_运算符">2.7.3. Match 运算符</a></h4>
<div class="paragraph">
<p>匹配运算符 ( ==~ ) 是查找运算符的轻微变体，它不返回 Matcher 而是返回布尔值，并且需要输入字符串的严格匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">m = text ==~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">match</span><span style="color:#404">/</span></span>                                              // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> m <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">Boolean</span>                                       // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">if</span> (m) {                                                          // <b class="conum">(3)</b>
    <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">RuntimeException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Should not reach that point!</span><span style="color:#710">&quot;</span></span>)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>==~ 与正则表达式匹配主题，但匹配必须严格</p>
</li>
<li>
<p>==~ 的返回类型是 boolean</p>
</li>
<li>
<p>相当于调用 if (text ==~ /match/)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_find_和_match_运算符的比较"><a class="link" href="#_find_和_match_运算符的比较">2.7.4. Find 和 Match 运算符的比较</a></h4>
<div class="paragraph">
<p>通常，当模式涉及单个精确匹配时，使用匹配运算符，否则查找运算符可能更有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">two words</span><span style="color:#710">'</span></span> ==~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">two words</span><span style="color:#710">'</span></span> ==~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">^</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#808">$</span><span style="color:#404">/</span></span>         // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> !(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20"> leading space</span><span style="color:#710">'</span></span> ==~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#404">/</span></span>)   // <b class="conum">(2)</b>

<span style="color:#080;font-weight:bold">def</span> m1 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">two words</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">^</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#808">$</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> m1.size() == <span style="color:#00D">1</span>                          // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> m2 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">now three words</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">^</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#808">$</span><span style="color:#404">/</span></span>    // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> m2.size() == <span style="color:#00D">0</span>                          // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">def</span> m3 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">now three words</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> m3.size() == <span style="color:#00D">1</span>                          // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> m3[<span style="color:#00D">0</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">now three</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> m4 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20"> leading space</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> m4.size() == <span style="color:#00D">1</span>                          // <b class="conum">(7)</b>
<span style="color:#080;font-weight:bold">assert</span> m4[<span style="color:#00D">0</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">leading space</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> m5 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">and with four words</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#D20">\s</span><span style="color:#808">+</span><span style="color:#D20">\S</span><span style="color:#808">+</span><span style="color:#404">/</span></span>
<span style="color:#080;font-weight:bold">assert</span> m5.size() == <span style="color:#00D">2</span>                          // <b class="conum">(8)</b>
<span style="color:#080;font-weight:bold">assert</span> m5[<span style="color:#00D">0</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">and with</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> m5[<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">four words</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>equivalent, but explicit ^ and $ are discouraged since they aren&#8217;t needed</p>
</li>
<li>
<p>no match because of leading space</p>
</li>
<li>
<p>one match</p>
</li>
<li>
<p>^ and $ indicate exact match required</p>
</li>
<li>
<p>zero matches</p>
</li>
<li>
<p>one match, greedily starting at first word</p>
</li>
<li>
<p>one match, ignores leading space</p>
</li>
<li>
<p>two matches</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_其他操作符"><a class="link" href="#_其他操作符">2.8. 其他操作符</a></h3>
<div class="sect3">
<h4 id="_线程操作符"><a class="link" href="#_线程操作符">2.8.1. 线程操作符</a></h4>
<div class="paragraph">
<p>Spread-dot 运算符 ( *. ) 通常缩写为 Spread 运算符，用于对聚合对象的所有元素进行操作。它相当于对每个元素进行操作并将结果收集到列表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Car</span> {
    <span style="color:#0a8;font-weight:bold">String</span> make
    <span style="color:#0a8;font-weight:bold">String</span> model
}
<span style="color:#080;font-weight:bold">def</span> cars = [
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>),
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>)]       // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> makes = cars*.make                                // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> makes == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>]                // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>构建 Car 项的列表。该列表是对象的聚合。</p>
</li>
<li>
<p>调用列表上的展开运算符，访问每个项目的 make 属性</p>
</li>
<li>
<p>返回与 make 项集合相对应的字符串列表</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>表达式 cars*.make 相当于 cars.collect{ it.make }</p>
</div>
<div class="paragraph">
<p>Groovy&#8217;s GPath notation allows a short-cut when the referenced property
isn&#8217;t a property of the containing list, in that case it is automatically
spread.</p>
</div>
<div class="paragraph">
<p>在前面提到的情况下，可以使用表达式 cars.make ，但通常建议保留显式扩展点运算符。</p>
</div>
<div class="paragraph">
<p>扩展运算符是 null 安全的，这意味着如果集合的元素为 null，它将返回 null 而不是抛出 NullPointerException ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">cars = [
   <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>),
   <span style="color:#069">null</span>,                                              // <b class="conum">(1)</b>
   <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>)]
<span style="color:#080;font-weight:bold">assert</span> cars*.make == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="color:#069">null</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>]     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">null</span>*.make == <span style="color:#069">null</span>                             // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>构建一个列表，其中一个元素是 null</p>
</li>
<li>
<p>使用扩展运算符不会抛出 NullPointerException</p>
</li>
<li>
<p>接收者也可能为 null，在这种情况下返回值为 null</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>扩展运算符可用于任何实现 Iterable 接口的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Component</span> {
    <span style="color:#0a8;font-weight:bold">Integer</span> id
    <span style="color:#0a8;font-weight:bold">String</span> name
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CompositeObject</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Iterable</span>&lt;<span style="color:#0a8;font-weight:bold">Component</span>&gt; {
    <span style="color:#080;font-weight:bold">def</span> components = [
        <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Component</span>(<span style="color:#606">id</span>: <span style="color:#00D">1</span>, <span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>),
        <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Component</span>(<span style="color:#606">id</span>: <span style="color:#00D">2</span>, <span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bar</span><span style="color:#710">'</span></span>)]

    <span style="color:#007">@Override</span>
    <span style="color:#0a8;font-weight:bold">Iterator</span>&lt;<span style="color:#0a8;font-weight:bold">Component</span>&gt; iterator() {
        components.iterator()
    }
}
<span style="color:#080;font-weight:bold">def</span> composite = <span style="color:#080;font-weight:bold">new</span> CompositeObject()
<span style="color:#080;font-weight:bold">assert</span> composite*.id == [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>]
<span style="color:#080;font-weight:bold">assert</span> composite*.name == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bar</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>在处理本身包含聚合的数据结构的聚合时，使用扩散运算符（此处为 cars*.models*.name ）的多次调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Make</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#0a8;font-weight:bold">List</span>&lt;Model&gt; models
}

<span style="color:#007">@Canonical</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Model</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}

<span style="color:#080;font-weight:bold">def</span> cars = [
    <span style="color:#080;font-weight:bold">new</span> Make(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>,
             <span style="color:#606">models</span>: [<span style="color:#080;font-weight:bold">new</span> Model(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>), <span style="color:#080;font-weight:bold">new</span> Model(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>)]),
    <span style="color:#080;font-weight:bold">new</span> Make(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>,
             <span style="color:#606">models</span>: [<span style="color:#080;font-weight:bold">new</span> Model(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>), <span style="color:#080;font-weight:bold">new</span> Model(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>)])
]

<span style="color:#080;font-weight:bold">def</span> makes = cars*.name
<span style="color:#080;font-weight:bold">assert</span> makes == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>]

<span style="color:#080;font-weight:bold">def</span> models = cars*.models*.name
<span style="color:#080;font-weight:bold">assert</span> models == [[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>], [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>]]
<span style="color:#080;font-weight:bold">assert</span> models.sum() == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>] <span style="color:#777">// flatten one level</span>
<span style="color:#080;font-weight:bold">assert</span> models.flatten() == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>] <span style="color:#777">// flatten all levels (one in this case)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于集合的集合，请考虑使用 collectNested 方法而不是散点运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Car</span> {
    <span style="color:#0a8;font-weight:bold">String</span> make
    <span style="color:#0a8;font-weight:bold">String</span> model
}
<span style="color:#080;font-weight:bold">def</span> cars = [
   [
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>),
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Peugeot</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>)
   ], [
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>),
       <span style="color:#080;font-weight:bold">new</span> Car(<span style="color:#606">make</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Renault</span><span style="color:#710">'</span></span>, <span style="color:#606">model</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>)
   ]
]
<span style="color:#080;font-weight:bold">def</span> models = cars.collectNested{ <span style="color:#950">it</span>.model }
<span style="color:#080;font-weight:bold">assert</span> models == [[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">408</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">508</span><span style="color:#710">'</span></span>], [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clio</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Captur</span><span style="color:#710">'</span></span>]]</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_展开方法参数"><a class="link" href="#_展开方法参数">2.8.1.1. 展开方法参数</a></h5>
<div class="paragraph">
<p>在某些情况下，可以在List中找到方法调用的参数。在这种情况下，您可以使用扩展运算符来调用该方法。例如，假设您有以下方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> function(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#339;font-weight:bold">int</span> z) {
    x*y+z
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么如果您有以下列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> args = [<span style="color:#00D">4</span>,<span style="color:#00D">5</span>,<span style="color:#00D">6</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以调用该方法而无需定义中间变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> function(*args) == <span style="color:#00D">26</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至可以将普通参数与扩展参数混合在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">args = [<span style="color:#00D">4</span>]
<span style="color:#080;font-weight:bold">assert</span> function(*args,<span style="color:#00D">5</span>,<span style="color:#00D">6</span>) == <span style="color:#00D">26</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_展开列表元素"><a class="link" href="#_展开列表元素">2.8.1.2. 展开列表元素</a></h5>
<div class="paragraph">
<p>当在列表中使用时，展开运算符的作用就好像展开元素内容并内联到列表中一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> items = [<span style="color:#00D">4</span>,<span style="color:#00D">5</span>]                      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> list = [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,*items,<span style="color:#00D">6</span>]            // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> list == [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>,<span style="color:#00D">6</span>]           // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>items 是一个列表</p>
</li>
<li>
<p>我们希望将 items 列表的内容直接插入到 list 中，而不必调用 addAll</p>
</li>
<li>
<p>items 的内容已内联到 list 中</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_扩展map中的元素"><a class="link" href="#_扩展map中的元素">2.8.1.3. 扩展map中的元素</a></h5>
<div class="paragraph">
<p>展开map运算符的工作方式与展开list运算符类似，但适用于map。它允许您将map的内容内联到另一个map中，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> m1 = [<span style="color:#606">c</span>:<span style="color:#00D">3</span>, <span style="color:#606">d</span>:<span style="color:#00D">4</span>]                   // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> map = [<span style="color:#606">a</span>:<span style="color:#00D">1</span>, <span style="color:#606">b</span>:<span style="color:#00D">2</span>, *:m1]            // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> map == [<span style="color:#606">a</span>:<span style="color:#00D">1</span>, <span style="color:#606">b</span>:<span style="color:#00D">2</span>, <span style="color:#606">c</span>:<span style="color:#00D">3</span>, <span style="color:#606">d</span>:<span style="color:#00D">4</span>]    // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>m1</code> 是我们要内联的map</p>
</li>
<li>
<p>我们使用 <code>*:m1</code> 表示法将 m1 的内容扩展到 map</p>
</li>
<li>
<p>map 包含 m1 的所有元素</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>展开map运算符的位置是相关的，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> m1 = [<span style="color:#606">c</span>:<span style="color:#00D">3</span>, <span style="color:#606">d</span>:<span style="color:#00D">4</span>]                   // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> map = [<span style="color:#606">a</span>:<span style="color:#00D">1</span>, <span style="color:#606">b</span>:<span style="color:#00D">2</span>, *:m1, <span style="color:#606">d</span>: <span style="color:#00D">8</span>]      // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> map == [<span style="color:#606">a</span>:<span style="color:#00D">1</span>, <span style="color:#606">b</span>:<span style="color:#00D">2</span>, <span style="color:#606">c</span>:<span style="color:#00D">3</span>, <span style="color:#606">d</span>:<span style="color:#00D">8</span>]    // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>m1 是我们要内联的地图</p>
</li>
<li>
<p>我们使用 <code>*:m1</code> 表示法将 <code>m1</code> 的内容扩展到 <code>map</code> 中，但在扩招后重新设置key d</p>
</li>
<li>
<p>map 包含所有预期的键，但 d 被重新设置</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_范围运算符"><a class="link" href="#_范围运算符">2.8.2. 范围运算符</a></h4>
<div class="paragraph">
<p>Groovy 支持范围的概念并提供符号 ( .. ) 来创建对象范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> range = <span style="color:#00D">0</span>..<span style="color:#00D">5</span>                                    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>..<span style="color:#00D">5</span>).collect() == [<span style="color:#00D">0</span>, <span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>, <span style="color:#00D">5</span>]       // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>..&lt;<span style="color:#00D">5</span>).collect() == [<span style="color:#00D">0</span>, <span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>]         // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>&lt;..<span style="color:#00D">5</span>).collect() == [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>, <span style="color:#00D">5</span>]         // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>&lt;..&lt;<span style="color:#00D">5</span>).collect() == [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>]           // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>..<span style="color:#00D">5</span>) <span style="color:#080;font-weight:bold">instanceof</span> <span style="color:#0a8;font-weight:bold">List</span>                       // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">0</span>..<span style="color:#00D">5</span>).size() == <span style="color:#00D">6</span>                           // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>一个简单的整数范围，存储到局部变量中</p>
</li>
<li>
<p>一个 IntRange ，包含边界</p>
</li>
<li>
<p>一个 IntRange ，具有独占上限</p>
</li>
<li>
<p>一个 IntRange ，具有独占下限</p>
</li>
<li>
<p>一个 IntRange ，具有独占的下限和上限</p>
</li>
<li>
<p>groovy.lang.Range 实现 List 接口</p>
</li>
<li>
<p>意味着你可以调用它的 size 方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>范围实现是轻量级的，这意味着仅存储下限和上限。You can create a range
from any <code>Comparable</code> object that has <code>next()</code> and <code>previous()</code> methods to determine the next / previous item in the range.
例如，您可以通过以下方式创建一系列字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>..<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>).collect() == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spaceship_操作符"><a class="link" href="#_spaceship_操作符">2.8.3. Spaceship 操作符</a></h4>
<div class="paragraph">
<p>spaceship 操作符 (<code>&lt;=&gt;</code>) 委托给 compareTo 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">1</span> &lt;=&gt; <span style="color:#00D">1</span>) == <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">1</span> &lt;=&gt; <span style="color:#00D">2</span>) == -<span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> (<span style="color:#00D">2</span> &lt;=&gt; <span style="color:#00D">1</span>) == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span> &lt;=&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">z</span><span style="color:#710">'</span></span>) == -<span style="color:#00D">1</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subscript-operator"><a class="link" href="#subscript-operator">2.8.4. 下标运算符</a></h4>
<div class="paragraph">
<p>下标运算符是 getAt 或 putAt 的简写符号，具体取决于您是在赋值的左侧还是右侧找到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list = [<span style="color:#00D">0</span>,<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>]
<span style="color:#080;font-weight:bold">assert</span> list[<span style="color:#00D">2</span>] == <span style="color:#00D">2</span>                         // <b class="conum">(1)</b>
list[<span style="color:#00D">2</span>] = <span style="color:#00D">4</span>                                 // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> list[<span style="color:#00D">0</span>..<span style="color:#00D">2</span>] == [<span style="color:#00D">0</span>,<span style="color:#00D">1</span>,<span style="color:#00D">4</span>]                // <b class="conum">(3)</b>
list[<span style="color:#00D">0</span>..<span style="color:#00D">2</span>] = [<span style="color:#00D">6</span>,<span style="color:#00D">6</span>,<span style="color:#00D">6</span>]                        // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> list == [<span style="color:#00D">6</span>,<span style="color:#00D">6</span>,<span style="color:#00D">6</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>]                  // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>可以使用 [2] 代替 getAt(2)</p>
</li>
<li>
<p>如果在作业的左侧，将调用 putAt</p>
</li>
<li>
<p>getAt 还支持范围</p>
</li>
<li>
<p>putAt 也是如此</p>
</li>
<li>
<p>列表已发生变化</p>
</li>
</ol>
</div>
<div id="custom-subscript-operator" class="paragraph">
<p>下标运算符与 getAt / putAt 的自定义实现相结合是解构对象的便捷方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">User</span> {
    <span style="color:#0a8;font-weight:bold">Long</span> id
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">getAt</span>(<span style="color:#339;font-weight:bold">int</span> i) {                                             // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">switch</span> (i) {
            <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">0</span>: <span style="color:#080;font-weight:bold">return</span> id
            <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">1</span>: <span style="color:#080;font-weight:bold">return</span> name
        }
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalArgumentException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">No such element </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>i</span><span style="color:#710">&quot;</span></span>)
    }
    <span style="color:#339;font-weight:bold">void</span> putAt(<span style="color:#339;font-weight:bold">int</span> i, <span style="color:#080;font-weight:bold">def</span> value) {                                 // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">switch</span> (i) {
            <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">0</span>: id = value; <span style="color:#080;font-weight:bold">return</span>
            <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">1</span>: name = value; <span style="color:#080;font-weight:bold">return</span>
        }
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">IllegalArgumentException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">No such element </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>i</span><span style="color:#710">&quot;</span></span>)
    }
}
<span style="color:#080;font-weight:bold">def</span> user = <span style="color:#080;font-weight:bold">new</span> User(<span style="color:#606">id</span>: <span style="color:#00D">1</span>, <span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alex</span><span style="color:#710">'</span></span>)                           // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> user[<span style="color:#00D">0</span>] == <span style="color:#00D">1</span>                                                // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> user[<span style="color:#00D">1</span>] == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alex</span><span style="color:#710">'</span></span>                                           // <b class="conum">(5)</b>
user[<span style="color:#00D">1</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                                                    // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> user.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                                          // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>User 类定义自定义 getAt 实现</p>
</li>
<li>
<p>User 类定义自定义 putAt 实现</p>
</li>
<li>
<p>创建示例</p>
</li>
<li>
<p>使用索引为 0 的下标运算符可以检索用户 ID</p>
</li>
<li>
<p>使用索引为 1 的下标运算符可以检索用户名</p>
</li>
<li>
<p>由于对 putAt 的委托，我们可以使用下标运算符写入属性</p>
</li>
<li>
<p>并检查它是否确实是已更改的属性 name</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_安全索引运算符"><a class="link" href="#_安全索引运算符">2.8.5. 安全索引运算符</a></h4>
<div class="paragraph">
<p>Groovy 3.0.0 引入了安全索引运算符，即 ?[] ，它类似于 ?. 。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> array = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span> == array?[<span style="color:#00D">1</span>]      <span style="color:#777">// get using normal array index</span>
array?[<span style="color:#00D">1</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>              <span style="color:#777">// set using normal array index</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span> == array?[<span style="color:#00D">1</span>]

array = <span style="color:#069">null</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">null</span> == array?[<span style="color:#00D">1</span>]     <span style="color:#777">// return null for all index values</span>
array?[<span style="color:#00D">1</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>              <span style="color:#777">// quietly ignore attempt to set value</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">null</span> == array?[<span style="color:#00D">1</span>]

<span style="color:#080;font-weight:bold">def</span> personInfo = [<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Daniel.Sun</span><span style="color:#710">'</span></span>, <span style="color:#606">location</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Shanghai</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Daniel.Sun</span><span style="color:#710">'</span></span> == personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>]      <span style="color:#777">// get using normal map index</span>
personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sunlan</span><span style="color:#710">'</span></span>                  <span style="color:#777">// set using normal map index</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sunlan</span><span style="color:#710">'</span></span> == personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>]

personInfo = <span style="color:#069">null</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">null</span> == personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>]              <span style="color:#777">// return null for all map values</span>
personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sunlan</span><span style="color:#710">'</span></span>                  <span style="color:#777">// quietly ignore attempt to set value</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">null</span> == personInfo?[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_成员_运算符"><a class="link" href="#_成员_运算符">2.8.6. 成员 运算符</a></h4>
<div class="paragraph">
<p>成员运算符 ( in ) 相当于调用 isCase 方法。在 List 的上下文中，它相当于调用 contains ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Grace</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Rob</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Emmy</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Emmy</span><span style="color:#710">'</span></span> <span style="color:#080;font-weight:bold">in</span> list)                     // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alex</span><span style="color:#710">'</span></span> !<span style="color:#080;font-weight:bold">in</span> list)                    // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>相当于调用 list.contains('Emmy') 或 list.isCase('Emmy')</p>
</li>
<li>
<p>相当于调用 !list.contains('Emmy') 或 !list.isCase('Emmy')</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_和_运算符"><a class="link" href="#_和_运算符">2.8.7. <code>==</code> 和 <code>===</code> 运算符</a></h4>
<div class="paragraph">
<p>在 Groovy 中，使用 == 测试相等性与在 Java 中使用相同的运算符不同。在 Groovy 中，它调用 equals 。如果要比较引用相等性，应使用 is ，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list1 = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 1.8</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 2.0</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 2.3</span><span style="color:#710">'</span></span>]        // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> list2 = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 1.8</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 2.0</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy 2.3</span><span style="color:#710">'</span></span>]        // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> list1 == list2                                       // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> !list1.is(list2)                                     // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> list1 !== list2                                      // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建字符串列表</p>
</li>
<li>
<p>创建另一个包含相同元素的字符串列表</p>
</li>
<li>
<p>使用 == ，我们测试对象相等性，相当于 Java 中的 list1.equals(list2)</p>
</li>
<li>
<p>使用 is ，我们可以检查引用是否不同，相当于 Java 中的 list1 == list2</p>
</li>
<li>
<p>使用 === 或 !== （从 Groovy 3.0.0 开始支持和推荐）检查引用是否不同，相当于 list1 == list2 和 list1 != list2 在 Java 中</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_类型强制转换运算符"><a class="link" href="#_类型强制转换运算符">2.8.8. 类型强制转换运算符</a></h4>
<div class="paragraph">
<p>强制转换运算符 ( as ) 是强制转换的一种变体。强制转换将对象从一种类型转换为另一种类型，但它们不兼容赋值。举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> input = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">42</span><span style="color:#710">'</span></span>
<span style="color:#0a8;font-weight:bold">Integer</span> num = (<span style="color:#0a8;font-weight:bold">Integer</span>) input                      // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Integer 不可分配给 String ，因此它将在运行时生成 ClassCastException</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这可以通过使用强制来解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> input = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">42</span><span style="color:#710">'</span></span>
<span style="color:#0a8;font-weight:bold">Integer</span> num = input <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Integer</span>                      // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Integer 不可分配给 String ，但使用 as 会将其强制分配给 String</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当一个对象被强制转换为另一个对象时，除非目标类型与源类型相同，否则强制将返回一个新对象。根据源类型和目标类型的不同，强制转换的规则也不同，如果没有找到转换规则，则强制转换可能会失败。自定义转换规则可以通过 <code>asType</code> 方法来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Identifiable</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">User</span> {
    <span style="color:#0a8;font-weight:bold">Long</span> id
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">asType</span>(<span style="color:#0a8;font-weight:bold">Class</span> target) {                                              // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">if</span> (target == Identifiable) {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Identifiable(<span style="color:#606">name</span>: name)
        }
        <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">ClassCastException</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">User cannot be coerced into </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>target</span><span style="color:#710">&quot;</span></span>)
    }
}
<span style="color:#080;font-weight:bold">def</span> u = <span style="color:#080;font-weight:bold">new</span> User(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Xavier</span><span style="color:#710">'</span></span>)                                            // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> p = u <span style="color:#080;font-weight:bold">as</span> Identifiable                                                   // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> p <span style="color:#080;font-weight:bold">instanceof</span> Identifiable                                            // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> !(p <span style="color:#080;font-weight:bold">instanceof</span> User)                                                 // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>User 类定义了从 User 到 Identifiable 的自定义转换规则</p>
</li>
<li>
<p>我们创建 User 的实例</p>
</li>
<li>
<p>我们将 User 实例强制转换为 Identifiable</p>
</li>
<li>
<p>目标是 Identifiable 的实例</p>
</li>
<li>
<p>目标不再是 User 的实例</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_操作符"><a class="link" href="#_操作符">2.8.9. &lt;&gt; 操作符</a></h4>
<div class="paragraph">
<p>菱形运算符 ( &lt;&gt; ) 是一个仅添加语法糖的运算符，用于支持与 Java 7 中同名运算符的兼容性。它用于指示应从声明中推断泛型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt; strings = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">LinkedList</span>&lt;&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在动态 Groovy 中，这是完全未使用的。在静态类型检查的 Groovy 中，它也是可选的，因为无论该运算符是否存在，Groovy 类型检查器都会执行类型推断。</p>
</div>
</div>
<div class="sect3">
<h4 id="_call_运算符"><a class="link" href="#_call_运算符">2.8.10. Call 运算符</a></h4>
<div class="paragraph">
<p>调用运算符 () 用于隐式调用名为 call 的方法。对于定义 call 方法的任何对象，您可以省略 .call 部分并使用调用运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyCallable</span> {
    <span style="color:#339;font-weight:bold">int</span> call(<span style="color:#339;font-weight:bold">int</span> x) {           // <b class="conum">(1)</b>
        <span style="color:#00D">2</span>*x
    }
}

<span style="color:#080;font-weight:bold">def</span> mc = <span style="color:#080;font-weight:bold">new</span> MyCallable()
<span style="color:#080;font-weight:bold">assert</span> mc.call(<span style="color:#00D">2</span>) == <span style="color:#00D">4</span>          // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> mc(<span style="color:#00D">2</span>) == <span style="color:#00D">4</span>               // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>MyCallable 定义了一个名为 call 的方法。请注意，它不需要实现 java.util.concurrent.Callable</p>
</li>
<li>
<p>我们可以使用经典的方法调用语法来调用该方法</p>
</li>
<li>
<p>或者我们可以省略 .call</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_运算符优先级"><a class="link" href="#_运算符优先级">2.9. 运算符优先级</a></h3>
<div class="paragraph">
<p>下表按优先级顺序列出了所有 groovy 运算符。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Level</th>
<th class="tableblock halign-left valign-top">Operator(s)</th>
<th class="tableblock halign-left valign-top">Name(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>new</code> &#160; <code>()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object creation, explicit parentheses</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>()</code> &#160; <code>{}</code> &#160; <code>[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">method call, closure, literal list/map</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.</code> &#160; <code>.&amp;</code> &#160; <code>.@</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">member access, method closure, field/attribute access</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?.</code> &#160; <code>*</code> &#160; <code>*.</code> &#160; <code>*:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">safe dereferencing, spread, spread-dot, spread-map</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~</code> &#160; <code>!</code> &#160; <code>(type)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitwise negate/pattern, not, typecast</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[]</code> &#160; <code>?[]</code> &#160; <code>++</code> &#160; <code>--</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list/map/array (safe) index, post inc/decrement</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">power</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+` {nbsp} `--` {nbsp} `</code> &#160; <code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pre inc/decrement, unary plus, unary minus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code> &#160; <code>/</code> &#160; <code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">multiply, div, remainder</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code> &#160; <code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">addition, subtraction</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;&lt;</code> &#160; <code>&gt;&gt;</code> &#160; <code>&gt;&gt;&gt;</code> &#160; <code>..</code> &#160; <code>..&lt;</code> &#160; <code>&lt;..&lt;</code> &#160; <code>&lt;..</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">left/right (unsigned) shift, inclusive/exclusive ranges</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code> &#160; <code>&lt;=</code> &#160; <code>&gt;</code> &#160; <code>&gt;=</code> &#160; <code>in</code> &#160; <code>!in</code> &#160; <code>instanceof</code> &#160; <code>!instanceof</code> &#160; <code>as</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">less/greater than/or equal, in, not in, instanceof, not instanceof, type coercion</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code> &#160; <code>!=</code> &#160; <code>&lt;=&gt;</code> &#160; <code>===</code> &#160; <code>!==</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equals, not equals, compare to, identical to, not identical to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=~</code> &#160; <code>==~</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex find, regex match</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary/bitwise and</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary/bitwise xor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary/bitwise or</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;&amp;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical and</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>||</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical or</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>? :</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ternary conditional</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">elvis operator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=</code> &#160; <code>**=</code> &#160; <code>*=</code> &#160; <code>/=</code> &#160; <code>%=</code> &#160; <code>+=</code> &#160; <code>-=</code> &#160;<br>
<code>&lt;&lt;=</code> &#160; <code>&gt;&gt;=</code> &#160; <code>&gt;&gt;&gt;=</code> &#160; <code>&amp;=</code> &#160; <code>^=</code> &#160; <code>|=</code> &#160; &#160; <code>?=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">various assignments</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="Operator-Overloading"><a class="link" href="#Operator-Overloading">2.10. 运算符重载</a></h3>
<div class="paragraph">
<p>Groovy 允许您重载各种运算符，以便它们可以与您自己的类一起使用。考虑这个简单的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bucket</span> {
    <span style="color:#339;font-weight:bold">int</span> size

    Bucket(<span style="color:#339;font-weight:bold">int</span> size) { <span style="color:#950">this</span>.size = size }

    Bucket plus(Bucket other) {                     // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Bucket(<span style="color:#950">this</span>.size + other.size)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Bucket 实现了一个名为 plus() 的特殊方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>只需实现 plus() 方法， Bucket 类现在就可以与 + 运算符一起使用，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> b1 = <span style="color:#080;font-weight:bold">new</span> Bucket(<span style="color:#00D">4</span>)
<span style="color:#080;font-weight:bold">def</span> b2 = <span style="color:#080;font-weight:bold">new</span> Bucket(<span style="color:#00D">11</span>)
<span style="color:#080;font-weight:bold">assert</span> (b1 + b2).size == <span style="color:#00D">15</span>                         // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>两个 Bucket 对象可以使用 + 运算符添加在一起</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>所有的非比较运算符都有一个相应的方法，您可以在自己的类中实现该方法。唯一的要求是您的方法是公共的，具有正确的名称，并且具有正确的参数数量。参数类型取决于您想要在运算符右侧支持的类型。例如，您可以支持以下陈述</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (b1 + <span style="color:#00D">11</span>).size == <span style="color:#00D">15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用以下签名实现 plus() 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Bucket plus(<span style="color:#339;font-weight:bold">int</span> capacity) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Bucket(<span style="color:#950">this</span>.size + capacity)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是运算符及其相应方法的完整列表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Method</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.plus(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.getAt(b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.minus(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b] = c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.putAt(b, c)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.multiply(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a in b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b.isCase(a)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.div(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;&lt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.leftShift(b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.mod(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShift(b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.power(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShiftUnsigned(b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.or(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>++</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.next()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.and(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.previous()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.xor(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.positive()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>as</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.asType(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.negative()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.call()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.bitwiseNegate()</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_程序结构"><a class="link" href="#_程序结构">3. 程序结构</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍 Groovy 编程语言的程序结构。</p>
</div>
<div class="sect2">
<h3 id="_包名"><a class="link" href="#_包名">3.1. 包名</a></h3>
<div class="paragraph">
<p>包名称的作用与 Java 中的作用完全相同。它们允许我们在没有任何冲突的情况下分离代码库。 Groovy 类必须在类定义之前指定其包，否则采用默认包。</p>
</div>
<div class="paragraph">
<p>定义包与 Java 非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// defining a package named com.yoursite</span>
<span style="color:#080;font-weight:bold">package</span> com.yoursite</code></pre>
</div>
</div>
<div class="paragraph">
<p>要引用 <code>com.yoursite.com</code> 包中的某些类 <code>Foo</code> ，您需要使用完全限定名称 <code>com.yoursite.com.Foo</code> ，或者您可以像如下说明的那样使用 <code>import</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_imports"><a class="link" href="#_imports">3.2. Imports</a></h3>
<div class="paragraph">
<p>为了引用类，您需要对其包的限定引用。 Groovy 遵循 Java 的概念，允许 import 语句解析类引用。</p>
</div>
<div class="paragraph">
<p>例如，Groovy 提供了多个构建器类，例如 <code>MarkupBuilder</code> 。 <code>MarkupBuilder</code> 位于包 <code>groovy.xml</code> 内，因此为了使用此类，您需要 <code>import</code> 它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// importing the class MarkupBuilder</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.xml.MarkupBuilder</span>

<span style="color:#777">// using the imported class to create an object</span>
<span style="color:#080;font-weight:bold">def</span> xml = <span style="color:#080;font-weight:bold">new</span> MarkupBuilder()

<span style="color:#080;font-weight:bold">assert</span> xml != <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_默认导入"><a class="link" href="#_默认导入">3.2.1. 默认导入</a></h4>
<div class="paragraph">
<p>默认导入是 Groovy 语言默认提供的导入。例如看下面的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java 中的相同代码需要对 <code>Date</code> 类使用 <code>import</code> 语句，如下所示：import java.util.Date 。 Groovy 默认情况下会为您导入这些类。</p>
</div>
<div class="paragraph">
<p>以下导入由 groovy 为您自动添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.lang.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.util.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.io.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.net.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.lang.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.util.*</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.math.BigInteger</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.math.BigDecimal</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做是因为这些包中的类最常用。通过导入这些样板代码可以减少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_简单导入"><a class="link" href="#_简单导入">3.2.2. 简单导入</a></h4>
<div class="paragraph">
<p>简单导入是一个导入语句，您可以在其中完全定义类名和包。例如，下面代码中的 <code>import</code> 语句 <code>import groovy.xml.MarkupBuilder</code> 是一个简单的导入，它直接引用包内的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// importing the class MarkupBuilder</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.xml.MarkupBuilder</span>

<span style="color:#777">// using the imported class to create an object</span>
<span style="color:#080;font-weight:bold">def</span> xml = <span style="color:#080;font-weight:bold">new</span> MarkupBuilder()

<span style="color:#080;font-weight:bold">assert</span> xml != <span style="color:#069">null</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_导入"><a class="link" href="#_导入">3.2.3. * 导入</a></h4>
<div class="paragraph">
<p>Groovy 与 Java 一样，使用 <code>*</code> 从包中导入所有类，即所谓的星号导入。 <code>MarkupBuilder</code> 是一个位于包 <code>groovy.xml</code> 中的类，与另一个名为 <code>StreamingMarkupBuilder</code> 的类一起。如果您需要使用这两个类，您可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.xml.MarkupBuilder</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.xml.StreamingMarkupBuilder</span>

<span style="color:#080;font-weight:bold">def</span> markupBuilder = <span style="color:#080;font-weight:bold">new</span> MarkupBuilder()

<span style="color:#080;font-weight:bold">assert</span> markupBuilder != <span style="color:#069">null</span>

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> StreamingMarkupBuilder() != <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是完全有效的代码。但是通过 <code><strong></code> 导入，我们只需一行即可达到相同的效果。 <code></strong></code> 导入包 <code>groovy.xml</code> 下的所有类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.xml.*</span>

<span style="color:#080;font-weight:bold">def</span> markupBuilder = <span style="color:#080;font-weight:bold">new</span> MarkupBuilder()

<span style="color:#080;font-weight:bold">assert</span> markupBuilder != <span style="color:#069">null</span>

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> StreamingMarkupBuilder() != <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>*</code> 的一个问题是它们可能会扰乱您的本地命名空间。但通过 Groovy 提供的别名类型，这个问题可以轻松解决。</p>
</div>
</div>
<div class="sect3">
<h4 id="_static_导入"><a class="link" href="#_static_导入">3.2.4. Static 导入</a></h4>
<div class="paragraph">
<p>Groovy 的静态导入功能允许您使用导入的类，就像它们是您自己的类中的静态方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">static</span> <span style="color:#B44;font-weight:bold">java.lang.Boolean.FALSE</span>

<span style="color:#080;font-weight:bold">assert</span> !FALSE <span style="color:#777">//use directly, without Boolean prefix!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这类似于 Java 的静态导入功能，但比 Java 更加动态，因为它允许您定义与导入方法同名的方法，只要您具有不同的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">static</span> <span style="color:#B44;font-weight:bold">java.lang.String.format</span> // <b class="conum">(1)</b>

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SomeClass</span> {

    <span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">Integer</span> i) { // <b class="conum">(2)</b>
        i.toString()
    }

    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> main(<span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> args) {
        <span style="color:#080;font-weight:bold">assert</span> format(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">String</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">String</span><span style="color:#710">'</span></span> // <b class="conum">(3)</b>
        <span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> SomeClass().format(<span style="color:#0a8;font-weight:bold">Integer</span>.valueOf(<span style="color:#00D">1</span>)) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1</span><span style="color:#710">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>方法的静态导入</p>
</li>
<li>
<p>方法声明与上面静态导入的方法同名，但参数类型不同</p>
</li>
<li>
<p>java中编译错误，但是有效的groovy代码</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果类型相同，则导入的类优先。</p>
</div>
</div>
<div class="sect3">
<h4 id="_静态导入别名"><a class="link" href="#_静态导入别名">3.2.5. 静态导入别名</a></h4>
<div class="paragraph">
<p>使用 <code>as</code> 关键字的静态导入为命名空间问题提供了一种优雅的解决方案。假设您想使用 <code>getInstance()</code> 方法获取 <code>Calendar</code> 实例。它是一个静态方法，因此我们可以使用静态导入。但是，我们可以使用别名导入它，以增加代码的可读性，而不是每次都调用 <code>getInstance()</code> ，这在与类名分开时可能会产生误导：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">static</span> <span style="color:#B44;font-weight:bold">Calendar.getInstance</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#B06;font-weight:bold">now</span>

<span style="color:#080;font-weight:bold">assert</span> now().class == <span style="color:#0a8;font-weight:bold">Calendar</span>.getInstance().class</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，一切都干净了！</p>
</div>
</div>
<div class="sect3">
<h4 id="_静态星号导入"><a class="link" href="#_静态星号导入">3.2.6. 静态星号导入</a></h4>
<div class="paragraph">
<p>静态星形导入与常规星形导入非常相似。它将导入给定类中的所有静态方法。</p>
</div>
<div class="paragraph">
<p>例如，假设我们需要为我们的应用程序计算正弦和余弦。类 <code>java.lang.Math</code> 有名为 <code>sin</code> 和 <code>cos</code> 的静态方法，满足我们的需要。借助静态星号导入，我们可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">static</span> <span style="color:#B44;font-weight:bold">java.lang.Math.*</span>

<span style="color:#080;font-weight:bold">assert</span> sin(<span style="color:#00D">0</span>) == <span style="color:#60E">0.0</span>
<span style="color:#080;font-weight:bold">assert</span> cos(<span style="color:#00D">0</span>) == <span style="color:#60E">1.0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，我们能够直接访问方法 <code>sin</code> 和 <code>cos</code> ，无需 <code>Math.</code> 前缀。</p>
</div>
</div>
<div class="sect3">
<h4 id="_导入别名"><a class="link" href="#_导入别名">3.2.7. 导入别名</a></h4>
<div class="paragraph">
<p>通过类型别名，我们可以使用我们选择的名称来引用完全限定的类名。这可以像以前一样使用 <code>as</code> 关键字来完成。</p>
</div>
<div class="paragraph">
<p>例如，我们可以将 <code>java.sql.Date</code> 导入为 <code>SQLDate</code> 并在与 <code>java.util.Date</code> 相同的文件中使用它，而不必使用任一类的完全限定名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.util.Date</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.sql.Date</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#B06;font-weight:bold">SQLDate</span>

<span style="color:#0a8;font-weight:bold">Date</span> utilDate = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>(<span style="color:#00D">1000L</span>)
SQLDate sqlDate = <span style="color:#080;font-weight:bold">new</span> SQLDate(<span style="color:#00D">1000L</span>)

<span style="color:#080;font-weight:bold">assert</span> utilDate <span style="color:#080;font-weight:bold">instanceof</span> java.util.Date
<span style="color:#080;font-weight:bold">assert</span> sqlDate <span style="color:#080;font-weight:bold">instanceof</span> java.sql.Date</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名空间冲突"><a class="link" href="#_命名空间冲突">3.2.8. 命名空间冲突</a></h4>
<div class="paragraph">
<p>与Java类似，在Groovy中，如果指定了相同名称但类型不同的多个导入，这将是一个错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.awt.List</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.util.List</span> <span style="color:#777">// error: name already declared</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用相同的名字声明import和顶级类型一样会导致error</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.util.List</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">List</span> { } <span style="color:#777">// error: name already declared</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，内部类可以在单元作用域内隐藏名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.util.List</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Main</span> {
    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">List</span> { } <span style="color:#777">// allowed; &quot;List&quot; refers to this type within `Main`'s scope and `java.util.List` elsewhere</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_脚本与类"><a class="link" href="#_脚本与类">3.3. 脚本与类</a></h3>
<div class="paragraph">
<p>Groovy支持脚本与类</p>
</div>
<div class="paragraph">
<p>从 Groovy 5开始,
Groovy 也支持 <a href="https://openjdk.org/jeps/445">JEP 445</a> 兼容的脚本.</p>
</div>
<div class="sect3">
<h4 id="_motivation_for_scripts"><a class="link" href="#_motivation_for_scripts">3.3.1. Motivation for scripts</a></h4>
<div class="paragraph">
<p>以下面的代码为例：</p>
</div>
<div class="listingblock">
<div class="title">Main.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Main</span> {                                    // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> main(<span style="color:#0a8;font-weight:bold">String</span>... args) {          // <b class="conum">(2)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy world!</span><span style="color:#710">'</span></span>                 // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义一个 <code>Main</code> 类，名称任意</p>
</li>
<li>
<p><code>public static void main(String[])</code> 方法可用作类的主方法</p>
</li>
<li>
<p>该方法的主体</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这是来自 Java 的典型代码，其中代码必须嵌入到类中才能执行。 Groovy 使它变得更容易，以下代码是等效的：</p>
</div>
<div class="listingblock">
<div class="title">Main.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy world!</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>脚本可以认为是一个无需显示声明的类, 但他们仍然有一些差异, 我们将在接下来进行介绍。首先，我们将介绍Groovy的 main <code>Script`类。然后，我们将介绍与 `JEP 445</code> 兼容的类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_script_class"><a class="link" href="#_script_class">3.3.2. <code>Script</code> class</a></h4>
<div class="paragraph">
<p><code>groovy.lang.Script</code> 总是被编译进一个类。 Groovy 编译器将为您编译该类，并将脚本主体复制到 <code>run</code> 方法中。因此，前面的示例被编译为如下所示：</p>
</div>
<div class="listingblock">
<div class="title">Main.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.runtime.InvokerHelper</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Main</span> <span style="color:#088;font-weight:bold">extends</span> Script {                     // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>() {                                 // <b class="conum">(2)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy world!</span><span style="color:#710">'</span></span>                 // <b class="conum">(3)</b>
    }
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> main(<span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> args) {           // <b class="conum">(4)</b>
        InvokerHelper.runScript(Main, args)     // <b class="conum">(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>Main</code> 类继承了 <code>groovy.lang.Script</code> 类</p>
</li>
<li>
<p><code>groovy.lang.Script</code> 需要 <code>run</code> 方法返回值</p>
</li>
<li>
<p>脚本主体进入 <code>run</code> 方法</p>
</li>
<li>
<p><code>main</code> 方法是自动生成的</p>
</li>
<li>
<p>并委托 <code>run</code> 方法执行脚本</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果脚本位于文件中，则使用该文件的基本名称来确定生成的脚本类的名称。在此示例中，如果文件名是 <code>Main.groovy</code> ，则脚本类将为 <code>Main</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_方法"><a class="link" href="#_方法">3.3.3. 方法</a></h4>
<div class="paragraph">
<p>可以将方法定义到脚本中，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> fib(<span style="color:#339;font-weight:bold">int</span> n) {
    n &lt; <span style="color:#00D">2</span> ? <span style="color:#00D">1</span> : fib(n-<span style="color:#00D">1</span>) + fib(n-<span style="color:#00D">2</span>)
}
<span style="color:#080;font-weight:bold">assert</span> fib(<span style="color:#00D">10</span>)==<span style="color:#00D">89</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以混合方法和代码。生成的脚本类会将所有方法携带到脚本类中，并将所有脚本体组装到 run 方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello</span><span style="color:#710">'</span></span>                                 // <b class="conum">(1)</b>

<span style="color:#339;font-weight:bold">int</span> power(<span style="color:#339;font-weight:bold">int</span> n) { <span style="color:#00D">2</span>**n }                       // <b class="conum">(2)</b>

println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2^6==</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>power(<span style="color:#00D">6</span>)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>                      // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>脚本开始</p>
</li>
<li>
<p>方法在脚本主体中定义</p>
</li>
<li>
<p>脚本继续</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>语句1和3有时被称为“松散”语句。它们不包含在显式的封闭方法或类中。松散语句会按顺序组装到run方法中。</p>
</div>
<div class="paragraph">
<p>因此，上述代码在内部被转换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.runtime.InvokerHelper</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Main</span> <span style="color:#088;font-weight:bold">extends</span> Script {
    <span style="color:#339;font-weight:bold">int</span> power(<span style="color:#339;font-weight:bold">int</span> n) { <span style="color:#00D">2</span>** n}                   // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>() {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello</span><span style="color:#710">'</span></span>                         // <b class="conum">(2)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2^6==</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>power(<span style="color:#00D">6</span>)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>              // <b class="conum">(3)</b>
    }
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> main(<span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> args) {
        InvokerHelper.runScript(Main, args)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>power</code> 方法按原样复制到生成的脚本类中</p>
</li>
<li>
<p>第一条语句被复制到 run 方法中</p>
</li>
<li>
<p>第二条语句被复制到 run 方法中</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
即使 Groovy 从您的脚本创建一个类，它对用户来说也是完全透明的。特别是，脚本被编译为字节码，并保留行号。这意味着，如果脚本中引发异常，堆栈跟踪将显示与原始脚本相对应的行号，而不是我们显示的生成代码。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_变量"><a class="link" href="#_变量">3.3.4. 变量</a></h4>
<div class="paragraph">
<p>脚本中的变量不需要类型定义。这意味着该脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> x = <span style="color:#00D">1</span>
<span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> x+y == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其行为将与以下内容相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">x = <span style="color:#00D">1</span>
y = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> x+y == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，两者之间存在语义差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果变量按照第一个示例中的方式声明，则它是 <em>局部变量</em> 。它将在编译器生成的 <code>run</code> 方法中声明，并且在脚本主体之外不可见。特别是，这样的变量在脚本的其他方法中将不可见</p>
</li>
<li>
<p>如果变量未声明，它将进入 gapi:groovy.lang.Script#getBinding()[script binding] 。绑定从方法中可见，如果您使用脚本与应用程序交互并且需要在脚本和应用程序之间共享数据，则绑定尤其重要。读者可以参阅<a href="guide-integrating.html#_integrating_groovy_in_a_java_application">集成指南</a>以获取更多信息。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
使变量对所有方法可见的另一种方法是使用 <code>@Field</code> 注释。以这种方式注释的变量将成为生成的脚本类的字段，并且对于局部变量，访问不会涉及脚本 <code>Binding</code> 。虽然不推荐，但如果您有与绑定变量同名的局部变量或脚本字段，则可以使用 <code>binding.varName</code> 访问绑定变量。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_convenience_variations"><a class="link" href="#_convenience_variations">3.3.5. Convenience variations</a></h4>
<div class="paragraph">
<p>正如之前提到的，通常情况下，<code>public static void main</code> 和 <code>run</code> 方法会被自动添加到您的脚本中，因此通常不允许添加您自己版本；如果尝试这样做，您将看到一个重复方法的编译错误。</p>
</div>
<div class="paragraph">
<p>然而，有一些例外情况，不适用上述规则。如果您的脚本仅包含与主兼容的主方法而没有其他松散语句，或者仅包含无参数的 <code>run</code> 实例方法（从Groovy 5开始），那么是允许的。在这种情况下，没有松散语句（因为没有任何松散语句）会被收集到 <code>run</code> 方法中。您提供的方法将被用来替代Groovy自动添加的相应方法。</p>
</div>
<div class="paragraph">
<p>如果需要向隐式添加的 main 或 run 方法添加注释，这就很有用，正如下面的例子所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@CompileStatic</span>
<span style="color:#088;font-weight:bold">static</span> main(args) {
    println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy world!</span><span style="color:#710">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了被识别为方便变体，并且没有松散语句，<code>main</code> 方法的参数应该是：</p>
</div>
<div class="paragraph">
<p>与上面一样是无类型的（ <code>Object</code> 类型），
或者是类型为 <code>String[]</code>，
或者是没有参数的（从Groovy 5开始）。
从Groovy 5开始，还支持不带参数的 <code>run</code> 实例变体。这也允许添加注解。<code>run</code> 变体遵循 <code>JEP 445</code> 中关于字段声明的规则（因此不需要使用 @Field 注解），正如涉及到Jackson JSON序列化的以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@JsonIgnoreProperties</span>([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">binding</span><span style="color:#710">&quot;</span></span>])
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>() {
    <span style="color:#339;font-weight:bold">var</span> mapper = <span style="color:#080;font-weight:bold">new</span> ObjectMapper()
    <span style="color:#080;font-weight:bold">assert</span> mapper.writeValueAsString(<span style="color:#950">this</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">{&quot;pets&quot;:[&quot;cat&quot;,&quot;dog&quot;]}</span><span style="color:#710">'</span></span>
}

<span style="color:#088;font-weight:bold">public</span> pets = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">cat</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">dog</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的脚本需要扩展Script类并访问脚本上下文和绑定，建议使用run 变体。如果您没有这个要求，提供 main 变体之一将创建一个兼容 JEP 445 的类，该类不会扩展 Script。接下来我们将更详细地介绍 JEP 445 兼容的脚本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jep_445_compatible_scripts"><a class="link" href="#_jep_445_compatible_scripts">3.4. JEP 445 compatible scripts</a></h3>
<div class="paragraph">
<p>从Groovy 5开始，添加了对包含 main 方法的 JEP 445 兼容脚本的支持。这样的脚本与普通的Groovy Script类有一些区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它们不会添加 public static void main 方法</p>
</li>
<li>
<p>它们不会扩展 Script 类，因此无法访问脚本上下文或绑定变量</p>
</li>
<li>
<p>允许在 main 之外定义额外的类级别的 字段 和 方法，除了 main</p>
</li>
<li>
<p>不能在 main 方法之外有"松散"语句（不包括任何字段定义）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个简单的例子可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">void</span> main(args) {
    println <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个包含额外字段和方法的例子可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">main</span>() {
    <span style="color:#080;font-weight:bold">assert</span> upper(foo) + lower(bar) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">FOObar</span><span style="color:#710">'</span></span>
}

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">upper</span>(s) { s.toUpperCase() }

<span style="color:#080;font-weight:bold">def</span> lower = <span style="color:#0a8;font-weight:bold">String</span>::toLowerCase
<span style="color:#080;font-weight:bold">def</span> (foo, bar) = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bar</span><span style="color:#710">'</span></span>]      // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>请注意，多重赋值语法是受支持的，并导致为每个组件生成单独的字段定义。</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_与java_jep_445行为的差异"><a class="link" href="#_与java_jep_445行为的差异">3.4.1. 与Java JEP 445行为的差异</a></h4>
<div class="paragraph">
<p>Groovy的JEP 445支持与Java的支持存在一些差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java支持无参数的main方法或包含单个String[]参数的方法。
Groovy还添加了对单一无类型（<code>Object</code> ）参数的支持，例如 <code>def main(args) { &#8230;&#8203; }</code>
This addition is known by the Groovy runner but would not be known by the
Java launch protocol for a JDK supporting JEP 445.</p>
</li>
<li>
<p>Java支持 <code>void</code> 的主方法。Groovy还添加了对无类型 <code>def（Object）</code> 方法的支持，例如 <code>def main(&#8230;&#8203;)</code> 以及 <code>void main(&#8230;&#8203;)</code> 。
This addition is known by the Groovy runner but would not be known by the Java launch protocol
for a JDK supporting JEP 445.</p>
</li>
<li>
<p>For static <code>main</code> variants, Groovy <em>promotes</em> the no-arg or untyped variants to have the
standard <code>public static void main(String[] args)</code> signature. This is for compatibility
with versions of Groovy prior to Groovy 5 (where JEP 445 support was added).
As a consequence, such classes are compatible with the Java launch protocol prior to JEP 445 support.</p>
</li>
<li>
<p>Groovy&#8217;s runner has been made aware of JEP 445 compatible classes and can run all variations
for JDK11 and above and without the need for preview mode to be enabled.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_object_orientation"><a class="link" href="#_object_orientation">4. Object orientation</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers the object-oriented aspects of the Groovy programming language.</p>
</div>
<div class="sect2">
<h3 id="_类型"><a class="link" href="#_类型">4.1. 类型</a></h3>
<div class="sect3">
<h4 id="_基本类型"><a class="link" href="#_基本类型">4.1.1. 基本类型</a></h4>
<div class="paragraph">
<p>Groovy 支持 <a href="https://docs.oracle.com/javase/specs/jls/se14/html/">Java Language Specification</a> 相同的基本类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整数类型： <code>byte</code> （8 位）、 <code>short</code> （16 位）、 <code>int</code> （32 位）和 <code>long</code> （64 位）</p>
</li>
<li>
<p>浮点类型： <code>float</code> （32 位）和 <code>double</code> （64 位）</p>
</li>
<li>
<p><code>boolean</code> 类型（ <code>true</code> 或 <code>false</code> 之一）</p>
</li>
<li>
<p><code>char</code> 类型（16 位，可用作数字类型，表示 UTF-16 代码）
与 Java 一样，当需要与任何基本类型相对应的对象时，Groovy 使用相应的包装类：</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. 基础类型包装类</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">基础类型</th>
<th class="tableblock halign-left valign-top">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Character</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>例如，当调用需要包装类的方法并将原始变量作为参数传递给它时，就会发生自动装箱和拆箱，反之亦然。这与 Java 类似，但 Groovy 更进一步地发展了这个想法。
在大多数情况下，您可以像对待包装器一样对待基础类。例如，您可以在基础类上调用 <code>.toString()</code> 或 <code>.equals(other)</code> 。 Groovy 根据需要在包装类和基础类之间自动包装和展开。</p>
</div>
<div class="paragraph">
<p>下面是一个使用 int 的示例，它被声明为类中的静态字段（稍后讨论）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> {
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">int</span> i
}

<span style="color:#080;font-weight:bold">assert</span> Foo.class.getDeclaredField(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">i</span><span style="color:#710">'</span></span>).type == <span style="color:#339;font-weight:bold">int</span>.class           //<b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> Foo.i.class != <span style="color:#339;font-weight:bold">int</span>.class &amp;&amp; Foo.i.class == <span style="color:#0a8;font-weight:bold">Integer</span>.class    //<b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>基础类型保留在字节码中</p>
</li>
<li>
<p>在运行时查看该字段表明它已被自动包装</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在您可能会担心，这意味着每次您对基础类型的引用使用数学运算符时，都会产生拆箱和重新装箱基础类型的成本。但事实并非如此，因为 Groovy 会将您的运算符编译为其<a href="core-operators.html#Operator-Overloading">等效方法</a>并使用它们。此外，当调用接收基础类型参数的 Java 方法时，Groovy 将自动拆箱为基础类，并自动对方法返回的基础类型进行装箱。但是，请注意，与 Java 的方法解析存在一些<a href="../core-differences-java.html#_primitives_and_wrappers">差异</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_引用类型"><a class="link" href="#_引用类型">4.1.2. 引用类型</a></h4>
<div class="paragraph">
<p>除了基础类型之外，其他一切都是对象，并且有定义其类型的关联类。我们将很快讨论类以及与类相关或类似类的事物，例如接口、特征和记录。</p>
</div>
<div class="paragraph">
<p>我们可以声明两个类型为 String 和 List 的变量，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> movie = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">The Matrix</span><span style="color:#710">'</span></span>
<span style="color:#0a8;font-weight:bold">List</span> actors = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Keanu Reeves</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hugo Weaving</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generics"><a class="link" href="#generics">4.1.3. 泛型</a></h4>
<div class="paragraph">
<p>Groovy 在泛型方面与 Java 具有相同的概念。定义类和方法时，可以使用类型参数并创建泛型类、接口、方法或构造函数。</p>
</div>
<div class="paragraph">
<p>泛型类和方法的使用，无论它们是在 Java 还是 Groovy 中定义的，都可能涉及提供类型参数。</p>
</div>
<div class="paragraph">
<p>我们可以声明一个 “字符串列表” 类型的变量，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt; roles = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Trinity</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Morpheus</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java 采用类型擦除来向后兼容早期版本的 Java。 Dynamic Groovy 可以被认为是更积极地应用类型擦除。一般来说，编译时会检查的泛型类型信息较少。 Groovy 的静态特性在泛型信息方面采用了与 Java 类似的检查。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类"><a class="link" href="#_类">4.2. 类</a></h3>
<div class="paragraph">
<p>Groovy 类与 Java 类非常相似，并且在 JVM 级别与 Java 类兼容。它们可能有方法、字段和属性（类似 JavaBeans 属性，但样板代码较少）。类和类成员可以具有与 Java 中相同的修饰符（public、protected、private、static 等），但在源代码级别有一些细微的差异，稍后将对此进行解释。</p>
</div>
<div class="paragraph">
<p>Groovy 类与其 Java 类之间的主要区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>没有可见性修饰符的类或方法自动是公共的</strong> （可以使用特殊的注解来实现包私有可见性）。</p>
</li>
<li>
<p><strong>没有可见性修饰符的字段会自动转换为属性，从而减少冗长的代码，因为不需要显式的 getter 和 setter 方法</strong>。有关这方面的更多信息将在<a href="#fields">字段和属性部分</a>中介绍。</p>
</li>
<li>
<p><strong>类不需要与其源文件定义具有相同的基本名称</strong>，但在大多数情况下强烈建议这样做（另请参阅有关脚本的下一点）。</p>
</li>
<li>
<p>一个源文件可能包含一个或多个类（但如果文件包含任何不在类中的代码，则将其视为脚本）。脚本只是具有一些特殊约定的类，并且与其源文件具有相同的名称（因此不要在与脚本源文件同名的脚本中包含类定义）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码提供了一个示例类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {                       //<b class="conum">(1)</b>

    <span style="color:#0a8;font-weight:bold">String</span> name                      //<b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">Integer</span> age

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">increaseAge</span>(<span style="color:#0a8;font-weight:bold">Integer</span> years) { //<b class="conum">(3)</b>
        <span style="color:#950">this</span>.age += years
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类以名称 <code>Person</code> 开头</p>
</li>
<li>
<p>名为 <code>name</code> 的字符串字段和属性</p>
</li>
<li>
<p>方法定义</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_普通类"><a class="link" href="#_普通类">4.2.1. 普通类</a></h4>
<div class="paragraph">
<p>普通类是指顶层的、具体的类。这意味着它们可以被实例化，而不受任何其他类或脚本的限制。这样，它们只能是公开的（即使 <code>public</code> 关键字可能被抑制）。类是通过使用 <code>new</code> 关键字调用其构造函数来实例化的，如以下代码片段所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_内部类"><a class="link" href="#_内部类">4.2.2. 内部类</a></h4>
<div class="paragraph">
<p>内部类是在另一个类中定义的。封闭类可以像往常一样使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的。封闭类以外的类不允许访问内部类。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Outer</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> privateStr

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">callInnerMethod</span>() {
        <span style="color:#080;font-weight:bold">new</span> Inner().methodA()       //<b class="conum">(1)</b>
    }

    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Inner</span> {                   //<b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">methodA</span>() {
            println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>privateStr<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span> //<b class="conum">(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>内部类被实例化并调用其方法</p>
</li>
<li>
<p>内部类定义，位于其封闭类内部</p>
</li>
<li>
<p>即使是私有的，封闭类的字段也可以由内部类访问</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用内部类有一些原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过对其他类隐藏内部类来增加封装性，其他类不需要知道它。这也导致了更清洁的软件包和工作空间。</p>
</li>
<li>
<p>它们通过将仅由一个类使用的类分组来提供良好的组织。</p>
</li>
<li>
<p>们会导致更易于维护的代码，因为内部类靠近使用它们的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>内部类通常会实现一些外部类的方法所需要的接口。下面的代码说明了这种典型的使用模式，此处与线程一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Outer2</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> privateStr = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">some string</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">startThread</span>() {
       <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Thread</span>(<span style="color:#080;font-weight:bold">new</span> Inner2()).start()
    }

    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Inner2</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Runnable</span> {
        <span style="color:#339;font-weight:bold">void</span> run() {
            println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>privateStr<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，类 <code>Inner2</code> 的定义只是为了向类 <code>Outer2</code> 提供方法 <code>run</code> 的实现。在这种情况下，匿名内部类有助于消除冗长的内容。我们很快就会讨论这个主题。</p>
</div>
<div class="paragraph">
<p>Groovy 3+ 还支持非静态内部类实例化的 Java 语法，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Computer</span> {
    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Cpu</span> {
        <span style="color:#339;font-weight:bold">int</span> coreNumber

        Cpu(<span style="color:#339;font-weight:bold">int</span> coreNumber) {
            <span style="color:#950">this</span>.coreNumber = coreNumber
        }
    }
}

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">4</span> == <span style="color:#080;font-weight:bold">new</span> Computer().new Cpu(<span style="color:#00D">4</span>).coreNumber</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_匿名内部类"><a class="link" href="#_匿名内部类">4.2.2.1. 匿名内部类</a></h5>
<div class="paragraph">
<p>前面的内部类示例 ( <code>Inner2</code> ) 可以使用匿名内部类进行简化。使用以下代码可以实现相同的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Outer3</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> privateStr = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">some string</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">startThread</span>() {
        <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Thread</span>(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Runnable</span>() {      //<b class="conum">(1)</b>
            <span style="color:#339;font-weight:bold">void</span> run() {
                println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>privateStr<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span>
            }
        }).start()                       //<b class="conum">(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>与上一节的最后一个示例相比， <code>new Inner2()</code> 及其所有实现都被替换为 <code>new Runnable()</code></p>
</li>
<li>
<p>方法 start 被正常调用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，不需要定义一个只使用一次的新类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_抽象类"><a class="link" href="#_抽象类">4.2.2.2. 抽象类</a></h5>
<div class="paragraph">
<p>抽象类代表通用概念，因此它们不能被实例化，也不能被创建为子类。它们的成员包括字段/属性和抽象或具体方法。抽象方法没有具体的实现，必须由具体的子类实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Abstract</span> {         //<b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name

    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">abstractMethod</span>() //<b class="conum">(2)</b>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">concreteMethod</span>() {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">concrete</span><span style="color:#710">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>抽象类必须使用 <code>abstract</code> 关键字声明</p>
</li>
<li>
<p>抽象方法也必须用 <code>abstract</code> 关键字声明</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>抽象类通常与接口进行比较。选择其中之一至少有两个重要的区别。首先，抽象类可以包含字段/属性和具体方法，但接口仅包含抽象方法（方法签名）。此外，一个类可以实现多个接口，而它只能扩展一个类，无论是否是抽象类。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_继承"><a class="link" href="#_继承">4.2.3. 继承</a></h4>
<div class="paragraph">
<p>Groovy 中的继承类似于 Java 中的继承。它为子类（或子类）提供了一种重用父类（或超类）的代码或属性的机制。
通过继承相关的类形成继承层次结构。常见的行为和成员被推到层次结构中以减少重复。</p>
</div>
</div>
<div class="sect3">
<h4 id="superclass"><a class="link" href="#superclass">4.2.4. 父类</a></h4>
<div class="paragraph">
<p>父类与子类共享可见的字段、属性或方法。一个子类最多可以有一个父类。 <code>extends</code> 关键字紧接在超类类型之前。</p>
</div>
</div>
<div class="sect3">
<h4 id="interfaces"><a class="link" href="#interfaces">4.2.5. Interfaces</a></h4>
<div class="paragraph">
<p>接口定义了类需要遵守的合约。接口只定义了需要实现的方法列表，但没有定义方法的实现。</p>
</div>
<div class="paragraph">
<p>下面是一个 <code>Greeter</code> 接口, 只定义了一个 <code>greet</code> 方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Greeter {                                         // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">void</span> greet(<span style="color:#0a8;font-weight:bold">String</span> name)                                 // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>需要使用 <code>interface</code> 关键字声明接口</p>
</li>
<li>
<p>接口仅定义方法签名</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>接口的方法始终是 <code>public</code> 的。在接口中使用 <code>protected</code> 或 <code>private</code> 方法是错误的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Greeter {
    <span style="color:#088;font-weight:bold">protected</span> <span style="color:#339;font-weight:bold">void</span> greet(<span style="color:#0a8;font-weight:bold">String</span> name)                       // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 <code>protected</code> 是一个编译时错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果一个类在其 <code>implements</code> 列表中定义了接口，或者它的任何超类定义了该接口，则该类实现了该接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SystemGreeter</span> <span style="color:#088;font-weight:bold">implements</span> Greeter {                    // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">void</span> greet(<span style="color:#0a8;font-weight:bold">String</span> name) {                               // <b class="conum">(2)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span>
    }
}

<span style="color:#080;font-weight:bold">def</span> greeter = <span style="color:#080;font-weight:bold">new</span> SystemGreeter()
<span style="color:#080;font-weight:bold">assert</span> greeter <span style="color:#080;font-weight:bold">instanceof</span> Greeter                           // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>SystemGreeter</code> 使用 <code>implements</code> 关键字声明 <code>Greeter</code> 接口</p>
</li>
<li>
<p>然后实现所需的 <code>greet</code> 方法</p>
</li>
<li>
<p><code>SystemGreeter</code> 的任何实例也是 <code>Greeter</code> 接口的实例</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>一个接口可以扩展另一个接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> ExtendedGreeter <span style="color:#088;font-weight:bold">extends</span> Greeter {                 // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">void</span> sayBye(<span style="color:#0a8;font-weight:bold">String</span> name)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>ExtendedGreeter</code> 接口使用 <code>extends</code> 关键字扩展 <code>Greeter</code> 接口</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值得注意的是，要使类成为接口的实例，它必须显式使用 <code>implements</code> 。例如，以下类定义了在 <code>Greeter</code> 接口中声明的 <code>greet</code> 方法，但没有在其接口中声明 <code>Greeter</code> ：`</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">DefaultGreeter</span> {
    <span style="color:#339;font-weight:bold">void</span> greet(<span style="color:#0a8;font-weight:bold">String</span> name) { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span> }
}

greeter = <span style="color:#080;font-weight:bold">new</span> DefaultGreeter()
<span style="color:#080;font-weight:bold">assert</span> !(greeter <span style="color:#080;font-weight:bold">instanceof</span> Greeter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，Groovy 没有定义结构类型(structural typing)。然而，可以使用 <code>as</code> 强制运算符使对象实例在运行时实现接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">greeter = <span style="color:#080;font-weight:bold">new</span> DefaultGreeter()                              // <b class="conum">(1)</b>
coerced = greeter <span style="color:#080;font-weight:bold">as</span> Greeter                                // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> coerced <span style="color:#080;font-weight:bold">instanceof</span> Greeter                           // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个不实现该接口的 DefaultGreeter 实例</p>
</li>
<li>
<p>在运行时将实例强制转换为 Greeter</p>
</li>
<li>
<p>强制实例实现 Greeter 接口</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可以看到有两个不同的对象：一个是源对象，DefaultGreeter 实例，它没有实现该接口。另一个是委托给强制对象的 Greeter 实例。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Groovy <a href="#_traits">traits</a> 与接口类似, 但是比接口更强大:
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>接口中只能包含default method和抽象方法(Java中的接口还可以包含static method, 但是groovy中的接口不行)</p>
</li>
<li>
<p>特质出了不能直接创建对象, 和普通类一样</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类成员"><a class="link" href="#_类成员">4.3. 类成员</a></h3>
<div class="sect3">
<h4 id="_构造函数"><a class="link" href="#_构造函数">4.3.1. 构造函数</a></h4>
<div class="paragraph">
<p>构造函数是用于初始化具有特定状态的对象的特殊方法。与普通方法一样，一个类可以声明多个构造函数，只要每个构造函数都有唯一的类型签名。如果一个对象在构造过程中不需要任何参数，它可以使用无参数构造函数。如果未提供构造函数，Groovy 编译器将提供一个空的无参数构造函数。</p>
</div>
<div class="paragraph">
<p>Groovy 支持两种调用方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>位置参数的使用方式与使用 Java 构造函数的方式类似</p>
</li>
<li>
<p>命名参数允许您在调用构造函数时指定参数名称。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_位置参数"><a class="link" href="#_位置参数">4.3.1.1. 位置参数</a></h5>
<div class="paragraph">
<p>要使用位置参数创建对象，相应的类需要声明一个或多个构造函数。在有多个构造函数的情况下，每个构造函数都必须具有唯一的类型签名。还可以使用 <code>groovy.transform.TupleConstructor</code> 注解将构造函数添加到类中。</p>
</div>
<div class="paragraph">
<p>通常，<strong>一旦声明了至少一个构造函数，则只能通过调用其构造函数来实例化该类。值得注意的是，在这种情况下，您通常无法创建带有命名参数的类</strong>。</p>
</div>
<div class="paragraph">
<p><strong>Groovy 确实支持命名参数，只要该类包含无参数构造函数或提供将 <code>Map</code> 参数作为第一个（也可能是唯一的）参数的构造函数</strong> - 请参阅下一节了解详细信息。</p>
</div>
<div class="paragraph">
<p>使用声明的构造函数有三种形式。第一种是普通的 Java 方式，使用 new 关键字。其他依赖于将列表强制转换为所需类型。在这种情况下，可以使用 as 关键字并通过静态键入变量来进行强制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">PersonConstructor</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#0a8;font-weight:bold">Integer</span> age

    PersonConstructor(name, age) {          //<b class="conum">(1)</b>
        <span style="color:#950">this</span>.name = name
        <span style="color:#950">this</span>.age = age
    }
}

<span style="color:#080;font-weight:bold">def</span> person1 = <span style="color:#080;font-weight:bold">new</span> PersonConstructor(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#00D">1</span>)  //<b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> person2 = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#00D">2</span>] <span style="color:#080;font-weight:bold">as</span> PersonConstructor  //<b class="conum">(3)</b>
PersonConstructor person3 = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#00D">3</span>]         //<b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>构造函数声明</p>
</li>
<li>
<p>构造函数调用，经典Java方式</p>
</li>
<li>
<p>构造函数的使用，使用带有 <code>as</code> 关键字的强制转换</p>
</li>
<li>
<p>构造函数的使用，在赋值中使用强制</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_命名参数"><a class="link" href="#_命名参数">4.3.1.2. 命名参数</a></h5>
<div class="paragraph">
<p><strong>如果没有声明构造函数, 或者声明了无参构造函数，则可以通过以 <code>Map</code>（属性/值对）的形式传递参数来创建对象</strong>。当人们想要允许多种参数组合的情况下，这会很方便。否则，通过使用传统的位置参数，有必要声明所有可能的构造函数。</p>
</div>
<div class="paragraph">
<p><strong>命名参数也支持第一个（也许是唯一）参数为 Map 参数的构造函数</strong> - 也可以使用 <code>groovy.transform.MapConstructor</code> 注解添加这样的构造函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">PersonWOConstructor</span> {                                  //<b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#0a8;font-weight:bold">Integer</span> age
}

<span style="color:#080;font-weight:bold">def</span> person4 = <span style="color:#080;font-weight:bold">new</span> PersonWOConstructor()                      //<b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> person5 = <span style="color:#080;font-weight:bold">new</span> PersonWOConstructor(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>)         //<b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> person6 = <span style="color:#080;font-weight:bold">new</span> PersonWOConstructor(<span style="color:#606">age</span>: <span style="color:#00D">1</span>)                //<b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">def</span> person7 = <span style="color:#080;font-weight:bold">new</span> PersonWOConstructor(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">2</span>) //<b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>没有声明构造函数</p>
</li>
<li>
<p>实例化时没有给出参数</p>
</li>
<li>
<p>实例化中给出 name 的参数</p>
</li>
<li>
<p>实例化中给出 age 的参数</p>
</li>
<li>
<p>实例化中给出 age 和 name 的参数</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然而，需要强调的是，这种方法为构造函数调用者提供了更多的权力，同时对调用者施加了更多的责任来确保名称和值类型正确。因此，如果需要更好的控制，那么使用位置参数声明构造函数可能是首选。</p>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>虽然上面的示例未提供构造函数，但您还可以提供无参数构造函数或第一个参数为 <code>Map</code> 的构造函数，最常见的是它是唯一的参数。</p>
</li>
<li>
<p>当未声明构造函数时, 或者声明了无参构造函数，Groovy 将调用无参数构造函数，然后调用每个传入的命名参数的 setter。</p>
</li>
<li>
<p>当第一个参数是 <code>Map</code> 时，Groovy 将所有命名参数组合到一个 <code>Map</code> 中（无论顺序如何），并将该映射提供为第一个参数。如果您的属性被声明为 <code>final</code> （因为它们将在构造函数中设置，而不是在事后使用setter设置），那么这可能是一个好方法。</p>
</li>
<li>
<p>您可以通过提供位置构造函数以及无参数或 Map 构造函数来支持命名构造函数和位置构造函数。</p>
</li>
<li>
<p>您可以通过使用第一个参数是 Map 但还有其他位置参数的构造函数来支持混合构造。谨慎使用这种风格。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_方法_2"><a class="link" href="#_方法_2">4.3.2. 方法</a></h4>
<div class="paragraph">
<p>Groovy 方法与其他语言非常相似。一些特性将在下一小节中显示。</p>
</div>
<div class="sect4">
<h5 id="_方法定义"><a class="link" href="#_方法定义">4.3.2.1. 方法定义</a></h5>
<div class="paragraph">
<p>使用*返回类型*定义方法或使用 <code>def</code> 关键字定义方法以使返回类型成为非类型化。</p>
</div>
<div class="paragraph">
<p>方法还可以接收任意数量的参数，这些参数可能没有显式声明其类型。</p>
</div>
<div class="paragraph">
<p>Java修饰符可以正常使用，如果没有提供可见性修饰符，则该方法是 <code>public</code> 的。</p>
</div>
<div class="paragraph">
<p>Groovy 中的方法总是返回一些值。如果未提供 <code>return</code> 语句，则将返回在执行的最后一行中计算的值。例如，请注意以下方法均不使用 <code>return</code> 关键字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">someMethod</span>() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">method called</span><span style="color:#710">'</span></span> }                           //<b class="conum">(1)</b>
<span style="color:#0a8;font-weight:bold">String</span> anotherMethod() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">another method called</span><span style="color:#710">'</span></span> }             //<b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">thirdMethod</span>(param1) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>param1</span><span style="color:#D20"> passed</span><span style="color:#710">&quot;</span></span> }                   //<b class="conum">(3)</b>
<span style="color:#088;font-weight:bold">static</span> <span style="color:#0a8;font-weight:bold">String</span> fourthMethod(<span style="color:#0a8;font-weight:bold">String</span> param1) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>param1</span><span style="color:#D20"> passed</span><span style="color:#710">&quot;</span></span> } //<b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>未声明返回类型且无参数的方法</p>
</li>
<li>
<p>具有显式返回类型且无参数的方法</p>
</li>
<li>
<p>带有未定义类型的参数的方法</p>
</li>
<li>
<p>带有字符串参数的静态方法</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_命名参数_2"><a class="link" href="#_命名参数_2">4.3.2.2. 命名参数</a></h5>
<div class="paragraph">
<p>与构造函数一样，普通方法也可以使用命名参数来调用。为了支持这种表示法，使用了一种约定，其中方法的第一个参数是 Map 。在方法主体中，可以像普通map ( map.key ) 中一样访问参数值。如果该方法只有一个 <code>Map</code> 参数，则必须命名所有提供的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Map</span> args) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.age<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
foo(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">1</span>)</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_混合命名参数和位置参数"><a class="link" href="#_混合命名参数和位置参数">混合命名参数和位置参数</a></h6>
<div class="paragraph">
<p>命名参数可以与位置参数混合。在这种情况下，除了作为第一个参数的 Map 参数之外，方法将根据需要具有其他位置参数。调用方法时提供的位置参数必须按顺序排列。命名参数可以位于任何位置。它们被合并到map中并自动作为第一个参数传递。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Map</span> args, <span style="color:#0a8;font-weight:bold">Integer</span> number) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.age<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, and the number is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>number<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
foo(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">1</span>, <span style="color:#00D">23</span>)  //<b class="conum">(1)</b>
foo(<span style="color:#00D">23</span>, <span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">1</span>)  //<b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 Integer 类型的附加 number 参数调用方法</p>
</li>
<li>
<p>改变参数顺序的方法调用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果不是 <code>Map</code> 作为第一个参数，则必须为该参数提供 Map 而不是命名参数。如果不这样做将导致 <code>groovy.lang.MissingMethodException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Integer</span> number, <span style="color:#0a8;font-weight:bold">Map</span> args) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.age<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, and the number is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>number<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
foo(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">1</span>, <span style="color:#00D">23</span>)  //<b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>方法调用抛出 <code>groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23]</code> ，因为命名参数 Map 不是第一个参数</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果我们用显式的 <code>Map</code> 参数替换命名参数，则可以避免上述异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Integer</span> number, <span style="color:#0a8;font-weight:bold">Map</span> args) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>args.age<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, and the number is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>number<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
foo(<span style="color:#00D">23</span>, [<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">1</span>])  //<b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>显式 Map 参数代替命名参数使调用有效</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
尽管 Groovy 允许您混合命名参数和位置参数，但它可能会导致不必要的混乱。谨慎混合命名参数和位置参数。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_默认参数"><a class="link" href="#_默认参数">4.3.2.3. 默认参数</a></h5>
<div class="paragraph">
<p>默认参数使参数可选。如果未提供参数，则该方法采用默认值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">String</span> par1, <span style="color:#0a8;font-weight:bold">Integer</span> par2 = <span style="color:#00D">1</span>) { [<span style="color:#606">name</span>: par1, <span style="color:#606">age</span>: par2] }
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Marie</span><span style="color:#710">'</span></span>).age == <span style="color:#00D">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>参数从右侧删除，但强制参数永远不会删除。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">baz</span>(a = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>, <span style="color:#339;font-weight:bold">int</span> b, c = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>, <span style="color:#339;font-weight:bold">boolean</span> d, e = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">e</span><span style="color:#710">'</span></span>) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>a</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>b</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>c</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>d</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>e</span><span style="color:#710">&quot;</span></span> }

<span style="color:#080;font-weight:bold">assert</span> baz(<span style="color:#00D">42</span>, <span style="color:#069">true</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a 42 c true e</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> baz(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>, <span style="color:#069">true</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A 42 c true e</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> baz(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>, <span style="color:#069">true</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A 42 C true e</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> baz(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>, <span style="color:#069">true</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">E</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A 42 C true E</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的规则适用于构造函数和方法。如果使用 <code>@TupleConstructor</code> ，则应用其他配置选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="_可变参数"><a class="link" href="#_可变参数">4.3.2.4. 可变参数</a></h5>
<div class="paragraph">
<p>Groovy 支持具有可变数量参数的方法。它们的定义如下： <code>def foo(p1, &#8230;&#8203;, pn, T&#8230;&#8203; args)</code> 。这里 foo 默认支持 <code>n</code> 参数，但也支持超过 <code>n</code> 的未指定数量的其他参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span>... args) { args.length }
<span style="color:#080;font-weight:bold">assert</span> foo() == <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>) == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>) == <span style="color:#00D">2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>T此示例定义了一个方法 <code>foo</code> ，该方法可以采用任意数量的参数，包括根本不带参数。 <code>args.length</code> 将返回给定参数的数量。 Groovy 允许 <code>T[]</code> 作为 <code>T&#8230;&#8203;</code> 的替代表示法。这意味着任何以数组作为最后一个参数的方法都被 Groovy 视为可以采用可变数量参数的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span><span style="color:#339;font-weight:bold">[]</span> args) { args.length }
<span style="color:#080;font-weight:bold">assert</span> foo() == <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>) == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>) == <span style="color:#00D">2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>如果使用 <code>null</code> 作为 可变参数 来调用带有 可变参数 的方法，则参数将为 null 而不是长度为 1 且以 null 作为唯一参数的数组元素</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span>... args) { args }
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#069">null</span>) == <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用数组作为参数调用 可变参数方法，则参数将是该数组，而不是包含给定数组作为唯一元素的长度为 1 的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span>... args) { args }
<span style="color:#0a8;font-weight:bold">Integer</span><span style="color:#339;font-weight:bold">[]</span> ints = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>]
<span style="color:#080;font-weight:bold">assert</span> foo(ints) == [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个重要的点是可变参数与方法重载的结合。如果方法重载，Groovy 将选择最具体的方法。例如，如果方法 <code>foo</code> 采用 <code>T</code> 类型的 可变 参数，而另一个方法 <code>foo</code> 也采用 <code>T</code> 类型的参数，则第二种方法是首选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span>... args) { <span style="color:#00D">1</span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">foo</span>(<span style="color:#0a8;font-weight:bold">Object</span> x) { <span style="color:#00D">2</span> }
<span style="color:#080;font-weight:bold">assert</span> foo() == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>) == <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> foo(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>) == <span style="color:#00D">1</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_方法选择算法"><a class="link" href="#_方法选择算法">4.3.2.5. 方法选择算法</a></h5>
<div class="paragraph">
<p>Dynamic Groovy 支持 <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>（也称为多重方法）。调用方法时，实际调用的方法是根据方法参数的运行时类型动态确定的。首先将考虑方法名称和参数数量（包括允许可变参数），然后考虑每个参数的类型。考虑以下方法定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Object</span> o1, <span style="color:#0a8;font-weight:bold">Object</span> o2) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">o/o</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Integer</span> i, <span style="color:#0a8;font-weight:bold">String</span>  s) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">i/s</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">String</span>  s, <span style="color:#0a8;font-weight:bold">Integer</span> i) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s/i</span><span style="color:#710">'</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>也许正如预期的那样，使用 <code>String</code> 和 <code>Integer</code> 参数调用 <code>method</code> 会调用我们的第三个方法定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> method(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s/i</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里更有趣的是编译时类型未知的情况。也许参数被声明为 <code>Object</code> 类型（在我们的例子中是此类对象的列表）。 Java 将确定在所有情况下都将选择 <code>method(Object, Object)</code> 变体（除非使用强制转换），但如以下示例所示，Groovy 使用运行时类型并将调用每个方法一次（并且不进行类型转换）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">Object</span>&gt;&gt; pairs = [[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, <span style="color:#00D">1</span>], [<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>], [<span style="color:#00D">3</span>, <span style="color:#00D">4</span>]]
<span style="color:#080;font-weight:bold">assert</span> pairs.collect { a, b -&gt; method(a, b) } == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">s/i</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">i/s</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">o/o</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于三个方法调用中的前两个，都找到了参数类型的精确匹配。对于第三次调用，未找到 <code>method(Integer, Integer)</code> 的精确匹配，但 <code>method(Object, Object)</code> 仍然有效并将被选择。</p>
</div>
<div class="paragraph">
<p>方法选择就是从具有兼容参数类型的有效候选方法中找到最接近的拟合。因此， <code>method(Object, Object)</code> 对于前两次调用也有效，但不如类型完全匹配的变体那么接近匹配。为了确定最接近的拟合，运行时有一个实际参数类型与声明的参数类型之间的距离的概念，并尝试最小化所有参数的总距离。</p>
</div>
<div class="paragraph">
<p>下表说明了影响距离计算的一些因素。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Aspect</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">直接实现的接口比继承层次结构中更高层的接口匹配得更紧密。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>给定这些接口和方法定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> I1 {}
<span style="color:#339;font-weight:bold">interface</span> I2 <span style="color:#088;font-weight:bold">extends</span> I1 {}
<span style="color:#339;font-weight:bold">interface</span> I3 {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Clazz</span> <span style="color:#088;font-weight:bold">implements</span> I3, I2 {}

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(I1 i1) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">I1</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(I3 i3) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">I3</span><span style="color:#710">'</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>直接实现的接口将匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> method(<span style="color:#080;font-weight:bold">new</span> Clazz()) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">I3</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">对象数组优于对象。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Object</span><span style="color:#339;font-weight:bold">[]</span> arg) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">array</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Object</span> arg) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">object</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">assert</span> method(<span style="color:#339;font-weight:bold">[]</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Object</span><span style="color:#339;font-weight:bold">[]</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">array</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">非可变参数变体比可变参数变体更优。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">String</span> s, <span style="color:#0a8;font-weight:bold">Object</span>... vargs) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">vararg</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">String</span> s) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">non-vararg</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">assert</span> method(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">non-vararg</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果两个 vararg 变体适用，则首选使用最少数量的 vararg 参数的变体。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">String</span> s, <span style="color:#0a8;font-weight:bold">Object</span>... vargs) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">two vargs</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">String</span> s, <span style="color:#0a8;font-weight:bold">Integer</span> i, <span style="color:#0a8;font-weight:bold">Object</span>... vargs) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">one varg</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">assert</span> method(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, <span style="color:#00D">35</span>, <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">one varg</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口优先于超类。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> I {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Base</span> {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Child</span> <span style="color:#088;font-weight:bold">extends</span> Base <span style="color:#088;font-weight:bold">implements</span> I {}

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(Base b) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">superclass</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(I i) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">interface</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">assert</span> method(<span style="color:#080;font-weight:bold">new</span> Child()) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">interface</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于原始参数类型，首选相同或稍大的声明参数类型。</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Long</span> l) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Long</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Short</span> s) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Short</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">BigInteger</span> bi) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">BigInteger</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">assert</span> method(<span style="color:#00D">35</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Long</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在两个变体具有完全相同的距离的情况下，这被认为是不明确的并且将导致运行时异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Date</span> d, <span style="color:#0a8;font-weight:bold">Object</span> o) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d/o</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>(<span style="color:#0a8;font-weight:bold">Object</span> o, <span style="color:#0a8;font-weight:bold">String</span> s) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">o/s</span><span style="color:#710">'</span></span> }

<span style="color:#080;font-weight:bold">def</span> ex = shouldFail {
    println method(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>(), <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">baz</span><span style="color:#710">'</span></span>)
}
<span style="color:#080;font-weight:bold">assert</span> ex.message.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ambiguous method overloading</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用类型转换来选择所需的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> method(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>(), (<span style="color:#0a8;font-weight:bold">Object</span>)<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">baz</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">d/o</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> method((<span style="color:#0a8;font-weight:bold">Object</span>)<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>(), <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">baz</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">o/s</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_声明异常"><a class="link" href="#_声明异常">4.3.2.6. 声明异常</a></h5>
<div class="paragraph">
<p>Groovy 自动允许您像对待unchecked exceptions一样对待unchecked exceptions。这意味着您不需要声明方法可能抛出的任何已检查异常，如以下示例所示，如果未找到文件，该方法可能会抛出 <code>FileNotFoundException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">badRead</span>() {
    <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">File</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">doesNotExist.txt</span><span style="color:#710">'</span></span>).text
}

shouldFail(<span style="color:#C00;font-weight:bold">FileNotFoundException</span>) {
    badRead()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也不需要将对上例中的 badRead 方法的调用包含在 <code>try/catch</code> 块中 - 尽管您可以根据需要自由地这样做。</p>
</div>
<div class="paragraph">
<p>如果您希望声明代码可能抛出的任何异常（checked or otherwise），您可以随意这样做。添加异常不会改变代码在其他 Groovy 代码中的使用方式，但可以被视为代码文档。异常将成为字节码中方法声明的一部分，因此如果您的代码可能从 Java 调用，则包含它们可能会很有用。以下示例说明了如何使用显式检查异常声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">badRead</span>() <span style="color:#088;font-weight:bold">throws</span> <span style="color:#C00;font-weight:bold">FileNotFoundException</span> {
    <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">File</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">doesNotExist.txt</span><span style="color:#710">'</span></span>).text
}

shouldFail(<span style="color:#C00;font-weight:bold">FileNotFoundException</span>) {
    badRead()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字段和属性"><a class="link" href="#_字段和属性">4.3.3. 字段和属性</a></h4>
<div class="sect4">
<h5 id="fields"><a class="link" href="#fields">4.3.3.1. 字段</a></h5>
<div class="paragraph">
<p>字段用于存储数据, 是类、接口或特征的成员。 Groovy 中的字段具有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个必须得访问修饰符 (<code>public</code>, <code>protected</code>, or <code>private</code>)</p>
</li>
<li>
<p>一个或多个可选修饰符 (<code>static</code>, <code>final</code>, <code>synchronized</code>)</p>
</li>
<li>
<p>一个可选的类型</p>
</li>
<li>
<p>一个必选的名称</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Data</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">int</span> id                                  // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">protected</span> <span style="color:#0a8;font-weight:bold">String</span> description                    // <b class="conum">(2)</b>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">boolean</span> DEBUG = <span style="color:#069">false</span>       // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>名为 <code>id</code> 的 <code>private</code> 字段，类型为 <code>int</code></p>
</li>
<li>
<p>名为 <code>description</code> 的 <code>protected</code> 字段，类型为 <code>String</code></p>
</li>
<li>
<p>名为 <code>DEBU</code>、类型为 <code>boolean</code> 的 <code>public static final</code> 字段</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>字段可以直接在声明时初始化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Data</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> id = IDGenerator.next() // <b class="conum">(1)</b>
    <span style="color:#777">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>私有字段 id 用 <code>IDGenerator.next()</code> 初始化</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>可以省略字段的类型声明。然而，这被认为是一种不好的做法，一般来说，对字段使用强类型是一个好主意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">BadPractice</span> {
    <span style="color:#088;font-weight:bold">private</span> mapping                         // <b class="conum">(1)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">GoodPractice</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>,<span style="color:#0a8;font-weight:bold">String</span>&gt; mapping      // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>字段 <code>mapping</code> 未声明类型</p>
</li>
<li>
<p>字段 <code>mapping</code> 具有强类型</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您想使用可选的类型检查，则两者之间的区别很重要。作为类的设计文档，它也很重要。但是，在某些情况下（例如脚本编写或您想依赖鸭子类型），省略类型可能会很有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="properties"><a class="link" href="#properties">4.3.3.2. 属性</a></h5>
<div class="paragraph">
<p>属性是类的外部可见特征。 与使用公共字段来表示此功能（这提供了更有限的抽象并会限制重构的可能性）不同，Java中的经典实现是遵循 JavaBeans 规范中概述的约定，即使用以下组合来表示属性：private字段和 getter/setter。</p>
</div>
<div class="paragraph">
<p>Groovy 遵循这些相同的约定，但提供了一种更简单的方法来定义属性。您可以使用以下方式定义属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无需访问修饰符 (no <code>public</code>, <code>protected</code> or <code>private</code>)</p>
</li>
<li>
<p>一个或多个可选修饰符 (<code>static</code>, <code>final</code>, <code>synchronized</code>)</p>
</li>
<li>
<p>一个可选类型</p>
</li>
<li>
<p>一个必选的名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后 Groovy 将适当地生成 getter/setter。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name                             // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">int</span> age                                 // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个支持 <code>private String name</code> 字段、一个 <code>getName</code> 和一个 <code>setName</code> 方法</p>
</li>
<li>
<p>创建一个支持 <code>private int age</code> 字段、一个 <code>getAge</code> 和一个 <code>setAge</code> 方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果属性声明为 <code>final</code> ，则不会生成 setter：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> name                   // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">int</span> age                       // <b class="conum">(2)</b>
    Person(<span style="color:#0a8;font-weight:bold">String</span> name, <span style="color:#339;font-weight:bold">int</span> age) {
        <span style="color:#950">this</span>.name = name                // <b class="conum">(3)</b>
        <span style="color:#950">this</span>.age = age                  // <b class="conum">(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义类型 <code>String</code> 的只读属性</p>
</li>
<li>
<p>定义类型 <code>int</code> 的只读属性</p>
</li>
<li>
<p>将 <code>name</code> 参数分配给 <code>name</code> 字段</p>
</li>
<li>
<p>将 <code>age</code> 参数分配给 <code>age</code> 字段</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>属性通过名称访问，并且会透明地调用 <code>getter</code> 或 <code>setter</code> ，除非代码位于定义该属性的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">void</span> name(<span style="color:#0a8;font-weight:bold">String</span> name) {
        <span style="color:#950">this</span>.name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Wonder </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span>      // <b class="conum">(1)</b>
    }
    <span style="color:#0a8;font-weight:bold">String</span> title() {
        <span style="color:#950">this</span>.name                       // <b class="conum">(2)</b>
    }
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()
p.name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Diana</span><span style="color:#710">'</span></span>                        // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> p.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Diana</span><span style="color:#710">'</span></span>                // <b class="conum">(4)</b>
p.name(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Woman</span><span style="color:#710">'</span></span>)                         // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> p.title() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Wonder Woman</span><span style="color:#710">'</span></span>      // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>this.name</code> 将直接访问该字段，因为该属性是从定义它的类中访问的</p>
</li>
<li>
<p>类似地，读取访问是直接在 <code>name</code> 字段上完成的</p>
</li>
<li>
<p>对属性的写访问是在 <code>Person</code> 类外部完成的，因此它将隐式调用 <code>setName</code></p>
</li>
<li>
<p>对属性的读取访问是在 <code>Person</code> 类之外完成的，因此它将隐式调用 <code>getName</code></p>
</li>
<li>
<p>这将调用 <code>Person</code> 上的 <code>name</code> 方法，该方法执行对该字段的直接访问</p>
</li>
<li>
<p>这将调用 <code>Person</code> 上的 <code>title</code> 方法，该方法对字段执行直接读取访问</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值得注意的是，这种直接访问支持字段的行为是为了防止在定义属性的类中使用属性访问语法时出现堆栈溢出(调用属性自动转换到setter上, setter中调用属性有转到setter上)。</p>
</div>
<div class="paragraph">
<p>可以通过实例的 <code>properties</code> 属性来列出所有属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> age
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()
<span style="color:#080;font-weight:bold">assert</span> p.properties.keySet().containsAll([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">name</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">age</span><span style="color:#710">'</span></span>])</code></pre>
</div>
</div>
<div class="paragraph">
<p>按照惯例，即使没有支持字段，只要存在遵循 Java Beans 规范的 getter 或 setter，Groovy 也会识别属性。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">PseudoProperties</span> {
    <span style="color:#777">// a pseudo property &quot;name&quot;</span>
    <span style="color:#339;font-weight:bold">void</span> setName(<span style="color:#0a8;font-weight:bold">String</span> name) {}
    <span style="color:#0a8;font-weight:bold">String</span> getName() {}

    <span style="color:#777">// a pseudo read-only property &quot;age&quot;</span>
    <span style="color:#339;font-weight:bold">int</span> getAge() { <span style="color:#00D">42</span> }

    <span style="color:#777">// a pseudo write-only property &quot;groovy&quot;</span>
    <span style="color:#339;font-weight:bold">void</span> setGroovy(<span style="color:#339;font-weight:bold">boolean</span> groovy) {  }
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> PseudoProperties()
p.name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>                      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> p.age == <span style="color:#00D">42</span>                  // <b class="conum">(2)</b>
p.groovy = <span style="color:#069">true</span>                     // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>允许写入 p.name ，因为存在伪属性 name</p>
</li>
<li>
<p>允许读取 p.age ，因为存在伪只读属性 age</p>
</li>
<li>
<p>允许写入 p.groovy ，因为存在伪只写属性 groovy</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这种语法糖是许多用 Groovy 编写的 DSL 的核心。</p>
</div>
<div class="sect5">
<h6 id="_属性命名规范"><a class="link" href="#_属性命名规范">属性命名规范</a></h6>
<div class="paragraph">
<p>通常建议属性名称的前两个字母小写，对于多单词属性，使用驼峰式大小写。在这些情况下，生成的 <code>getter</code> 和 <code>setter</code> 的名称将通过将属性名称大写并添加 <code>get</code> 或 <code>set</code> 前缀（布尔 <code>getter</code> 的 <code>is</code> ）来形成。因此， <code>getLength</code> 将是 <code>length</code> 属性的 <code>getter</code> ，而 <code>setFirstName</code> 将是 <code>firstName</code> 属性的 <code>setter</code>。 <code>isEmpty</code> 可能是名为 <code>empty</code> 的属性的 <code>getter</code> 方法名称。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>以大写字母开头的属性名称将具有仅添加前缀的 getter/setter。因此，即使属性 <code>Foo</code> 不遵循建议的命名约定，也是允许的。对于此属性，访问器方法将为 <code>setFoo</code> 和 <code>getFoo</code> 。这样做的结果是不允许您同时拥有 <code>foo</code> 和 <code>Foo</code> 属性，因为它们将具有相同的命名访问器方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>JavaBeans 规范对通常可能是首字母缩略词的属性做了特殊处理。如果属性名称的前两个字母为大写，则不执行大写（或更重要的是，如果从访问器方法名称生成属性名称，则不执行小写）。因此， <code>getURL</code> 将是 <code>URL</code> 属性的 <code>getter</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于 JavaBeans 规范中特殊的“首字母缩略词处理”属性命名逻辑，属性名称的转换是不对称的。这会导致一些奇怪的边缘情况。 Groovy 采用了一种命名约定，避免了一种歧义，这种歧义可能看起来有点奇怪，但在 Groovy 设计时很流行，并且由于历史原因一直保留（到目前为止）。 Groovy 查看属性名称的第二个字母。如果这是大写字母，则该属性被视为首字母缩略词样式属性之一，并且不进行大写，否则进行正常大写。尽管我们从不推荐它，但它确实允许您拥有看似“重复命名”的属性，例如您可以有 <code>aProp</code> 和 <code>AProp</code> ，或 <code>pNAME</code> 和 <code>PNAME</code> 。 <code>getter</code> 分别是 <code>getaProp</code> 和 <code>getAProp</code> 以及 <code>getpNAME</code> 和 <code>getPNAME</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_属性的修饰符"><a class="link" href="#_属性的修饰符">属性的修饰符</a></h6>
<div class="paragraph">
<p>我们已经看到属性是通过省略可见性修饰符来定义的。一般来说，任何其他修饰符，例如 <code>transient</code> 将被复制到该字段。有两个特殊情况值得注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>final</code> ，我们之前看到的是只读属性，被复制到支持字段上，但也导致没有定义 setter</p>
</li>
<li>
<p><code>static</code> 被复制到支持字段，但也会导致访问器方法成为静态</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您希望将像 <code>final</code> 这样的修饰符也保留到访问器方法中，则可以手动编写属性或考虑使用<a href="#split-properties">拆分属性定义</a>。</p>
</div>
</div>
<div class="sect5">
<h6 id="_属性上的注解"><a class="link" href="#_属性上的注解">属性上的注解</a></h6>
<div class="paragraph">
<p>注解（包括与 AST 转换相关的注解）将被复制到属性的支持字段。这允许适用于字段的 AST 转换应用于属性，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Animal</span> {
    <span style="color:#339;font-weight:bold">int</span> lowerCount = <span style="color:#00D">0</span>
    <span style="color:#007">@Lazy</span> <span style="color:#0a8;font-weight:bold">String</span> name = { lower().toUpperCase() }()
    <span style="color:#0a8;font-weight:bold">String</span> lower() { lowerCount++; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sloth</span><span style="color:#710">'</span></span> }
}

<span style="color:#080;font-weight:bold">def</span> a = <span style="color:#080;font-weight:bold">new</span> Animal()
<span style="color:#080;font-weight:bold">assert</span> a.lowerCount == <span style="color:#00D">0</span>  // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> a.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">SLOTH</span><span style="color:#710">'</span></span>  // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> a.lowerCount == <span style="color:#00D">1</span>  // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>确认没有急切初始化</p>
</li>
<li>
<p>正常的财产访问</p>
</li>
<li>
<p>确认属性访问时才初始化</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="split-properties"><a class="link" href="#split-properties">使用显式支持字段拆分属性定义</a></h6>
<div class="paragraph">
<p>当您的类设计遵循某些与常见 JavaBean 实践一致的约定时，Groovy 的属性语法是一种方便的速记方式。如果您的类不完全符合这些约定，您当然可以像在 Java 中一样编写 getter、setter 和支持字段。</p>
</div>
<div class="paragraph">
<p>However, Groovy does provide a split definition capability which still provides a shortened syntax while allowing slight adjustments to the conventions. For a split definition, you write a field and a property with the same name and type. Only one of the field or property may have an initial value.</p>
</div>
<div class="paragraph">
<p>For split properties, annotations on the field remain on the backing field for the property. Annotations on the property part of the definition are copied onto the getter and setter methods.</p>
</div>
<div class="paragraph">
<p>This mechanism allows a number of common variations that property users may wish to use if the standard property definition doesn’t exactly fit their needs. For example, if the backing field should be <code>protected</code> rather than <code>private</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HasPropertyWithProtectedField</span> {
    <span style="color:#088;font-weight:bold">protected</span> <span style="color:#0a8;font-weight:bold">String</span> name  // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name            // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Protected backing field for name property instead of normal private one</p>
</li>
<li>
<p>Declare name property</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>或者，相同的示例，但具有包私有支持字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HasPropertyWithPackagePrivateField</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name                // <b class="conum">(1)</b>
    <span style="color:#007">@PackageScope</span> <span style="color:#0a8;font-weight:bold">String</span> name  // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Declare name property</p>
</li>
<li>
<p>Package-private backing field for name property instead of normal private one</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As a final example, we may wish to apply method-related AST transforms, or in general, any annotation to the setters/getters, e.g. to have the accessors be synchronized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HasPropertyWithSynchronizedAccessorMethods</span> {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> name        // <b class="conum">(1)</b>
    <span style="color:#007">@Synchronized</span> <span style="color:#0a8;font-weight:bold">String</span> name  // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Backing field for name property</p>
</li>
<li>
<p>Declare name property with annotation for setter/getter</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_显式的settergetter方法"><a class="link" href="#_显式的settergetter方法">显式的setter/getter方法</a></h6>
<div class="paragraph">
<p>如果类中明确定义了 getter 或 setter，则不会自动生成访问器方法。这允许您根据需要修改此类 getter 或 setter 的正常行为。通常不考虑继承的访问器方法，但如果继承的访问器方法被标记为最终的，这也将导致不生成额外的访问器方法来满足此类方法没有子类化的 final 要求。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_注解"><a class="link" href="#_注解">4.4. 注解</a></h3>
<div class="sect3">
<h4 id="ann-definition"><a class="link" href="#ann-definition">4.4.1. 定义注解</a></h4>
<div class="paragraph">
<p>注解是一种专用于注解代码元素的特殊接口。注解是一种类型，其超级接口是 <code>java.lang.annotation.Annotation</code> 接口。注解的声明方式与接口非常相似，使用 <code>@interface</code> 关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@interface</span> SomeAnnotation {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注解可以以不带主体和可选默认值的方法的形式定义成员。可能的成员类型仅限于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基础类型</p>
</li>
<li>
<p>java.lang.String</p>
</li>
<li>
<p>java.lang.Class</p>
</li>
<li>
<p>java.lang.Enum</p>
</li>
<li>
<p>另外一个注解类型</p>
</li>
<li>
<p>或者以上类型的数组</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@interface</span> SomeAnnotation {
    <span style="color:#0a8;font-weight:bold">String</span> value()                          // <b class="conum">(1)</b>
}
<span style="color:#007">@interface</span> SomeAnnotation {
    <span style="color:#0a8;font-weight:bold">String</span> value() <span style="color:#080;font-weight:bold">default</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">something</span><span style="color:#710">'</span></span>      // <b class="conum">(2)</b>
}
<span style="color:#007">@interface</span> SomeAnnotation {
    <span style="color:#339;font-weight:bold">int</span> step()                              // <b class="conum">(3)</b>
}
<span style="color:#007">@interface</span> SomeAnnotation {
    <span style="color:#0a8;font-weight:bold">Class</span> appliesTo()                       // <b class="conum">(4)</b>
}
<span style="color:#007">@interface</span> SomeAnnotation {}
<span style="color:#007">@interface</span> SomeAnnotations {
    SomeAnnotation<span style="color:#339;font-weight:bold">[]</span> value()                // <b class="conum">(5)</b>
}
<span style="color:#339;font-weight:bold">enum</span> DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
<span style="color:#007">@interface</span> Scheduled {
    DayOfWeek dayOfWeek()                   // <b class="conum">(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义 <code>String</code> 类型的 <code>value</code> 成员的注解</p>
</li>
<li>
<p>定义 <code>String</code> 类型的 <code>value</code> 成员的注解，默认值为 something</p>
</li>
<li>
<p>定义原始类型 <code>int</code> 类型的 <code>step</code> 成员的注解</p>
</li>
<li>
<p>定义 <code>Class</code> 类型的 <code>appliesTo</code> 成员的注解</p>
</li>
<li>
<p>定义 <code>value</code> 成员的注解，其类型是另一个注解类型的数组</p>
</li>
<li>
<p>定义 <code>dayOfWeek</code> 成员的注解，其类型为枚举类型 <code>DayOfWeek</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>与 Java 语言不同，在 Groovy 中，注解可用于更改语言的语义。对于将基于注解生成代码的 AST 转换尤其如此。</p>
</div>
<div class="sect4">
<h5 id="ann-placement"><a class="link" href="#ann-placement">4.4.1.1. 使用注解的位置</a></h5>
<div class="paragraph">
<p>注解可以应用于代码的各个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@SomeAnnotation</span>                 // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">void</span> someMethod() {
    <span style="color:#777">// ...</span>
}

<span style="color:#007">@SomeAnnotation</span>                 // <b class="conum">(2)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SomeClass</span> {}

<span style="color:#007">@SomeAnnotation</span> <span style="color:#0a8;font-weight:bold">String</span> <span style="color:#339;font-weight:bold">var</span>      // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>@SomeAnnotation `适用于 `someMethod</code> 方法</p>
</li>
<li>
<p><code>@SomeAnnotation</code> 适用于 <code>SomeClass</code> 类</p>
</li>
<li>
<p><code>@SomeAnnotation</code> 适用于 <code>var</code> 变量</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了限制注解的应用范围，需要在注解定义上使用 <code>java.lang.annotation.Target</code> 注解进行声明。例如，以下是如何声明注解可以应用于类或方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.lang.annotation.ElementType</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.lang.annotation.Target</span>

<span style="color:#007">@Target</span>([<span style="color:#0a8;font-weight:bold">ElementType</span>.METHOD, <span style="color:#0a8;font-weight:bold">ElementType</span>.TYPE])     // <b class="conum">(1)</b>
<span style="color:#007">@interface</span> SomeAnnotation {}                        // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>@Target</code> 注解限定注解的使用位置</p>
</li>
<li>
<p>因此， <code>@SomeAnnotation</code> 只能在 <code>TYPE</code> 或 <code>METHOD</code> 上使用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>java.lang.annotation.ElementType</code> 中提供了可能的 <code>Target</code> 的列表。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Groovy 不支持 Java 8 中引入的 <code>java.lang.annotation.ElementType#TYPE_PARAMETER</code> 和 <code>java.lang.annotation.ElementType#TYPE_PARAMETER</code> 元素类型。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_注解中成员的值"><a class="link" href="#_注解中成员的值">4.4.1.2. 注解中成员的值</a></h5>
<div class="paragraph">
<p>当使用注解时，至少需要设置所有没有默认值的成员。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@interface</span> Page {
    <span style="color:#339;font-weight:bold">int</span> statusCode()
}

<span style="color:#007">@Page</span>(statusCode=<span style="color:#00D">404</span>)
<span style="color:#339;font-weight:bold">void</span> notFound() {
    <span style="color:#777">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果 <code>value</code> 是唯一需要被设置的成员，则可以在注解值的声明中省略 <code>value=</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@interface</span> Page {
    <span style="color:#0a8;font-weight:bold">String</span> value()
    <span style="color:#339;font-weight:bold">int</span> statusCode() <span style="color:#080;font-weight:bold">default</span> <span style="color:#00D">200</span>
}

<span style="color:#007">@Page</span>(value=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/home</span><span style="color:#710">'</span></span>)                    // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">void</span> home() {
    <span style="color:#777">// ...</span>
}

<span style="color:#007">@Page</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/users</span><span style="color:#710">'</span></span>)                         // <b class="conum">(2)</b>
<span style="color:#339;font-weight:bold">void</span> userList() {
    <span style="color:#777">// ...</span>
}

<span style="color:#007">@Page</span>(value=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">error</span><span style="color:#710">'</span></span>,statusCode=<span style="color:#00D">404</span>)     // <b class="conum">(3)</b>
<span style="color:#339;font-weight:bold">void</span> notFound() {
    <span style="color:#777">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们可以省略 <code>statusCode</code> ，因为它有默认值，但需要设置 value</p>
</li>
<li>
<p>由于 <code>value</code> 是唯一没有默认值的强制成员，因此我们可以省略 <code>value=</code></p>
</li>
<li>
<p>如果 <code>value</code> 和 <code>statusCode</code> 都需要设置，则需要使用 <code>value=</code> 作为默认的 <code>value</code> 成员</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_保留策略"><a class="link" href="#_保留策略">4.4.1.3. 保留策略</a></h5>
<div class="paragraph">
<p>注解的可见性取决于其保留策略。注解的保留策略是使用 <code>java.lang.annotation.Retention</code> 注解设置的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.lang.annotation.Retention</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">java.lang.annotation.RetentionPolicy</span>

<span style="color:#007">@Retention</span>(<span style="color:#0a8;font-weight:bold">RetentionPolicy</span>.SOURCE)                   // <b class="conum">(1)</b>
<span style="color:#007">@interface</span> SomeAnnotation {}                         // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>@Retention</code> 注解 <code>@SomeAnnotation</code></p>
</li>
<li>
<p>因此 <code>@SomeAnnotation</code> 将具有 <code>SOURCE</code> 保留策略</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>java.lang.annotation.RetentionPolicy</code> 枚举中提供了可能的保留目标和描述的列表。选择通常取决于您希望注解在编译时还是运行时可见。</p>
</div>
</div>
<div class="sect4">
<h5 id="_closure_annotation_parameters"><a class="link" href="#_closure_annotation_parameters">4.4.1.4. Closure annotation parameters</a></h5>
<div class="paragraph">
<p>Groovy 中注解的一个有趣功能是您可以使用闭包作为注解值。因此，注解可以与多种表达式一起使用，并且仍然具有 IDE 支持。例如，想象一个框架，您希望在其中根据环境约束（例如 JDK 版本或操作系统）执行一些方法。可以编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Tasks</span> {
    <span style="color:#0a8;font-weight:bold">Set</span> result = <span style="color:#339;font-weight:bold">[]</span>
    <span style="color:#339;font-weight:bold">void</span> alwaysExecuted() {
        result &lt;&lt; <span style="color:#00D">1</span>
    }
    <span style="color:#007">@OnlyIf</span>({ jdk&gt;=<span style="color:#00D">6</span> })
    <span style="color:#339;font-weight:bold">void</span> supportedOnlyInJDK6() {
        result &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">JDK 6</span><span style="color:#710">'</span></span>
    }
    <span style="color:#007">@OnlyIf</span>({ jdk&gt;=<span style="color:#00D">7</span> &amp;&amp; windows })
    <span style="color:#339;font-weight:bold">void</span> requiresJDK7AndWindows() {
        result &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">JDK 7 Windows</span><span style="color:#710">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使  <code>@OnlyIf</code> 注解接受 <code>Closure</code> 作为参数，您只需将 <code>value</code> 声明为 <code>Class</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Retention</span>(<span style="color:#0a8;font-weight:bold">RetentionPolicy</span>.RUNTIME)
<span style="color:#007">@interface</span> OnlyIf {
    <span style="color:#0a8;font-weight:bold">Class</span> value()                    // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了完成该示例，让我们编写一个使用该信息的示例运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Runner</span> {
    <span style="color:#088;font-weight:bold">static</span> &lt;T&gt; T run(<span style="color:#0a8;font-weight:bold">Class</span>&lt;T&gt; taskClass) {
        <span style="color:#080;font-weight:bold">def</span> tasks = taskClass.newInstance()                                         // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">def</span> params = [<span style="color:#606">jdk</span>: <span style="color:#00D">6</span>, <span style="color:#606">windows</span>: <span style="color:#069">false</span>]                                       // <b class="conum">(2)</b>
        tasks.class.declaredMethods.each { m -&gt;                                     // <b class="conum">(3)</b>
            <span style="color:#080;font-weight:bold">if</span> (<span style="color:#0a8;font-weight:bold">Modifier</span>.isPublic(m.modifiers) &amp;&amp; m.parameterTypes.length == <span style="color:#00D">0</span>) {   // <b class="conum">(4)</b>
                <span style="color:#080;font-weight:bold">def</span> onlyIf = m.getAnnotation(OnlyIf)                                // <b class="conum">(5)</b>
                <span style="color:#080;font-weight:bold">if</span> (onlyIf) {
                    Closure cl = onlyIf.value().newInstance(tasks,tasks)            // <b class="conum">(6)</b>
                    cl.delegate = params                                            // <b class="conum">(7)</b>
                    <span style="color:#080;font-weight:bold">if</span> (cl()) {                                                     // <b class="conum">(8)</b>
                        m.invoke(tasks)                                             // <b class="conum">(9)</b>
                    }
                } <span style="color:#080;font-weight:bold">else</span> {
                    m.invoke(tasks)                                                 // <b class="conum">(10)</b>
                }
            }
        }
        tasks                                                                       // <b class="conum">(11)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个实例</p>
</li>
<li>
<p>模拟 JDK 6 并且不是 Windows 的环境</p>
</li>
<li>
<p>迭代任务类的所有声明的方法</p>
</li>
<li>
<p>如果该方法是公共的并且不带参数</p>
</li>
<li>
<p>尝试找到 @OnlyIf 注解</p>
</li>
<li>
<p>如果找到，则获取 value 并从中创建一个新的 Closure</p>
</li>
<li>
<p>将闭包的 delegate 设置为我们的环境变量</p>
</li>
<li>
<p>调用闭包，即注解闭包。它将返回一个 boolean</p>
</li>
<li>
<p>如果是 true ，则调用该方法</p>
</li>
<li>
<p>如果该方法没有用 @OnlyIf 注解，则无论如何执行该方法</p>
</li>
<li>
<p>之后，返回任务对象</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>可以这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> tasks = Runner.run(Tasks)
<span style="color:#080;font-weight:bold">assert</span> tasks.result == [<span style="color:#00D">1</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">JDK 6</span><span style="color:#710">'</span></span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Set</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_meta_annotations"><a class="link" href="#_meta_annotations">4.4.2. Meta-annotations</a></h4>
<div class="sect4">
<h5 id="_声明元注解"><a class="link" href="#_声明元注解">4.4.2.1. 声明元注解</a></h5>
<div class="paragraph">
<p>元注解，也称为注解别名，是 <strong>在编译时被其他注解替换的注解</strong>（一个元注解是一个或多个注解的别名）。元注解可用于减少涉及多个注解的代码的大小。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始。假设您有 <code>@Service</code> 和 <code>@Transactional</code> 注解，并且您想用这两者注解一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Service</span>
<span style="color:#007">@Transactional</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyTransactionalService</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑到您可以添加到同一个类中的注解数量增多，元注解可以通过将两个注解减少为具有完全相同语义的单个注解来提供帮助。例如，我们可能想这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@TransactionalService</span>                           // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyTransactionalService</span> {}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>@TransactionalService</code> 是元注解</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>元注解被声明为常规注解，但被 <code>@AnnotationCollector</code> 和一系列其正在收集的注解列表进行注解。在我们的例子中， <code>@TransactionalService</code> 注解可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.AnnotationCollector</span>

<span style="color:#007">@Service</span>                                        // <b class="conum">(1)</b>
<span style="color:#007">@Transactional</span>                                  // <b class="conum">(2)</b>
<span style="color:#007">@AnnotationCollector</span>                            // <b class="conum">(3)</b>
<span style="color:#007">@interface</span> TransactionalService {
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 @Service 注释元注解</p>
</li>
<li>
<p>使用 @Transactional 注释元注解</p>
</li>
<li>
<p>使用 @AnnotationCollector 注释元注解</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="meta-ann-behavior"><a class="link" href="#meta-ann-behavior">4.4.2.2. 元注解的行为</a></h5>
<div class="paragraph">
<p>Groovy supports both <em>precompiled</em> and <em>source form</em>
meta-annotations. This means that your meta-annotation <em>may</em> be
precompiled, or you can have it in the same source tree as the one you
are currently compiling.</p>
</div>
<div class="paragraph">
<p>INFO: Meta-annotations are a Groovy-only feature. There is
no chance for you to annotate a Java class with a meta-annotation and
hope it will do the same as in Groovy. Likewise, you cannot write a
meta-annotation in Java: both the meta-annotation definition <strong>and</strong> usage
have to be Groovy code. But you can happily collect Java annotations
and Groovy annotations within your meta-annotation.</p>
</div>
<div class="paragraph">
<p>When the Groovy compiler encounters a class annotated with a
meta-annotation, it <strong>replaces</strong> it with the collected annotations. So,
in our previous example, it will
replace <code>@TransactionalService</code> with <code>@Transactional</code> and <code>@Service</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> annotations = MyTransactionalService.annotations*.annotationType()
<span style="color:#080;font-weight:bold">assert</span> (Service <span style="color:#080;font-weight:bold">in</span> annotations)
<span style="color:#080;font-weight:bold">assert</span> (Transactional <span style="color:#080;font-weight:bold">in</span> annotations)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The conversion from a meta-annotation to the collected annotations is performed during the
<em>semantic analysis</em> compilation phase. </p>
</div>
<div class="paragraph">
<p>In addition to replacing the alias with the collected annotations, a meta-annotation is capable of
processing them, including arguments.</p>
</div>
</div>
<div class="sect4">
<h5 id="meta-ann-members"><a class="link" href="#meta-ann-members">4.4.2.3. 元注解的参数</a></h5>
<div class="paragraph">
<p>元注解可以收集带有参数的注解。为了说明这一点，我们将想象两个注解，每个注解都接受一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Timeout</span>(after=<span style="color:#00D">3600</span>)
<span style="color:#007">@Dangerous</span>(type=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">explosive</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设您要创建一个名为 <code>@Explosive</code> 的元注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Timeout</span>(after=<span style="color:#00D">3600</span>)
<span style="color:#007">@Dangerous</span>(type=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">explosive</span><span style="color:#710">'</span></span>)
<span style="color:#007">@AnnotationCollector</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> Explosive {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，当 <code>@Explosive</code> 被替换时，<code>@Timeout</code>
<code>@Dangerous`将获取 `@Explosive</code> 中定义的对应的参数值。更有趣的是，元注解支持覆盖特定值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Explosive</span>(after=<span style="color:#00D">0</span>)                 // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bomb</span> {}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>作为参数提供给 @Explosive 的 after 值会覆盖 @Timeout 注解中定义的值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果两个注解定义了相同的参数名称，则默认处理器会将注解值复制到所有接受该参数的注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Retention</span>(<span style="color:#0a8;font-weight:bold">RetentionPolicy</span>.RUNTIME)
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> Foo {
   <span style="color:#0a8;font-weight:bold">String</span> value()                                   // <b class="conum">(1)</b>
}
<span style="color:#007">@Retention</span>(<span style="color:#0a8;font-weight:bold">RetentionPolicy</span>.RUNTIME)
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> Bar {
    <span style="color:#0a8;font-weight:bold">String</span> value()                                  // <b class="conum">(2)</b>
}

<span style="color:#007">@Foo</span>
<span style="color:#007">@Bar</span>
<span style="color:#007">@AnnotationCollector</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> FooBar {}                         // <b class="conum">(3)</b>

<span style="color:#007">@Foo</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>)
<span style="color:#007">@Bar</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>)
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bob</span> {}                                        // <b class="conum">(4)</b>

<span style="color:#080;font-weight:bold">assert</span> Bob.getAnnotation(Foo).value() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>        // <b class="conum">(5)</b>
println Bob.getAnnotation(Bar).value() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>       // <b class="conum">(6)</b>

<span style="color:#007">@FooBar</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>)
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Joe</span> {}                                        // <b class="conum">(7)</b>
<span style="color:#080;font-weight:bold">assert</span> Joe.getAnnotation(Foo).value() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>        // <b class="conum">(8)</b>
println Joe.getAnnotation(Bar).value() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>       // <b class="conum">(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>@Foo 注解定义 String 类型的 value 成员</p>
</li>
<li>
<p>@Bar 注解还定义了 String 类型的 value 成员</p>
</li>
<li>
<p>@FooBar 元注解聚合 @Foo 和 @Bar</p>
</li>
<li>
<p>类 Bob 用 @Foo 和 @Bar 注解</p>
</li>
<li>
<p>Bob 上的 @Foo 注解的值为 a</p>
</li>
<li>
<p>而 Bob 上的 @Bar 注解的值为 b</p>
</li>
<li>
<p>类 Joe 用 @FooBar 注解</p>
</li>
<li>
<p>那么 Joe 上的 @Foo 注解的值为 a</p>
</li>
<li>
<p>Joe 上的 @Bar 注解的值也是 a</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在第二种情况下，元注解值被复制到 @Foo 和 @Bar 注解中。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
如果收集的注解定义了具有不兼容类型的相同成员，则会出现编译时错误。例如，如果在前面的示例中 @Foo 定义了 String 类型的值，但 @Bar 定义了 int 类型的值。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然而，可以自定义元注解的行为并描述如何扩展收集的注解。我们很快就会了解如何做到这一点，但首先要介绍一个高级处理选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="handling_duplicate_annotations"><a class="link" href="#handling_duplicate_annotations">4.4.2.4. 处理元注解中的重复注解</a></h5>
<div class="paragraph">
<p>@AnnotationCollector 注解支持 mode 参数，该参数可用于更改默认处理器在存在重复注解的情况下处理注解替换的方式。</p>
</div>
<div class="paragraph">
<p>INFO: Custom processors （接下来讨论）可能支持也可能不支持此参数。</p>
</div>
<div class="paragraph">
<p>例如，假设您创建一个包含 @ToString 注解的元注解，然后将元注解放在已经具有显式 @ToString 注解的类上。这应该是一个错误吗？是否应该应用这两个注解？其中一个优先于另一个吗？没有正确答案。在某些情况下，这些答案中的任何一个都可能是正确的。因此，Groovy 不是试图抢占一种正确的方法来处理重复注解问题，而是让您编写自己的自定义元注解处理器（接下来介绍），并让您在 AST 转换中编写您喜欢的任何检查逻辑 - 这是一个常见的目标用于聚合。话虽如此，通过简单地设置 mode ，在任何额外的编码中都会自动为您处理许多常见的预期场景。 mode 参数的行为由所选的 AnnotationCollectorMode 枚举值确定，并总结在下表中。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DUPLICATE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotations from the annotation collection will always be inserted. After all transforms have been run, it will be an error if multiple annotations (excluding those with SOURCE retention) exist.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotations from the collector will be added and any existing annotations with the same name will be removed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotations from the collector will be ignored if any existing annotations with the same name are found.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="meta-ann-processor"><a class="link" href="#meta-ann-processor">4.4.2.5. 自定义元注解处理器</a></h5>
<div class="paragraph">
<p>自定义注解处理器将允许您选择如何将元注解扩展为收集的注解。在这种情况下，元注解的行为完全取决于您。为此，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个元注解处理器，扩展 org.codehaus.groovy.transform.AnnotationCollectorTransform</p>
</li>
<li>
<p>声明要在元注解声明中使用的处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明这一点，我们将探讨元注解 @CompileDynamic 是如何实现的。</p>
</div>
<div class="paragraph">
<p>@CompileDynamic 是一个元注解，可扩展为 @CompileStatic(TypeCheckingMode.SKIP) 。问题是默认的元注解处理器不支持枚举，并且注解值 TypeCheckingMode.SKIP 是 1。</p>
</div>
<div class="paragraph">
<p>这里的简单实现是行不通的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@CompileStatic</span>(TypeCheckingMode.SKIP)
<span style="color:#007">@AnnotationCollector</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> CompileDynamic {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，我们将这样定义它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@AnnotationCollector</span>(processor = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">org.codehaus.groovy.transform.CompileDynamicProcessor</span><span style="color:#710">&quot;</span></span>)
<span style="color:#088;font-weight:bold">public</span> <span style="color:#007">@interface</span> CompileDynamic {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first thing you may notice is that our interface is no longer
annotated with <code>@CompileStatic</code>. The reason for this is that we rely on
the <code>processor</code> parameter instead, that references a class which
will <strong>generate</strong> the annotation.</p>
</div>
<div class="paragraph">
<p>Here is how the custom processor is implemented:</p>
</div>
<div class="listingblock">
<div class="title">CompileDynamicProcessor.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@CompileStatic</span>                                                                  // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CompileDynamicProcessor</span> <span style="color:#088;font-weight:bold">extends</span> AnnotationCollectorTransform {            // <b class="conum">(2)</b>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> ClassNode CS_NODE = ClassHelper.make(CompileStatic)    // <b class="conum">(3)</b>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) // <b class="conum">(4)</b>

    <span style="color:#0a8;font-weight:bold">List</span>&lt;AnnotationNode&gt; visit(AnnotationNode collector,                        // <b class="conum">(5)</b>
                               AnnotationNode aliasAnnotationUsage,             // <b class="conum">(6)</b>
                               AnnotatedNode aliasAnnotated,                    // <b class="conum">(7)</b>
                               SourceUnit source) {                             // <b class="conum">(8)</b>
        <span style="color:#080;font-weight:bold">def</span> node = <span style="color:#080;font-weight:bold">new</span> AnnotationNode(CS_NODE)                                  // <b class="conum">(9)</b>
        <span style="color:#080;font-weight:bold">def</span> enumRef = <span style="color:#080;font-weight:bold">new</span> PropertyExpression(
            <span style="color:#080;font-weight:bold">new</span> ClassExpression(TC_NODE), <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">SKIP</span><span style="color:#710">&quot;</span></span>)                               // <b class="conum">(10)</b>
        node.addMember(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">value</span><span style="color:#710">&quot;</span></span>, enumRef)                                        // <b class="conum">(11)</b>
        <span style="color:#0a8;font-weight:bold">Collections</span>.singletonList(node)                                         // <b class="conum">(12)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>our custom processor is written in Groovy, and for better compilation performance, we use static compilation</p>
</li>
<li>
<p>the custom processor has to extend gapi:org.codehaus.groovy.transform.AnnotationCollectorTransform[AnnotationCollectorTransform]</p>
</li>
<li>
<p>create a class node representing the <code>@CompileStatic</code> annotation type</p>
</li>
<li>
<p>create a class node representing the <code>TypeCheckingMode</code> enum type</p>
</li>
<li>
<p><code>collector</code> is the <code>@AnnotationCollector</code> node found in the meta-annotation. Usually unused.</p>
</li>
<li>
<p><code>aliasAnnotationUsage</code> is the meta-annotation being expanded, here it is <code>@CompileDynamic</code></p>
</li>
<li>
<p><code>aliasAnnotated</code> is the node being annotated with the meta-annotation</p>
</li>
<li>
<p><code>sourceUnit</code> is the <code>SourceUnit</code> being compiled</p>
</li>
<li>
<p>we create a new annotation node for <code>@CompileStatic</code></p>
</li>
<li>
<p>we create an expression equivalent to <code>TypeCheckingMode.SKIP</code></p>
</li>
<li>
<p>we add that expression to the annotation node, which is now <code>@CompileStatic(TypeCheckingMode.SKIP)</code></p>
</li>
<li>
<p>return the generated annotation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the example, the <code>visit</code> method is the only method which has to be overridden. It is meant to return a list of
annotation nodes that will be added to the node annotated with the meta-annotation. In this example, we return a
single one corresponding to <code>@CompileStatic(TypeCheckingMode.SKIP)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_特质"><a class="link" href="#_特质">4.5. 特质</a></h3>
<div class="paragraph">
<p>特质是groovy的结构构造，它允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>行为的构成</p>
</li>
<li>
<p>接口的运行时实现</p>
</li>
<li>
<p>行为的重写</p>
</li>
<li>
<p>与静态类型检查/编译的兼容性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>它们可以被视为携带默认实现和状态的interface</strong>。使用 trait 关键字定义特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait FlyingAbility {                           // <b class="conum">(1)</b>
        <span style="color:#0a8;font-weight:bold">String</span> fly() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span> }          // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>特性的声明</p>
</li>
<li>
<p>特质内方法的声明</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然后就可以像接口一样使用 <code>implements</code> 关键字来使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bird</span> <span style="color:#088;font-weight:bold">implements</span> FlyingAbility {}          // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> b = <span style="color:#080;font-weight:bold">new</span> Bird()                              // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> b.fly() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span>                 // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>将特质 FlyingAbility 添加到 Bird 类功能中</p>
</li>
<li>
<p>实例化一个新的 Bird</p>
</li>
<li>
<p>Bird 类自动获取 FlyingAbility 特质的行为</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>特质提供了广泛的功能，从简单的组合到测试，本节将对此进行详细描述。</p>
</div>
<div class="sect3">
<h4 id="_方法_3"><a class="link" href="#_方法_3">4.5.1. 方法</a></h4>
<div class="sect4">
<h5 id="_public_方法"><a class="link" href="#_public_方法">4.5.1.1. Public 方法</a></h5>
<div class="paragraph">
<p>在特质中声明方法可以像类中的常规方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait FlyingAbility {                           // <b class="conum">(1)</b>
        <span style="color:#0a8;font-weight:bold">String</span> fly() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span> }          // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>特性的声明</p>
</li>
<li>
<p>特质内方法的声明</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_abstract_methods"><a class="link" href="#_abstract_methods">4.5.1.2. Abstract methods</a></h5>
<div class="paragraph">
<p>此外，特质也可以声明抽象方法，因此需要在实现特质的类中实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Greetable {
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#0a8;font-weight:bold">String</span> name()                              // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> greeting() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name()<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> }           // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>实现类必须声明 name 方法</p>
</li>
<li>
<p>可与具体方法进行混合</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然后可以像这样使用该特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> <span style="color:#088;font-weight:bold">implements</span> Greetable {                     // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span> }                             // <b class="conum">(2)</b>
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()
<span style="color:#080;font-weight:bold">assert</span> p.greeting() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Bob!</span><span style="color:#710">'</span></span>                    // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>实现特质 Greetable</p>
</li>
<li>
<p>由于 name 是抽象的，因此需要实现它</p>
</li>
<li>
<p>然后可以调用 greeting</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_private_方法"><a class="link" href="#_private_方法">4.5.1.3. Private 方法</a></h5>
<div class="paragraph">
<p>特质还可以定义私有方法。这些方法不会出现在实现特质的子类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Greeter {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> greetingMessage() {                      // <b class="conum">(1)</b>
        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello from a private method!</span><span style="color:#710">'</span></span>
    }
    <span style="color:#0a8;font-weight:bold">String</span> greet() {
        <span style="color:#080;font-weight:bold">def</span> m = greetingMessage()                           // <b class="conum">(2)</b>
        println m
        m
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">GreetingMachine</span> <span style="color:#088;font-weight:bold">implements</span> Greeter {}                 // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> g = <span style="color:#080;font-weight:bold">new</span> GreetingMachine()
<span style="color:#080;font-weight:bold">assert</span> g.greet() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello from a private method!</span><span style="color:#710">&quot;</span></span>          // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">try</span> {
    <span style="color:#080;font-weight:bold">assert</span> g.greetingMessage()                              // <b class="conum">(5)</b>
} <span style="color:#080;font-weight:bold">catch</span> (MissingMethodException e) {
    println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">greetingMessage is private in trait</span><span style="color:#710">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在特质中定义私有方法 greetingMessage</p>
</li>
<li>
<p>公共 greet 消息默认调用 greetingMessage</p>
</li>
<li>
<p>创建一个实现该特质的类</p>
</li>
<li>
<p>greet 可以被调用</p>
</li>
<li>
<p>但 greetingMessage 不行</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
特质仅支持 public 和 private 方法。 protected 和 <code>package private</code> 范围均不受支持。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_final_方法"><a class="link" href="#_final_方法">4.5.1.4. Final 方法</a></h5>
<div class="paragraph">
<p>如果我们有一个实现特质的类，从概念上讲，特质方法的实现将“继承”到该类中。但实际上，不存在包含此类实现的基类。相反，它们直接融入课堂。方法的最终修饰符仅指示编织方法的修饰符。虽然继承和覆盖或乘以具有相同签名但混合了最终和非最终变体的继承方法可能被认为是不好的风格，但 Groovy 并不禁止这种情况。应用正常方法选择，并且所使用的修饰符将根据结果方法确定。如果您想要无法重写的特质实现方法，您可以考虑创建一个实现所需特质的基类。</p>
</div>
<div class="paragraph">
<p>If we have a class implementing a trait, conceptually implementations from the trait methods
are "inherited" into the class. But, in reality, there is no base class containing such
implementations. Rather, they are woven directly into the class. A final modifier on a method
just indicates what the modifier will be for the woven method. While it would likely be
considered bad style to inherit and override or multiply inherit methods with the same
signature but a mix of final and non-final variants, Groovy doesn&#8217;t prohibit this scenario.
Normal method selection applies and the modifier used will be determined from the resulting method.
You might consider creating a base class which implements the desired trait(s) if you
want trait implementation methods that can&#8217;t be overridden.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_this的含义"><a class="link" href="#_this的含义">4.5.2. this的含义</a></h4>
<div class="paragraph">
<p>this 代表具体实现的实例。将特质视为一个父类。这意味着当你写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait <span style="color:#0a8;font-weight:bold">Introspector</span> {
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">whoAmI</span>() { <span style="color:#950">this</span> }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Introspector</span> {}
<span style="color:#080;font-weight:bold">def</span> foo = <span style="color:#080;font-weight:bold">new</span> Foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">foo.whoAmI()</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回相同的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> foo.whoAmI().is(foo)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_接口"><a class="link" href="#_接口">4.5.3. 接口</a></h4>
<div class="paragraph">
<p>特质可以实现接口，在这种情况下，使用 <code>implements</code> 关键字声明接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Named {                                       // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name()
}
trait Greetable <span style="color:#088;font-weight:bold">implements</span> Named {                      // <b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">String</span> greeting() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name()<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> <span style="color:#088;font-weight:bold">implements</span> Greetable {                     // <b class="conum">(3)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span> }                             // <b class="conum">(4)</b>
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()
<span style="color:#080;font-weight:bold">assert</span> p.greeting() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Bob!</span><span style="color:#710">'</span></span>                    // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> p <span style="color:#080;font-weight:bold">instanceof</span> Named                               // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> p <span style="color:#080;font-weight:bold">instanceof</span> Greetable                           // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>普通接口的声明</p>
</li>
<li>
<p>将 Named 添加到已实现的接口列表中</p>
</li>
<li>
<p>声明一个实现 Greetable 特质的类</p>
</li>
<li>
<p>实现缺少的 name 方法</p>
</li>
<li>
<p>greeting 实现来自特质</p>
</li>
<li>
<p>确保 Person 实现 Named 接口</p>
</li>
<li>
<p>确保 Person 实现 Greetable 特质</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_属性"><a class="link" href="#_属性">4.5.4. 属性</a></h4>
<div class="paragraph">
<p>特质可以定义属性，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Named {
    <span style="color:#0a8;font-weight:bold">String</span> name                             // <b class="conum">(1)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> <span style="color:#088;font-weight:bold">implements</span> Named {}            // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>)             // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> p.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                      // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> p.getName() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                 // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在特质中声明属性 name</p>
</li>
<li>
<p>声明一个实现该特质的类</p>
</li>
<li>
<p>该属性自动可见</p>
</li>
<li>
<p>可以使用属性访问器来访问它</p>
</li>
<li>
<p>或使用常规 getter 语法</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_字段"><a class="link" href="#_字段">4.5.5. 字段</a></h4>
<div class="sect4">
<h5 id="_private字段"><a class="link" href="#_private字段">4.5.5.1. Private字段</a></h5>
<div class="paragraph">
<p>由于特质允许使用私有方法，因此使用私有字段来存储状态也很有趣。特质可以让你做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Counter {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#339;font-weight:bold">int</span> count = <span style="color:#00D">0</span>                   // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">int</span> count() { count += <span style="color:#00D">1</span>; count }       // <b class="conum">(2)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> <span style="color:#088;font-weight:bold">implements</span> Counter {}             // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> f = <span style="color:#080;font-weight:bold">new</span> Foo()
<span style="color:#080;font-weight:bold">assert</span> f.count() == <span style="color:#00D">1</span>                       // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> f.count() == <span style="color:#00D">2</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在特质中声明私有字段 count</p>
</li>
<li>
<p>声明一个公共方法 count 来增加计数器并返回它</p>
</li>
<li>
<p>声明一个实现 Counter 特质的类</p>
</li>
<li>
<p>count 方法可以使用私有字段来保存状态</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
这是与 Java 8 <a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8 virtual extension methods</a>的一个主要区别。虽然虚拟扩展方法不携带状态，但特质可以。此外，从 Java 6 开始支持 Groovy 中的特质，因为它们的实现不依赖于虚拟扩展方法。这意味着即使一个特质可以从 Java 的角度视为常规接口，该接口也不会具有default方法，只有抽象方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_public字段"><a class="link" href="#_public字段">4.5.5.2. Public字段</a></h5>
<div class="paragraph">
<p>公共字段的工作方式与私有字段相同，但为了避免http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem[菱形问题]问题，字段名称在实现类中重新映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Named {
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">String</span> name                      // <b class="conum">(1)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> <span style="color:#088;font-weight:bold">implements</span> Named {}            // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person()                        // <b class="conum">(3)</b>
p.Named__name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                       // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在特质内声明一个公共字段</p>
</li>
<li>
<p>声明一个实现该特质的类</p>
</li>
<li>
<p>创建该类的一个实例</p>
</li>
<li>
<p>公共字段可用，但已重命名</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>字段的名称取决于特质的完全限定名称。包中的所有点（ . ）都替换为下划线（ _ ），最终名称包含双下划线。因此，如果字段的类型为 String ，包的名称为 my.package ，特质的名称为 Foo ，字段的名称为 bar ，在实现类中，公共字段将显示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> my_package_Foo__bar</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
虽然特质支持公共字段，但不建议使用它们，并被认为是一种不好的做法。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_行为的组合"><a class="link" href="#_行为的组合">4.5.6. 行为的组合</a></h4>
<div class="paragraph">
<p>Traits 可用于实现多重继承。例如，我们可以具有以下特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait FlyingAbility {                           // <b class="conum">(1)</b>
        <span style="color:#0a8;font-weight:bold">String</span> fly() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span> }          // <b class="conum">(2)</b>
}
trait SpeakingAbility {
    <span style="color:#0a8;font-weight:bold">String</span> speak() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm speaking!</span><span style="color:#710">&quot;</span></span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及一个实现这两个特质的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Duck</span> <span style="color:#088;font-weight:bold">implements</span> FlyingAbility, SpeakingAbility {} // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#080;font-weight:bold">new</span> Duck()                                      // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> d.fly() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span>                         // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> d.speak() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm speaking!</span><span style="color:#710">&quot;</span></span>                     // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Duck 类同时实现 FlyingAbility 和 SpeakingAbility</p>
</li>
<li>
<p>创建 Duck 的新实例</p>
</li>
<li>
<p>我们可以从 FlyingAbility 调用方法 fly</p>
</li>
<li>
<p>还有 SpeakingAbility 中的方法 speak</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>特质鼓励对象之间重用功能，并通过现有行为的组合来创建新类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_重写default方法"><a class="link" href="#_重写default方法">4.5.7. 重写default方法</a></h4>
<div class="paragraph">
<p>特质提供方法的默认实现，但可以在实现类中重写它们。例如，我们可以稍微改变上面的例子，让鸭子嘎嘎叫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Duck</span> <span style="color:#088;font-weight:bold">implements</span> FlyingAbility, SpeakingAbility {
    <span style="color:#0a8;font-weight:bold">String</span> quack() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Quack!</span><span style="color:#710">&quot;</span></span> }                         // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> speak() { quack() }                          // <b class="conum">(2)</b>
}

<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#080;font-weight:bold">new</span> Duck()
<span style="color:#080;font-weight:bold">assert</span> d.fly() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm flying!</span><span style="color:#710">&quot;</span></span>                         // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> d.quack() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Quack!</span><span style="color:#710">&quot;</span></span>                            // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> d.speak() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Quack!</span><span style="color:#710">&quot;</span></span>                            // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义一个特定于 Duck 的方法，名为 quack</p>
</li>
<li>
<p>覆盖 speak 的默认实现，以便我们使用 quack 代替</p>
</li>
<li>
<p>鸭子仍然在飞</p>
</li>
<li>
<p>quack 来自 Duck 类</p>
</li>
<li>
<p>speak 不再使用 SpeakingAbility 中的默认实现</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_特质的继承"><a class="link" href="#_特质的继承">4.5.8. 特质的继承</a></h4>
<div class="sect4">
<h5 id="_简单继承"><a class="link" href="#_简单继承">4.5.8.1. 简单继承</a></h5>
<div class="paragraph">
<p>特质可能会扩展另一个特质，在这种情况下，您必须使用 extends 关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Named {
    <span style="color:#0a8;font-weight:bold">String</span> name                                     // <b class="conum">(1)</b>
}
trait Polite <span style="color:#088;font-weight:bold">extends</span> Named {                        // <b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">String</span> introduce() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, I am </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span> }      // <b class="conum">(3)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> <span style="color:#088;font-weight:bold">implements</span> Polite {}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span>)                   // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> p.introduce() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, I am Alice</span><span style="color:#710">'</span></span>         // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Named 特质定义单个 name 属性</p>
</li>
<li>
<p>Polite 特性扩展了 Named 特性</p>
</li>
<li>
<p>Polite 添加了一个新方法，可以访问父特质的 name 属性</p>
</li>
<li>
<p>name 属性在实现 Polite 的 Person 类中可见</p>
</li>
<li>
<p>与 introduce 方法一样</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_多重继承"><a class="link" href="#_多重继承">4.5.8.2. 多重继承</a></h5>
<div class="paragraph">
<p>一个特质可以继承多个特质。在这种情况下，所有父特质都必须在 implements 子句中声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait WithId {                                      // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">Long</span> id
}
trait WithName {                                    // <b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">String</span> name
}
trait Identified <span style="color:#088;font-weight:bold">implements</span> WithId, WithName {}     // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>WithId 特质定义 id 属性</p>
</li>
<li>
<p>WithName 特质定义 name 属性</p>
</li>
<li>
<p>Identified 是继承 WithId 和 WithName 的特质</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_鸭子类型与特质"><a class="link" href="#_鸭子类型与特质">4.5.9. 鸭子类型与特质</a></h4>
<div class="sect4">
<h5 id="_动态代码"><a class="link" href="#_动态代码">4.5.9.1. 动态代码</a></h5>
<div class="paragraph">
<p>Traits 可以调用任何动态代码，就像普通的 Groovy 类一样。这意味着 <strong>您可以在方法主体中调用应该存在于实现类中的方法，而无需在接口中显式声明它们</strong>。这意味着特质与鸭子类型完全兼容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait SpeakingDuck {
    <span style="color:#0a8;font-weight:bold">String</span> speak() { quack() }                      // <b class="conum">(1)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Duck</span> <span style="color:#088;font-weight:bold">implements</span> SpeakingDuck {
    <span style="color:#0a8;font-weight:bold">String</span> methodMissing(<span style="color:#0a8;font-weight:bold">String</span> name, args) {
        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name.capitalize()<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span>                     // <b class="conum">(2)</b>
    }
}
<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#080;font-weight:bold">new</span> Duck()
<span style="color:#080;font-weight:bold">assert</span> d.speak() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Quack!</span><span style="color:#710">'</span></span>                        // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>SpeakingDuck 期望定义 quack 方法</p>
</li>
<li>
<p>Duck 类 实现了 methodMissing  方法方法</p>
</li>
<li>
<p>调用 speak 方法会触发对 quack 的调用，该调用由 methodMissing 处理</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_特质中的动态方法"><a class="link" href="#_特质中的动态方法">4.5.9.2. 特质中的动态方法</a></h5>
<div class="paragraph">
<p>特质还可以实现 MOP 方法，例如 methodMissing 或 propertyMissing ，在这种情况下，实现类将从特质继承行为，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait DynamicObject {                               // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">Map</span> props = [:]
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">methodMissing</span>(<span style="color:#0a8;font-weight:bold">String</span> name, args) {
        name.toUpperCase()
    }
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">propertyMissing</span>(<span style="color:#0a8;font-weight:bold">String</span> name) {
        props.get(name)
    }
    <span style="color:#339;font-weight:bold">void</span> setProperty(<span style="color:#0a8;font-weight:bold">String</span> name, <span style="color:#0a8;font-weight:bold">Object</span> value) {
        props.put(name, value)
    }
}

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Dynamic</span> <span style="color:#088;font-weight:bold">implements</span> DynamicObject {
    <span style="color:#0a8;font-weight:bold">String</span> existingProperty = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span>                  // <b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">String</span> existingMethod() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span> }                // <b class="conum">(3)</b>
}
<span style="color:#080;font-weight:bold">def</span> d = <span style="color:#080;font-weight:bold">new</span> Dynamic()
<span style="color:#080;font-weight:bold">assert</span> d.existingProperty == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span>                   // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> d.foo == <span style="color:#069">null</span>                                // <b class="conum">(5)</b>
d.foo = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>                                       // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> d.foo == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>                               // <b class="conum">(7)</b>
<span style="color:#080;font-weight:bold">assert</span> d.existingMethod() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span>                   // <b class="conum">(8)</b>
<span style="color:#080;font-weight:bold">assert</span> d.someMethod() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">SOMEMETHOD</span><span style="color:#710">'</span></span>               // <b class="conum">(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个实现多个 MOP 方法的特质</p>
</li>
<li>
<p>Dynamic 类定义一个属性</p>
</li>
<li>
<p>Dynamic 类定义了一个方法</p>
</li>
<li>
<p>调用现有属性将调用 Dynamic 中的方法</p>
</li>
<li>
<p>调用不存在的属性将调用特质中的方法</p>
</li>
<li>
<p>将调用特质上定义的 setProperty</p>
</li>
<li>
<p>将调用特质上定义的 getProperty</p>
</li>
<li>
<p>调用 Dynamic 上的现有方法</p>
</li>
<li>
<p>但由于 methodMissing 特性而调用不存在的方法</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多重继承的冲突"><a class="link" href="#_多重继承的冲突">4.5.10. 多重继承的冲突</a></h4>
<div class="sect4">
<h5 id="_默认冲突解决方案"><a class="link" href="#_默认冲突解决方案">4.5.10.1. 默认冲突解决方案</a></h5>
<div class="paragraph">
<p>一个类可以实现多个特质。如果某个特质定义的方法与另一个特质中的方法具有相同的签名，则会发生冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait A {
    <span style="color:#0a8;font-weight:bold">String</span> exec() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span> }               // <b class="conum">(1)</b>
}
trait B {
    <span style="color:#0a8;font-weight:bold">String</span> exec() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">B</span><span style="color:#710">'</span></span> }               // <b class="conum">(2)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">C</span> <span style="color:#088;font-weight:bold">implements</span> A,B {}               // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Trait A 定义了一个名为 exec 的方法，返回一个 String</p>
</li>
<li>
<p>特质 B 定义了完全相同的方法</p>
</li>
<li>
<p>类 C 实现了这两个特质</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在这种情况下，默认行为是 implements 子句中最后声明的特质中的方法获胜。这里， B 是在 A 之后声明的，因此 B 中的方法将被选取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> c = <span style="color:#080;font-weight:bold">new</span> C()
<span style="color:#080;font-weight:bold">assert</span> c.exec() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">B</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_user_conflict_resolution"><a class="link" href="#_user_conflict_resolution">4.5.10.2. User conflict resolution</a></h5>
<div class="paragraph">
<p>如果这种行为不是您想要的，您可以使用 Trait.super.foo 语法显式选择要调用的方法。在上面的示例中，我们可以通过编写以下内容来确保调用特质 A 中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">C</span> <span style="color:#088;font-weight:bold">implements</span> A,B {
    <span style="color:#0a8;font-weight:bold">String</span> exec() { A.super.exec() }    // <b class="conum">(1)</b>
}
<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#080;font-weight:bold">new</span> C()
<span style="color:#080;font-weight:bold">assert</span> c.exec() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>                  // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>从特质 A 显式调用 exec</p>
</li>
<li>
<p>调用 A 中的版本，而不是使用默认的 B 中的版本</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_特质的运行时实现"><a class="link" href="#_特质的运行时实现">4.5.11. 特质的运行时实现</a></h4>
<div class="sect4">
<h5 id="_在运行时实现特质"><a class="link" href="#_在运行时实现特质">4.5.11.1. 在运行时实现特质</a></h5>
<div class="paragraph">
<p>Groovy 还支持在运行时动态实现特质。它允许您使用特质“装饰”现有对象。作为一个例子，让我们从这个特质和下面的类开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Extra {
    <span style="color:#0a8;font-weight:bold">String</span> extra() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm an extra method</span><span style="color:#710">&quot;</span></span> }            // <b class="conum">(1)</b>
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Something</span> {                                       // <b class="conum">(2)</b>
    <span style="color:#0a8;font-weight:bold">String</span> doSomething() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Something</span><span style="color:#710">'</span></span> }                // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Extra 特质定义了 extra 方法</p>
</li>
<li>
<p>Something 类未实现 Extra 特质</p>
</li>
<li>
<p>Something 只定义了一个方法 doSomething</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>那么如果我们这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> s = <span style="color:#080;font-weight:bold">new</span> Something()
s.extra()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对 extra 的调用将失败，因为 Something 未实现 Extra 。可以使用以下语法在运行时执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> s = <span style="color:#080;font-weight:bold">new</span> Something() <span style="color:#080;font-weight:bold">as</span> Extra                        // <b class="conum">(1)</b>
s.extra()                                               // <b class="conum">(2)</b>
s.doSomething()                                         // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 as 关键字在运行时将对象强制为特质</p>
</li>
<li>
<p>然后可以在对象上调用 extra</p>
</li>
<li>
<p>并且 doSomething 仍然可以调用</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
当将对象强制为特质时，操作的结果与原来的实例不是同一个实例。被强制的对象将实现原始对象实现的特质和接口，但不会是原始类的实例。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_一次实现多个特质"><a class="link" href="#_一次实现多个特质">4.5.11.2. 一次实现多个特质</a></h5>
<div class="paragraph">
<p>如果您需要一次实现多个特质，您可以使用 withTraits 方法而不是 as 关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait A { <span style="color:#339;font-weight:bold">void</span> methodFromA() {} }
trait B { <span style="color:#339;font-weight:bold">void</span> methodFromB() {} }

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">C</span> {}

<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#080;font-weight:bold">new</span> C()
c.methodFromA()                     // <b class="conum">(1)</b>
c.methodFromB()                     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> d = c.withTraits A, B           // <b class="conum">(3)</b>
d.methodFromA()                     // <b class="conum">(4)</b>
d.methodFromB()                     // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>调用 methodFromA 将失败，因为 C 未实现 A</p>
</li>
<li>
<p>调用 methodFromB 将失败，因为 C 未实现 B</p>
</li>
<li>
<p>withTrait 将把 c 包装成实现 A 和 B 的东西</p>
</li>
<li>
<p>methodFromA 现在将通过，因为 d 实现了 A</p>
</li>
<li>
<p>methodFromB 现在将通过，因为 d 也实现了 B</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
当将一个对象强制为多个特质时，操作的结果与原来的实例不是同一个实例。被强制的对象将实现原始对象实现的特质和接口，但不会是原始类的实例。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_链式行为"><a class="link" href="#_链式行为">4.5.12. 链式行为</a></h4>
<div class="paragraph">
<p>Groovy 支持可堆叠特质的概念。这个想法是，如果当前特质无法处理消息，则将一个特质委托给另一个特质。为了说明这一点，让我们想象一个像这样的消息处理程序接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> MessageHandler {
    <span style="color:#339;font-weight:bold">void</span> on(<span style="color:#0a8;font-weight:bold">String</span> message, <span style="color:#0a8;font-weight:bold">Map</span> payload)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以通过应用小行为来编写消息处理程序。例如，让我们以特质的形式定义一个默认处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait DefaultHandler <span style="color:#088;font-weight:bold">implements</span> MessageHandler {
    <span style="color:#339;font-weight:bold">void</span> on(<span style="color:#0a8;font-weight:bold">String</span> message, <span style="color:#0a8;font-weight:bold">Map</span> payload) {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Received </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>message</span><span style="color:#D20"> with payload </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>payload</span><span style="color:#710">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后任何类都可以通过实现该特质来继承默认处理程序的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SimpleHandler</span> <span style="color:#088;font-weight:bold">implements</span> DefaultHandler {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您想记录除了默认处理程序之外的所有消息怎么办？一种选择是这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SimpleHandlerWithLogging</span> <span style="color:#088;font-weight:bold">implements</span> DefaultHandler {
    <span style="color:#339;font-weight:bold">void</span> on(<span style="color:#0a8;font-weight:bold">String</span> message, <span style="color:#0a8;font-weight:bold">Map</span> payload) {                                  // <b class="conum">(1)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Seeing </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>message</span><span style="color:#D20"> with payload </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>payload</span><span style="color:#710">&quot;</span></span>                     // <b class="conum">(2)</b>
        DefaultHandler.super.on(message, payload)                           // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>显式实现 on 方法</p>
</li>
<li>
<p>执行日志记录</p>
</li>
<li>
<p>继续执行 DefaultHandler 特质中的行为</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这是可行的，但这种方法有缺点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>日志逻辑绑定到“具体”处理程序</p>
</li>
<li>
<p>我们在 on 方法中显式引用了 DefaultHandler ，这意味着如果我们碰巧更改了类实现的特质，代码将会被破坏</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>作为替代方案，我们可以编写另一个特质，其责任仅限于日志记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait LoggingHandler <span style="color:#088;font-weight:bold">implements</span> MessageHandler {                            // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">void</span> on(<span style="color:#0a8;font-weight:bold">String</span> message, <span style="color:#0a8;font-weight:bold">Map</span> payload) {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Seeing </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>message</span><span style="color:#D20"> with payload </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>payload</span><span style="color:#710">&quot;</span></span>                     // <b class="conum">(2)</b>
        <span style="color:#950">super</span>.on(message, payload)                                          // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>日志处理程序本身就是一个处理程序</p>
</li>
<li>
<p>打印收到的消息</p>
</li>
<li>
<p>然后 super 使其将调用委托给链中的下一个特质</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>那么我们的类可以重写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HandlerWithLogger</span> <span style="color:#088;font-weight:bold">implements</span> DefaultHandler, LoggingHandler {}
<span style="color:#080;font-weight:bold">def</span> loggingHandler = <span style="color:#080;font-weight:bold">new</span> HandlerWithLogger()
loggingHandler.on(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">test logging</span><span style="color:#710">'</span></span>, [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing test logging with payload [:]
Received test logging with payload [:]</pre>
</div>
</div>
<div class="paragraph">
<p>由于优先级规则意味着 LoggerHandler 获胜，因为它是最后声明的，因此对 on 的调用将使用 LoggingHandler 的实现。但后者调用了 super ，这意味着链中的下一个特质。在这里，下一个特质是 DefaultHandler 因此两者都会被调用：</p>
</div>
<div class="paragraph">
<p>如果我们添加第三个处理程序，该处理程序负责处理以 say 开头的消息，那么这种方法的好处就变得更加明显：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait SayHandler <span style="color:#088;font-weight:bold">implements</span> MessageHandler {
    <span style="color:#339;font-weight:bold">void</span> on(<span style="color:#0a8;font-weight:bold">String</span> message, <span style="color:#0a8;font-weight:bold">Map</span> payload) {
        <span style="color:#080;font-weight:bold">if</span> (message.startsWith(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">say</span><span style="color:#710">&quot;</span></span>)) {                                    // <b class="conum">(1)</b>
            println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I say </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>message - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">say</span><span style="color:#710">'</span></span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span>
        } <span style="color:#080;font-weight:bold">else</span> {
            <span style="color:#950">super</span>.on(message, payload)                                      // <b class="conum">(2)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>处理程序特定的先决条件</p>
</li>
<li>
<p>如果不满足前提条件，则将消息传递给链中的下一个处理程序</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然后我们的最终处理程序如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Handler</span> <span style="color:#088;font-weight:bold">implements</span> DefaultHandler, SayHandler, LoggingHandler {}
<span style="color:#080;font-weight:bold">def</span> h = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Handler</span>()
h.on(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, [:])
h.on(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sayHello</span><span style="color:#710">'</span></span>, [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息将首先通过日志处理程序</p>
</li>
<li>
<p>日志处理程序调用 super ，它将委托给下一个处理程序，即 SayHandler</p>
</li>
<li>
<p>如果消息以 say 开头，则处理程序将使用该消息</p>
</li>
<li>
<p>如果没有， say 处理程序将委托给链中的下一个处理程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法非常强大，因为它允许您编写彼此不认识的处理程序，但又可以按照您想要的顺序组合它们。例如，如果我们执行代码，它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>但是如果我们将日志处理程序移至链中的第二个，则输出会有所不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AlternateHandler</span> <span style="color:#088;font-weight:bold">implements</span> DefaultHandler, LoggingHandler, SayHandler {}
h = <span style="color:#080;font-weight:bold">new</span> AlternateHandler()
h.on(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, [:])
h.on(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">sayHello</span><span style="color:#710">'</span></span>, [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>原因是，现在，由于 SayHandler 在不调用 super 的情况下使用消息，因此不再调用日志记录处理程序。</p>
</div>
<div class="sect4">
<h5 id="_trait_内_super_的语义"><a class="link" href="#_trait_内_super_的语义">4.5.12.1. Trait 内 super 的语义</a></h5>
<div class="paragraph">
<p>如果一个类实现了多个特质并且发现了对 super 的调用，则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果该类实现了另一个特质，则调用将委托给链中的下一个特质</p>
</li>
<li>
<p>如果链中没有剩余的特质了，则 super 引用实现类的超类（this）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，由于以下行为，可以装饰最终类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Filtering {                                       // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">StringBuilder</span> append(<span style="color:#0a8;font-weight:bold">String</span> str) {                  // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">def</span> subst = str.replace(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">o</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>)                 // <b class="conum">(3)</b>
        <span style="color:#950">super</span>.append(subst)                             // <b class="conum">(4)</b>
    }
    <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="color:#950">super</span>.toString() }              // <b class="conum">(5)</b>
}
<span style="color:#080;font-weight:bold">def</span> sb = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">StringBuilder</span>().withTraits Filtering       // <b class="conum">(6)</b>
sb.append(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> sb.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Grvy</span><span style="color:#710">'</span></span>                          // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义一个名为 Filtering 的特质，应该在运行时应用于 StringBuilder</p>
</li>
<li>
<p>重新定义 append 方法</p>
</li>
<li>
<p>删除字符串中的所有“o”</p>
</li>
<li>
<p>然后委托给 super</p>
</li>
<li>
<p>如果调用 toString ，则委托给 super.toString</p>
</li>
<li>
<p>StringBuilder 实例上 Filtering 特质的运行时实现</p>
</li>
<li>
<p>已附加的字符串不再包含字母 o</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在这个例子中，当遇到 super.append 时，目标对象没有实现其他trait，所以调用的方法是原来的 append 方法，也就是说来自 StringBuilder 。同样的技巧也用于 toString ，以便生成的代理对象的字符串表示形式委托给 StringBuilder 实例的 toString 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_高级功能"><a class="link" href="#_高级功能">4.5.13. 高级功能</a></h4>
<div class="sect4">
<h5 id="_sam_类型强制"><a class="link" href="#_sam_类型强制">4.5.13.1. SAM 类型强制</a></h5>
<div class="paragraph">
<p>如果一个特质定义了单个抽象方法，那么它就是 SAM（单个抽象方法）类型强制的候选者。例如，想象一下以下特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Greeter {
    <span style="color:#0a8;font-weight:bold">String</span> greet() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span> }        // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#0a8;font-weight:bold">String</span> getName()               // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>greet 方法不是抽象方法，调用抽象方法 getName</p>
</li>
<li>
<p>getName 是一个抽象方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>由于 getName 是 Greeter 特质中的单个抽象方法，因此您可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Greeter greeter = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span> }               // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>闭包“成为” getName 单个抽象方法的实现</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>or even:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">void</span> greet(Greeter g) { println g.greet() } // <b class="conum">(1)</b>
greet { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span> }                           // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>greet 方法接受 SAM 类型 Greeter 作为参数</p>
</li>
<li>
<p>我们可以直接调用它, 并传递闭包</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_与_java_8_默认方法的差异"><a class="link" href="#_与_java_8_默认方法的差异">4.5.13.2. 与 Java 8 默认方法的差异</a></h5>
<div class="paragraph">
<p>在 Java 8 中，接口可以具有default方法。如果一个类实现了一个接口并且没有重写该default方法，则会使用接口的default方法。特质与此类似，但有一个主要区别：<strong>如果特质和父类上有相同的方法, 那么默认使用特质上的</strong>.</p>
</div>
<div class="paragraph">
<p>如果您想覆盖已实现的方法的行为，此功能可用于以非常精确的方式组合行为。</p>
</div>
<div class="paragraph">
<p>为了说明这个概念，让我们从这个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.test.GroovyTestCase</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.CompileStatic</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.control.CompilerConfiguration</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.control.customizers.ASTTransformationCustomizer</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.control.customizers.ImportCustomizer</span>

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SomeTest</span> <span style="color:#088;font-weight:bold">extends</span> GroovyTestCase {
    <span style="color:#080;font-weight:bold">def</span> config
    <span style="color:#080;font-weight:bold">def</span> shell

    <span style="color:#339;font-weight:bold">void</span> setup() {
        config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
        shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
    }
    <span style="color:#339;font-weight:bold">void</span> testSomething() {
        <span style="color:#080;font-weight:bold">assert</span> shell.evaluate(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">1+1</span><span style="color:#710">'</span></span>) == <span style="color:#00D">2</span>
    }
    <span style="color:#339;font-weight:bold">void</span> otherTest() { <span style="color:#777">/* ... */</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们创建一个简单的测试用例，它使用两个属性（config 和 shell）并在多个测试方法中使用这些属性。现在假设您想要测试相同的内容，但使用另一个不同的编译器配置。一种选择是创建 SomeTest 的子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AnotherTest</span> <span style="color:#088;font-weight:bold">extends</span> SomeTest {
    <span style="color:#339;font-weight:bold">void</span> setup() {
        config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它有效，但是如果您实际上有多个测试类，并且您想要测试所有这些测试类的新配置怎么办？然后你必须为每个测试类创建一个不同的子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">YetAnotherTest</span> <span style="color:#088;font-weight:bold">extends</span> SomeTest {
    <span style="color:#339;font-weight:bold">void</span> setup() {
        config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后你看到的是，两个测试的 setup 方法是相同的。那么，我们的办法就是创造一个特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait MyTestSupport {
    <span style="color:#339;font-weight:bold">void</span> setup() {
        config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
        config.addCompilationCustomizers( <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(CompileStatic) )
        shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在子类中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AnotherTest</span> <span style="color:#088;font-weight:bold">extends</span> SomeTest <span style="color:#088;font-weight:bold">implements</span> MyTestSupport {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">YetAnotherTest</span> <span style="color:#088;font-weight:bold">extends</span> SomeTest2 <span style="color:#088;font-weight:bold">implements</span> MyTestSupport {}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将允许我们显着减少样板代码，并降低在我们决定更改设置代码时忘记更改设置代码的风险。<strong>即使 setup 已经在父类中实现，由于测试类在其接口列表中声明了特质，因此默认使用特质中的行为</strong>！</p>
</div>
<div class="paragraph">
<p>当您无法访问父类源代码时，此功能特别有用。它可用于模拟方法或强制子类中方法的特定实现。它允许您重构代码，将被覆盖的逻辑保留在单个特质中，并通过实现它来继承新的行为。当然，另一种方法是在您将使用新代码的每个地方重写该方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
值得注意的是，如果您使用运行时特质，则特质中的方法始终优先于原始对象的方法：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name                                         // <b class="conum">(1)</b>
}
trait Bob {
    <span style="color:#0a8;font-weight:bold">String</span> getName() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span> }                          // <b class="conum">(2)</b>
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> p.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span>                                // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> p2 = p <span style="color:#080;font-weight:bold">as</span> Bob                                       // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> p2.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>                                 // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Person 类定义了 name 属性，该属性产生 getName 方法</p>
</li>
<li>
<p>Bob 是一个特质，它将 getName 定义为返回 Bob</p>
</li>
<li>
<p>默认对象将返回 Alice</p>
</li>
<li>
<p>p2 在运行时将 p 强制转换为 Bob</p>
</li>
<li>
<p>getName 返回 Bob，因为 getName 来自特质</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Again, don&#8217;t forget that dynamic trait coercion returns a distinct object which only implements the original
interfaces, as well as the traits.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_与_mixins_的区别"><a class="link" href="#_与_mixins_的区别">4.5.14. 与 mixins 的区别</a></h4>
<div class="paragraph">
<p>Mixins 在概念上存在一些差异，因为它们在 Groovy 中可用。请注意，我们谈论的是运行时 mixin，而不是 @Mixin 注解，@Mixin 注解已被弃用。</p>
</div>
<div class="paragraph">
<p>首先，特质中定义的方法在字节码中可见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在内部，该特质表示为一个接口（没有默认或静态方法）和几个辅助类</p>
</li>
<li>
<p>这意味着实现特质的对象有效地实现了接口</p>
</li>
<li>
<p>这些方法在 Java 中是可见的</p>
</li>
<li>
<p>它们与类型检查和静态编译兼容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相反，通过 mixin 添加的方法仅在运行时可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">A</span> { <span style="color:#0a8;font-weight:bold">String</span> methodFromA() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span> } }        // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">B</span> { <span style="color:#0a8;font-weight:bold">String</span> methodFromB() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">B</span><span style="color:#710">'</span></span> } }        // <b class="conum">(2)</b>
A.metaClass.mixin B                             // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> o = <span style="color:#080;font-weight:bold">new</span> A()
<span style="color:#080;font-weight:bold">assert</span> o.methodFromA() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>                   // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> o.methodFromB() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">B</span><span style="color:#710">'</span></span>                   // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> o <span style="color:#080;font-weight:bold">instanceof</span> A                           // <b class="conum">(6)</b>
<span style="color:#080;font-weight:bold">assert</span> !(o <span style="color:#080;font-weight:bold">instanceof</span> B)                        // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类 A 定义 methodFromA</p>
</li>
<li>
<p>类 B 定义 methodFromB</p>
</li>
<li>
<p>将B混入A中</p>
</li>
<li>
<p>我们可以调用 methodFromA</p>
</li>
<li>
<p>我们也可以调用 methodFromB</p>
</li>
<li>
<p>该对象是 A 的实例</p>
</li>
<li>
<p>但它不是 B 的实例</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>最后一点实际上非常重要，它说明了 mixin 比 Trait 具有优势的地方：实例不会被修改，因此如果您将某个类混合到另一个类中，则不会生成第三个类，and methods which respond to A will continue responding to A even if mixed in.</p>
</div>
</div>
<div class="sect3">
<h4 id="_静态的方法属性和字段"><a class="link" href="#_静态的方法属性和字段">4.5.15. 静态的方法、属性和字段</a></h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
以下说明需谨慎。静态成员支持正在进行中，并且仍处于试验阶段。以下信息仅适用于 {groovyVersion}。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以在特质中定义静态方法，但它有许多限制：
* 具有静态方法的特质无法进行静态编译或类型检查。所有静态方法、属性和字段都是动态访问的（这是 JVM 的限制）。
* 静态方法不会出现在每个特质生成的接口中。
* 该特质被视为实现类的模板，这意味着每个实现类将获得自己的静态方法、属性和字段。因此，在特质上声明的静态成员不属于 Trait ，而是属于其实现类。
* You should typically not mix static and instance methods of the same signature. The normal
rules for applying traits apply (including multiple inheritance conflict resolution). If the
method chosen is static but some implemented trait has an instance variant, a compilation error
will occur. If the method chosen is the instance variant, the static variant will be ignored
(the behavior is similar to static methods in Java interfaces for this case).
通常不应混合具有相同签名的静态方法和实例方法。应用特质的正常规则适用（包括多重继承冲突解决）。如果选择的方法是静态的，但某些实现的特质具有实例变体，则会发生编译错误。如果选择的方法是实例变体，则静态变体将被忽略（在这种情况下，其行为类似于 Java 接口中的静态方法）。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait TestHelper {
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">boolean</span> CALLED = <span style="color:#069">false</span>        // <b class="conum">(1)</b>
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> init() {                        // <b class="conum">(2)</b>
        CALLED = <span style="color:#069">true</span>                           // <b class="conum">(3)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> <span style="color:#088;font-weight:bold">implements</span> TestHelper {}
Foo.init()                                      // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> Foo.TestHelper__CALLED                   // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>静态字段在特质中声明</p>
</li>
<li>
<p>特质中还声明了一个静态方法</p>
</li>
<li>
<p>静态字段在特质内更新</p>
</li>
<li>
<p>静态方法 init 可供实现类使用</p>
</li>
<li>
<p>重新映射静态场以避免钻石问题</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>与往常一样，不建议使用公共字段。不管怎样，如果你想要这个，你必须明白下面的代码会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Foo.CALLED = <span style="color:#069">true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>因为特质本身没有定义静态字段 CALLED。同样，如果您有两个不同的实现类，则每个类都会获得一个不同的静态字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bar</span> <span style="color:#088;font-weight:bold">implements</span> TestHelper {}              // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Baz</span> <span style="color:#088;font-weight:bold">implements</span> TestHelper {}              // <b class="conum">(2)</b>
Bar.init()                                      // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> Bar.TestHelper__CALLED                   // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> !Baz.TestHelper__CALLED                  // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类 Bar 实现该特质</p>
</li>
<li>
<p>类 Baz 也实现了该特质</p>
</li>
<li>
<p>init 仅在 Bar 上调用</p>
</li>
<li>
<p>Bar 上的静态字段 CALLED 已更新</p>
</li>
<li>
<p>但 Baz 上的静态字段 CALLED 不是，因为它是不同的</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_状态继承的陷阱"><a class="link" href="#_状态继承的陷阱">4.5.16. 状态继承的陷阱</a></h4>
<div class="paragraph">
<p>我们已经看到特质是有状态的。特质可以定义字段或属性，但是当类实现特质时，它会根据每个特质获取这些字段/属性。因此，请考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait IntCouple {
    <span style="color:#339;font-weight:bold">int</span> x = <span style="color:#00D">1</span>
    <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">2</span>
    <span style="color:#339;font-weight:bold">int</span> sum() { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该特质定义了两个属性， x 和 y ，以及一个 sum 方法。现在让我们创建一个实现该特质的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">BaseElem</span> <span style="color:#088;font-weight:bold">implements</span> IntCouple {
    <span style="color:#339;font-weight:bold">int</span> f() { sum() }
}
<span style="color:#080;font-weight:bold">def</span> base = <span style="color:#080;font-weight:bold">new</span> BaseElem()
<span style="color:#080;font-weight:bold">assert</span> base.f() == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>调用 f 的结果是 3 ，因为 f 委托给特质中的 sum ，它具有状态。但如果我们改写这个呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Elem</span> <span style="color:#088;font-weight:bold">implements</span> IntCouple {
    <span style="color:#339;font-weight:bold">int</span> x = <span style="color:#00D">3</span>                                       // <b class="conum">(1)</b>
    <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">4</span>                                       // <b class="conum">(2)</b>
    <span style="color:#339;font-weight:bold">int</span> f() { sum() }                               // <b class="conum">(3)</b>
}
<span style="color:#080;font-weight:bold">def</span> elem = <span style="color:#080;font-weight:bold">new</span> Elem()</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>覆盖属性 x</p>
</li>
<li>
<p>覆盖属性 y</p>
</li>
<li>
<p>从特质调用 sum</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您调用 elem.f() ，预期输出是什么？其实是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> elem.f() == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>原因是 sum 方法访问特质的字段。因此它使用特质中定义的 x 和 y 值。如果您想使用实现类中的值，则需要使用 getter 和 setter 来取消引用字段，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait IntCouple {
    <span style="color:#339;font-weight:bold">int</span> x = <span style="color:#00D">1</span>
    <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">2</span>
    <span style="color:#339;font-weight:bold">int</span> sum() { getX()+getY() }
}

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Elem</span> <span style="color:#088;font-weight:bold">implements</span> IntCouple {
    <span style="color:#339;font-weight:bold">int</span> x = <span style="color:#00D">3</span>
    <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">4</span>
    <span style="color:#339;font-weight:bold">int</span> f() { sum() }
}
<span style="color:#080;font-weight:bold">def</span> elem = <span style="color:#080;font-weight:bold">new</span> Elem()
<span style="color:#080;font-weight:bold">assert</span> elem.f() == <span style="color:#00D">7</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_self_types"><a class="link" href="#_self_types">4.5.17. Self types</a></h4>
<div class="sect4">
<h5 id="_特质的类型限制"><a class="link" href="#_特质的类型限制">4.5.17.1. 特质的类型限制</a></h5>
<div class="paragraph">
<p>有时您会想编写一个只能应用于某种类型的特质。例如，您可能希望在一个类上应用一个特质，该特质扩展了另一个超出您控制范围的类，并且仍然能够调用这些方法。为了说明这一点，让我们从这个例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CommunicationService</span> {
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> sendMessage(<span style="color:#0a8;font-weight:bold">String</span> from, <span style="color:#0a8;font-weight:bold">String</span> to, <span style="color:#0a8;font-weight:bold">String</span> message) {       // <b class="conum">(1)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>from</span><span style="color:#D20"> sent [</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>message</span><span style="color:#D20">] to </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>to</span><span style="color:#710">&quot;</span></span>
    }
}

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Device</span> { <span style="color:#0a8;font-weight:bold">String</span> id }                                                  // <b class="conum">(2)</b>

trait Communicating {
    <span style="color:#339;font-weight:bold">void</span> sendMessage(Device to, <span style="color:#0a8;font-weight:bold">String</span> message) {
        CommunicationService.sendMessage(id, to.id, message)                // <b class="conum">(3)</b>
    }
}

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyDevice</span> <span style="color:#088;font-weight:bold">extends</span> Device <span style="color:#088;font-weight:bold">implements</span> Communicating {}                   // <b class="conum">(4)</b>

<span style="color:#080;font-weight:bold">def</span> bob = <span style="color:#080;font-weight:bold">new</span> MyDevice(<span style="color:#606">id</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bob</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> alice = <span style="color:#080;font-weight:bold">new</span> MyDevice(<span style="color:#606">id</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Alice</span><span style="color:#710">'</span></span>)
bob.sendMessage(alice,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">secret</span><span style="color:#710">'</span></span>)                                             // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A <code>Service</code> class, beyond your control (in a library, &#8230;&#8203;) defines a <code>sendMessage</code> method</p>
</li>
<li>
<p>A <code>Device</code> class, beyond your control (in a library, &#8230;&#8203;)</p>
</li>
<li>
<p>Defines a communicating trait for devices that can call the service</p>
</li>
<li>
<p>Defines <code>MyDevice</code> as a communicating device</p>
</li>
<li>
<p>The method from the trait is called, and <code>id</code> is resolved</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>很明显， Communicating 特质只能应用于 Device 。然而，没有明确的契约表明这一点，因为特质不能扩展类。然而，代码编译并运行得很好，因为特质方法中的 id 将被动态解析。问题是没有什么可以阻止该特质应用于任何不是 Device 的类。任何具有 id 属性的类都可以工作，而任何不具有 id 属性的类都会导致运行时错误。</p>
</div>
<div class="paragraph">
<p>如果您想启用类型检查或在特质上应用 @CompileStatic ，问题会更加复杂：因为特质不知道自己是 Device ，类型检查器会抱怨说它找不到 id 属性。</p>
</div>
<div class="paragraph">
<p>一种可能性是在特质中显式添加 getId 方法，但这并不能解决所有问题。如果一个方法需要 this 作为参数，并且实际上要求它是 Device 该怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SecurityService</span> {
    <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> check(Device d) { <span style="color:#080;font-weight:bold">if</span> (d.id==<span style="color:#069">null</span>) <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">SecurityException</span>() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您希望能够在特质中调用 this ，那么您将明确需要将 this 转换为 Device 。如果到处显式转换为 this ，这很快就会变得不可读。</p>
</div>
</div>
<div class="sect4">
<h5 id="traits-selftype"><a class="link" href="#traits-selftype">4.5.17.2. @SelfType注解</a></h5>
<div class="paragraph">
<p>为了使这个契约明确，并使类型检查器了解其自身的类型，Groovy 提供了一个 @SelfType 注解，它将：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>让您声明实现此特质的类必须继承或实现的类型</p>
</li>
<li>
<p>如果不满足这些类型约束，则抛出编译时错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，在前面的示例中，我们可以使用 @groovy.transform.SelfType 注解来修复该特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@SelfType</span>(Device)
<span style="color:#007">@CompileStatic</span>
trait Communicating {
    <span style="color:#339;font-weight:bold">void</span> sendMessage(Device to, <span style="color:#0a8;font-weight:bold">String</span> message) {
        SecurityService.check(<span style="color:#950">this</span>)
        CommunicationService.sendMessage(id, to.id, message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您尝试在不是 Device 的类上实现此特质，则会出现编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyDevice</span> <span style="color:#088;font-weight:bold">implements</span> Communicating {} <span style="color:#777">// forgot to extend Device</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>错误将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'</pre>
</div>
</div>
<div class="paragraph">
<p>总之，自我类型是声明对特质的约束的有效方式，而不必直接在特质中声明契约或必须在各处使用强制转换，从而保持关注点的分离尽可能紧密。</p>
</div>
</div>
<div class="sect4">
<h5 id="_与_sealed_注解孵化中的差异"><a class="link" href="#_与_sealed_注解孵化中的差异">4.5.17.3. 与 Sealed 注解（孵化中）的差异</a></h5>
<div class="paragraph">
<p>Both <code>@Sealed</code> and <code>@SelfType</code> restrict classes which use a trait but in orthogonal ways.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> HasHeight { <span style="color:#339;font-weight:bold">double</span> getHeight() }
<span style="color:#339;font-weight:bold">interface</span> HasArea { <span style="color:#339;font-weight:bold">double</span> getArea() }

<span style="color:#007">@SelfType</span>([HasHeight, HasArea])                       // <b class="conum">(1)</b>
<span style="color:#007">@Sealed</span>(permittedSubclasses=[UnitCylinder,UnitCube])  // <b class="conum">(2)</b>
trait HasVolume {
    <span style="color:#339;font-weight:bold">double</span> getVolume() { height * area }
}

<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">UnitCube</span> <span style="color:#088;font-weight:bold">implements</span> HasVolume, HasHeight, HasArea {
    <span style="color:#777">// for the purposes of this example: h=1, w=1, l=1</span>
    <span style="color:#339;font-weight:bold">double</span> height = <span style="color:#60E">1d</span>
    <span style="color:#339;font-weight:bold">double</span> area = <span style="color:#60E">1d</span>
}

<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">UnitCylinder</span> <span style="color:#088;font-weight:bold">implements</span> HasVolume, HasHeight, HasArea {
    <span style="color:#777">// for the purposes of this example: h=1, diameter=1</span>
    <span style="color:#777">// radius=diameter/2, area=PI * r^2</span>
    <span style="color:#339;font-weight:bold">double</span> height = <span style="color:#60E">1d</span>
    <span style="color:#339;font-weight:bold">double</span> area = <span style="color:#0a8;font-weight:bold">Math</span>.PI * <span style="color:#60E">0.5d</span>**<span style="color:#00D">2</span>
}

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> UnitCube().volume == <span style="color:#60E">1d</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> UnitCylinder().volume == <span style="color:#60E">0.7853981633974483d</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>All usages of the <code>HasVolume</code> trait must implement or extend both <code>HasHeight</code> and <code>HasArea</code></p>
</li>
<li>
<p>Only <code>UnitCube</code> or <code>UnitCylinder</code> can use the trait</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For the degenerate case where a single class implements a trait, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> <span style="color:#088;font-weight:bold">implements</span> FooTrait {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, either:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@SelfType</span>(Foo)
trait FooTrait {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Sealed</span>(permittedSubclasses=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>) // <b class="conum">(1)</b>
trait FooTrait {}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Or just <code>@Sealed</code> if <code>Foo</code> and <code>FooTrait</code> are in the same source file</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>could express this constraint. Generally, the former of these is preferred.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_局限性"><a class="link" href="#_局限性">4.5.18. 局限性</a></h4>
<div class="sect4">
<h5 id="_与_ast_转换的兼容性"><a class="link" href="#_与_ast_转换的兼容性">4.5.18.1. 与 AST 转换的兼容性</a></h5>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Traits 与 AST 转换不是正式兼容。其中一些（例如 @CompileStatic ）将应用于特质本身（而不是实现类），而其他一些将应用于实现类和特质。绝对不能保证 AST 转换会像在常规类上一样在特质上运行，因此使用它需要您自担风险！
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_前缀和后缀操作"><a class="link" href="#_前缀和后缀操作">4.5.18.2. 前缀和后缀操作</a></h5>
<div class="paragraph">
<p>在特质中，不允许使用前缀和后缀操作更新特质的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">trait Counting {
    <span style="color:#339;font-weight:bold">int</span> x
    <span style="color:#339;font-weight:bold">void</span> inc() {
        x++                             // <b class="conum">(1)</b>
    }
    <span style="color:#339;font-weight:bold">void</span> dec() {
        --x                             // <b class="conum">(2)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Counter</span> <span style="color:#088;font-weight:bold">implements</span> Counting {}
<span style="color:#080;font-weight:bold">def</span> c = <span style="color:#080;font-weight:bold">new</span> Counter()
c.inc()</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>x 在特质中定义，不允许后缀增量</p>
</li>
<li>
<p>x 在特质中定义，不允许前缀递减</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>解决方法是使用 += 运算符。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record类_孵化中"><a class="link" href="#_record类_孵化中">4.6. Record类 (孵化中)</a></h3>
<div class="paragraph">
<p>Record类是一种特殊的类，可用于对普通数据聚合进行建模。它们提供了比普通类更少的紧凑语法。 Groovy 已经具有 AST 转换，例如 @Immutable 和 @Canonical ，它们已经大大减少了仪式，但Record已经在 Java 中引入，并且 Groovy 中的Record类被设计为与 Java Record类保持一致。</p>
</div>
<div class="paragraph">
<p>例如，假设我们要创建代表电子邮件的 Message 的Record类。出于本示例的目的，我们将此类消息简化为仅包含发件人电子邮件地址、收件人电子邮件地址和消息正文。我们可以如下定义这样的Record类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record Message(<span style="color:#0a8;font-weight:bold">String</span> from, <span style="color:#0a8;font-weight:bold">String</span> to, <span style="color:#0a8;font-weight:bold">String</span> body) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将以与普通类相同的方式使用Record类，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> msg = <span style="color:#080;font-weight:bold">new</span> Message(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">me@myhost.com</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">you@yourhost.net</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello!</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> msg.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Message[from=me@myhost.com, to=you@yourhost.net, body=Hello!]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>简化的仪式使我们免于定义显式字段、getter 和 toString 、 equals 和 hashCode 方法。事实上，它是以下粗略等效的简写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Message</span> <span style="color:#088;font-weight:bold">extends</span> Record {
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> from
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> to
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> body
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">long</span> serialVersionUID = <span style="color:#00D">0</span>

    <span style="color:#777">/* constructor(s) */</span>

    <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="color:#777">/*...*/</span> }

    <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">boolean</span> equals(<span style="color:#0a8;font-weight:bold">Object</span> other) { <span style="color:#777">/*...*/</span> }

    <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">int</span> hashCode() { <span style="color:#777">/*...*/</span> }

    <span style="color:#0a8;font-weight:bold">String</span> from() { from }
    <span style="color:#777">// other getters ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意Record类的getter的特殊命名约定。它们与字段同名（而不是常见的 JavaBean 惯例，大写并带有“get”前缀）。</p>
</div>
<div class="paragraph">
<p>就像在 Java 中一样，您可以通过编写自己的方法来覆盖通常隐式提供的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record Point3D(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#339;font-weight:bold">int</span> z) {
    <span style="color:#0a8;font-weight:bold">String</span> toString() {
        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Point3D[coords=</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>x</span><span style="color:#D20">,</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>y</span><span style="color:#D20">,</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>z</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>
    }
}

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> Point3D(<span style="color:#00D">10</span>, <span style="color:#00D">20</span>, <span style="color:#00D">30</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Point3D[coords=10,20,30]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以以正常方式对Record类使用泛型。例如，考虑以下 Coord Record类定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record Coord&lt;T <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Number</span>&gt;(T v1, T v2){
    <span style="color:#339;font-weight:bold">double</span> distFromOrigin() { <span style="color:#0a8;font-weight:bold">Math</span>.sqrt(v1()**<span style="color:#00D">2</span> + v2()**<span style="color:#00D">2</span> <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">double</span>) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以按如下方式使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> r1 = <span style="color:#080;font-weight:bold">new</span> Coord&lt;<span style="color:#0a8;font-weight:bold">Integer</span>&gt;(<span style="color:#00D">3</span>, <span style="color:#00D">4</span>)
<span style="color:#080;font-weight:bold">assert</span> r1.distFromOrigin() == <span style="color:#00D">5</span>
<span style="color:#080;font-weight:bold">def</span> r2 = <span style="color:#080;font-weight:bold">new</span> Coord&lt;<span style="color:#0a8;font-weight:bold">Double</span>&gt;(<span style="color:#60E">6d</span>, <span style="color:#60E">2.5d</span>)
<span style="color:#080;font-weight:bold">assert</span> r2.distFromOrigin() == <span style="color:#60E">6.5d</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_record类的特殊功能"><a class="link" href="#_record类的特殊功能">4.6.1. Record类的特殊功能</a></h4>
<div class="sect4">
<h5 id="_紧凑的构造函数"><a class="link" href="#_紧凑的构造函数">4.6.1.1. 紧凑的构造函数</a></h5>
<div class="paragraph">
<p>记录有一个隐式构造函数。这可以通过提供您自己的构造函数来覆盖 - 如果您这样做，您需要确保设置所有字段。</p>
</div>
<div class="paragraph">
<p>然而，为了简洁起见，可以使用紧凑的构造函数语法。</p>
</div>
<div class="paragraph">
<p>对于这种特殊情况，仍然提供正常的隐式构造函数，但通过紧凑构造函数定义中提供的语句进行了扩充：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">public</span> record Warning(<span style="color:#0a8;font-weight:bold">String</span> message) {
    <span style="color:#088;font-weight:bold">public</span> Warning {
        Objects.requireNonNull(message)
        message = message.toUpperCase()
    }
}

<span style="color:#080;font-weight:bold">def</span> w = <span style="color:#080;font-weight:bold">new</span> Warning(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Help</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> w.message() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">HELP</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_序列化"><a class="link" href="#_序列化">4.6.1.2. 序列化</a></h5>
<div class="paragraph">
<p>Groovy native records类遵循适用于 Java record的可序列化性的https://docs.oracle.com/en/java/javase/16/docs/specs/records-serialization.html[特殊约定]。 Groovy record-like 的类（下面讨论）遵循普通的 Java 类可序列化约定。</p>
</div>
<div class="paragraph">
<p>Groovy <em>native</em> records follow the</p>
</div>
<div class="paragraph">
<p>for serializability which apply to Java records.
Groovy <em>record-like</em> classes (discussed below) follow normal Java class serializability conventions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_groovy_对record类的增强"><a class="link" href="#_groovy_对record类的增强">4.6.2. Groovy 对Record类的增强</a></h4>
<div class="sect4">
<h5 id="_参数默认值"><a class="link" href="#_参数默认值">4.6.2.1. 参数默认值</a></h5>
<div class="paragraph">
<p>Groovy 支持构造函数参数的默认值。此功能也适用于记录，如以下记录定义所示，该定义具有 y 和 color 的默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record ColoredPoint(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">0</span>, <span style="color:#0a8;font-weight:bold">String</span> color = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">white</span><span style="color:#710">'</span></span>) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments when left off (dropping one or more arguments from the right) are replaced
with their defaults values as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint(<span style="color:#00D">5</span>, <span style="color:#00D">5</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">black</span><span style="color:#710">'</span></span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint[x=5, y=5, color=black]</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint(<span style="color:#00D">5</span>, <span style="color:#00D">5</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint[x=5, y=5, color=white]</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint(<span style="color:#00D">5</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint[x=5, y=0, color=white]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此处理遵循构造函数默认参数的常规 Groovy 约定，本质上自动为构造函数提供以下签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ColoredPoint(<span style="color:#339;font-weight:bold">int</span>, <span style="color:#339;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">String</span>)
ColoredPoint(<span style="color:#339;font-weight:bold">int</span>, <span style="color:#339;font-weight:bold">int</span>)
ColoredPoint(<span style="color:#339;font-weight:bold">int</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用命名参数（默认值也适用于此）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint(<span style="color:#606">x</span>: <span style="color:#00D">5</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint[x=5, y=0, color=white]</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint(<span style="color:#606">x</span>: <span style="color:#00D">0</span>, <span style="color:#606">y</span>: <span style="color:#00D">5</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint[x=0, y=5, color=white]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以禁用默认参数处理，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@TupleConstructor</span>(defaultsMode=DefaultsMode.OFF)
record ColoredPoint2(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) {}
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint2(<span style="color:#00D">4</span>, <span style="color:#00D">5</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">red</span><span style="color:#710">'</span></span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint2[x=4, y=5, color=red]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将按照 Java 的默认值生成一个构造函数。如果在这种情况下省略参数，将会出现错误。</p>
</div>
<div class="paragraph">
<p>您可以强制所有属性具有默认值，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@TupleConstructor</span>(defaultsMode=DefaultsMode.ON)
record ColoredPoint3(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y = <span style="color:#00D">0</span>, <span style="color:#0a8;font-weight:bold">String</span> color = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">white</span><span style="color:#710">'</span></span>) {}
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> ColoredPoint3(<span style="color:#606">y</span>: <span style="color:#00D">5</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ColoredPoint3[x=0, y=5, color=white]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>任何没有显式初始值的属性/字段都将被赋予参数类型的默认值（null，0, false）。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">深入研究</div>
<div class="paragraph">
<p>我们之前描述了 Message 记录并显示了它的粗略等效项。 Groovy 实际上会经历一个中间阶段，其中 record 关键字被 class 关键字和随附的 @RecordType 注释替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@RecordType</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Message</span> {
    <span style="color:#0a8;font-weight:bold">String</span> from
    <span style="color:#0a8;font-weight:bold">String</span> to
    <span style="color:#0a8;font-weight:bold">String</span> body
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，@RecordType 本身被处理为元注解（注解集合器），并扩展为其组成的子注解，如 @TupleConstructor、@POJO、@RecordBase 等。在某种意义上，这是一个可以经常忽略的实现细节。然而，如果您希望自定义或配置记录实现，您可能希望回退到 @RecordType 风格，或者用其中一个组成子注解来增强您的记录类。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_自定义tostring"><a class="link" href="#_自定义tostring">4.6.2.2. 自定义toString</a></h5>
<div class="paragraph">
<p>根据 Java，您可以通过编写自己的方法来自定义记录的 toString 方法。如果您更喜欢更具声明性的样式，您也可以使用 Groovy 的 @ToString 转换来覆盖默认记录 toString 。例如，可以按如下方式记录三维点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">package</span> threed

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.ToString</span>

<span style="color:#007">@ToString</span>(ignoreNulls=<span style="color:#069">true</span>, cache=<span style="color:#069">true</span>, includeNames=<span style="color:#069">true</span>,
          leftDelimiter=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[</span><span style="color:#710">'</span></span>, rightDelimiter=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">]</span><span style="color:#710">'</span></span>, nameValueSeparator=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">=</span><span style="color:#710">'</span></span>)
record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#0a8;font-weight:bold">Integer</span> x, <span style="color:#0a8;font-weight:bold">Integer</span> y, <span style="color:#0a8;font-weight:bold">Integer</span> z=<span style="color:#069">null</span>) { }

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">10</span>, <span style="color:#00D">20</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">threed.Point[x=10, y=20]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义 toString:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>includeNames=true, 包含包名和类名, 默认为false</p>
</li>
<li>
<p>cache=true, 缓存toString的值, 因为我们不会改变Record中的值</p>
</li>
<li>
<p>ignoreNulls=true, 忽略null值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于二维点，我们可以有类似的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">package</span> twod

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.ToString</span>

<span style="color:#007">@ToString</span>(ignoreNulls=<span style="color:#069">true</span>, cache=<span style="color:#069">true</span>, includeNames=<span style="color:#069">true</span>,
          leftDelimiter=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[</span><span style="color:#710">'</span></span>, rightDelimiter=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">]</span><span style="color:#710">'</span></span>, nameValueSeparator=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">=</span><span style="color:#710">'</span></span>)
record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#0a8;font-weight:bold">Integer</span> x, <span style="color:#0a8;font-weight:bold">Integer</span> y) { }

<span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">10</span>, <span style="color:#00D">20</span>).toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">twod.Point[x=10, y=20]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在这里看到，如果没有包名称，它将具有与前面的示例相同的 toString。</p>
</div>
</div>
<div class="sect4">
<h5 id="_获取record中所有属性的值"><a class="link" href="#_获取record中所有属性的值">4.6.2.3. 获取Record中所有属性的值</a></h5>
<div class="paragraph">
<p>我们可以从记录中获取组件值作为列表，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) { }

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">100</span>, <span style="color:#00D">200</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> (x, y, c) = p.toList()
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">100</span>
<span style="color:#080;font-weight:bold">assert</span> y == <span style="color:#00D">200</span>
<span style="color:#080;font-weight:bold">assert</span> c == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 @RecordOptions(toList=false) 禁用此功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_获取record中所有属性对应的map"><a class="link" href="#_获取record中所有属性对应的map">4.6.2.4. 获取Record中所有属性对应的map</a></h5>
<div class="paragraph">
<p>我们可以从记录中获取组件值作为映射，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) { }

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">100</span>, <span style="color:#00D">200</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> p.toMap() == [<span style="color:#606">x</span>: <span style="color:#00D">100</span>, <span style="color:#606">y</span>: <span style="color:#00D">200</span>, <span style="color:#606">color</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 @RecordOptions(toMap=false) 禁用此功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_获取record中属性的个数"><a class="link" href="#_获取record中属性的个数">4.6.2.5. 获取Record中属性的个数</a></h5>
<div class="paragraph">
<p>我们可以像这样获取记录中的组件数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) { }

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">100</span>, <span style="color:#00D">200</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> p.size() == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 @RecordOptions(size=false) 禁用此功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_从record中获取第n个属性"><a class="link" href="#_从record中获取第n个属性">4.6.2.6. 从Record中获取第n个属性</a></h5>
<div class="paragraph">
<p>我们可以使用 Groovy 的正常位置索引来获取记录中的特定组件，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) { }

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">100</span>, <span style="color:#00D">200</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> p[<span style="color:#00D">1</span>] == <span style="color:#00D">200</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 @RecordOptions(getAt=false) 禁用此功能。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可选的_groovy_功能"><a class="link" href="#_可选的_groovy_功能">4.6.3. 可选的 Groovy 功能</a></h4>
<div class="sect4">
<h5 id="_copying"><a class="link" href="#_copying">4.6.3.1. Copying</a></h5>
<div class="paragraph">
<p>创建某些更改了属性的Record副本可能很有用。这可以使用带有命名参数的可选 copyWith 方法来完成。</p>
</div>
<div class="paragraph">
<p>复制的Record类的属性是根据提供的参数设置的。</p>
</div>
<div class="paragraph">
<p>对于未设置的属性，使用原Record的（浅）副本。以下是您可以如何使用 copyWith 作为 Fruit 记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@RecordOptions</span>(copyWith=<span style="color:#069">true</span>)
record Fruit(<span style="color:#0a8;font-weight:bold">String</span> name, <span style="color:#339;font-weight:bold">double</span> price) {}
<span style="color:#080;font-weight:bold">def</span> apple = <span style="color:#080;font-weight:bold">new</span> Fruit(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Apple</span><span style="color:#710">'</span></span>, <span style="color:#60E">11.6</span>)
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Apple</span><span style="color:#710">'</span></span> == apple.name()
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">11.6</span> == apple.price()

<span style="color:#080;font-weight:bold">def</span> orange = apple.copyWith(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Orange</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> orange.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Fruit[name=Orange, price=11.6]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过将 RecordOptions#copyWith 注释属性设置为 false 来禁用 copyWith 功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_深度不可变"><a class="link" href="#_深度不可变">4.6.3.2. 深度不可变</a></h5>
<div class="paragraph">
<p>与 Java 一样，记录默认提供浅层不变性。 Groovy 的 @Immutable 转换对一系列可变数据类型执行防御性复制。记录可以利用这种防御性复制来获得深度不变性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@ImmutableProperties</span>
record Shopping(<span style="color:#0a8;font-weight:bold">List</span> items) {}

<span style="color:#080;font-weight:bold">def</span> items = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bread</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">milk</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">def</span> shop = <span style="color:#080;font-weight:bold">new</span> Shopping(items)
items &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">chocolate</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> shop.items() == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bread</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">milk</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些示例说明了 Groovy 记录功能背后的原理，提供了三个级别的便利性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 record 关键字以获得最大程度的简洁性</p>
</li>
<li>
<p>使用注释支持简单的定制</p>
</li>
<li>
<p>当需要完全控制时允许通过正常方法实现</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_获取record属性对应的tuple"><a class="link" href="#_获取record属性对应的tuple">4.6.3.3. 获取Record属性对应的tuple</a></h5>
<div class="paragraph">
<p>您可以获取记录的组成部分作为类型化元组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.*</span>

<span style="color:#007">@RecordOptions</span>(components=<span style="color:#069">true</span>)
record <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y, <span style="color:#0a8;font-weight:bold">String</span> color) { }

<span style="color:#007">@CompileStatic</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method</span>() {
    <span style="color:#080;font-weight:bold">def</span> p1 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">100</span>, <span style="color:#00D">200</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
    <span style="color:#080;font-weight:bold">def</span> (<span style="color:#339;font-weight:bold">int</span> x1, <span style="color:#339;font-weight:bold">int</span> y1, <span style="color:#0a8;font-weight:bold">String</span> c1) = p1.components()
    <span style="color:#080;font-weight:bold">assert</span> x1 == <span style="color:#00D">100</span>
    <span style="color:#080;font-weight:bold">assert</span> y1 == <span style="color:#00D">200</span>
    <span style="color:#080;font-weight:bold">assert</span> c1 == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">def</span> p2 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">10</span>, <span style="color:#00D">20</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">blue</span><span style="color:#710">'</span></span>)
    <span style="color:#080;font-weight:bold">def</span> (x2, y2, c2) = p2.components()
    <span style="color:#080;font-weight:bold">assert</span> x2 * <span style="color:#00D">10</span> == <span style="color:#00D">100</span>
    <span style="color:#080;font-weight:bold">assert</span> y2 ** <span style="color:#00D">2</span> == <span style="color:#00D">400</span>
    <span style="color:#080;font-weight:bold">assert</span> c2.toUpperCase() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">BLUE</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">def</span> p3 = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Point</span>(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">red</span><span style="color:#710">'</span></span>)
    <span style="color:#080;font-weight:bold">assert</span> p3.components() <span style="color:#080;font-weight:bold">instanceof</span> Tuple3
}

method()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy 的 TupleN 类数量有限。如果您的记录中有大量属性，则可能无法使用此功能。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_与_java_的其他差异"><a class="link" href="#_与_java_的其他差异">4.6.4. 与 Java 的其他差异</a></h4>
<div class="paragraph">
<p>Groovy 支持创建 <em>record-like</em> 的Record类以及native records。<em>record-like</em> 的Record类不会扩展 Java 的 Record 类，并且此类不会被 Java 视为Record，但会具有类似的属性。</p>
</div>
<div class="paragraph">
<p>@RecordOptions 注释（ @RecordType 的一部分）支持 mode 注释属性，该属性可以采用三个值之一（ AUTO 是默认值） ）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NATIVE</dt>
<dd>
<p>生成一个与 Java 类似的类。在 JDK16 之前的 JDK 上编译时会产生错误。</p>
</dd>
<dt class="hdlist1">EMULATE</dt>
<dd>
<p>为所有 JDK 版本生成 <em>record-like</em> 的Record类。</p>
</dd>
<dt class="hdlist1">AUTO</dt>
<dd>
<p>Produces a native record for JDK16+ and emulates the record otherwise.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Whether you use the <code>record</code> keyword or the <code>@RecordType</code> annotation
is independent of the mode.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_密封的层次结构_incubating"><a class="link" href="#_密封的层次结构_incubating">4.7. 密封的层次结构 (incubating)</a></h3>
<div class="paragraph">
<p>密封类、接口和特征限制了哪些子类可以扩展/实现它们。在密封类出现之前，类层次结构设计者有两个主要选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将class设置为final, 不允许继承</p>
</li>
<li>
<p>将class设置为public, 非final, 运行任何人继承</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与这些全有或全无的选择相比，密封类提供了一个中间立场。</p>
</div>
<div class="paragraph">
<p>例如，假设我们要创建一个仅包含圆形和正方形的形状层次结构。我们还希望形状接口能够引用层次结构中的实例。我们可以按如下方式创建层次结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sealed <span style="color:#339;font-weight:bold">interface</span> ShapeI permits Circle,Square { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Circle</span> <span style="color:#088;font-weight:bold">implements</span> ShapeI { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Square</span> <span style="color:#088;font-weight:bold">implements</span> ShapeI { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy 还支持替代注解语法。我们认为关键字样式更好，但如果您的编辑器尚不支持 Groovy 4，您可以选择注解样式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Sealed</span>(permittedSubclasses=[Circle,Square]) <span style="color:#339;font-weight:bold">interface</span> ShapeI { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Circle</span> <span style="color:#088;font-weight:bold">implements</span> ShapeI { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Square</span> <span style="color:#088;font-weight:bold">implements</span> ShapeI { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以有一个 ShapeI 类型的引用，由于 permits 子句，它可以指向 Circle 或 Square ，并且，由于我们的类是 final ，我们知道将来不会将其他类添加到我们的层次结构中。</p>
</div>
<div class="paragraph">
<p>一般来说，我们可能希望立即锁定类层次结构的某些部分，就像我们在这里将子类标记为 final 但其他时候我们可能希望允许进一步控制继承。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sealed <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Shape</span> permits Circle,<span style="color:#0a8;font-weight:bold">Polygon</span>,<span style="color:#0a8;font-weight:bold">Rectangle</span> { }

<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Circle</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> { }

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Polygon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> { }
non-sealed <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">RegularPolygon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Polygon</span> { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Hexagon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Polygon</span> { }

sealed <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Rectangle</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> permits Square{ }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Square</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Rectangle</span> { }</code></pre>
</div>
</div>
<details>
<summary class="title">&lt;单击查看备用注解语法&gt;</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Sealed</span>(permittedSubclasses=[Circle,<span style="color:#0a8;font-weight:bold">Polygon</span>,<span style="color:#0a8;font-weight:bold">Rectangle</span>]) <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Shape</span> { }

<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Circle</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> { }

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Polygon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> { }
<span style="color:#007">@NonSealed</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">RegularPolygon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Polygon</span> { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Hexagon</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Polygon</span> { }

<span style="color:#007">@Sealed</span>(permittedSubclasses=Square) <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Rectangle</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Shape</span> { }
<span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Square</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Rectangle</span> { }</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>&nbsp;<br>
在此示例中， Shape 允许的子类是 Circle 、 Polygon 和 Rectangle 。 Circle 是 final ，因此层次结构的该部分无法扩展。</p>
</div>
<div class="paragraph">
<p>Polygon 是隐式非密封， RegularPolygon 显式标记为 non-sealed 。这意味着我们可以通过子类进行任何进一步的扩展，如 <code>Polygon → RegularPolygon</code> 和 <code>RegularPolygon → Hexagon</code> 所示。</p>
</div>
<div class="paragraph">
<p><code>Rectangle</code> 是密封的，并且仅允许 Square 子类。</p>
</div>
<div class="paragraph">
<p>密封类对于创建需要包含实例特定数据的类似枚举的相关类非常有用。例如，我们可能有以下枚举：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">enum</span> Weather { Rainy, Cloudy, Sunny }
<span style="color:#080;font-weight:bold">def</span> forecast = [Weather.Rainy, Weather.Sunny, Weather.Cloudy]
<span style="color:#080;font-weight:bold">assert</span> forecast.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[Rainy, Sunny, Cloudy]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>但我们现在还希望将天气特定数据添加到天气预报中。我们可以按如下方式改变我们的抽象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sealed <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Weather</span> { }
<span style="color:#007">@Immutable</span>(includeNames=<span style="color:#069">true</span>) <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Rainy</span> <span style="color:#088;font-weight:bold">extends</span> Weather { <span style="color:#0a8;font-weight:bold">Integer</span> expectedRainfall }
<span style="color:#007">@Immutable</span>(includeNames=<span style="color:#069">true</span>) <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Sunny</span> <span style="color:#088;font-weight:bold">extends</span> Weather { <span style="color:#0a8;font-weight:bold">Integer</span> expectedTemp }
<span style="color:#007">@Immutable</span>(includeNames=<span style="color:#069">true</span>) <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Cloudy</span> <span style="color:#088;font-weight:bold">extends</span> Weather { <span style="color:#0a8;font-weight:bold">Integer</span> expectedUV }
<span style="color:#080;font-weight:bold">def</span> forecast = [<span style="color:#080;font-weight:bold">new</span> Rainy(<span style="color:#00D">12</span>), <span style="color:#080;font-weight:bold">new</span> Sunny(<span style="color:#00D">35</span>), <span style="color:#080;font-weight:bold">new</span> Cloudy(<span style="color:#00D">6</span>)]
<span style="color:#080;font-weight:bold">assert</span> forecast.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">[Rainy(expectedRainfall:12), Sunny(expectedTemp:35), Cloudy(expectedUV:6)]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在指定代数(Algebraic)或抽象数据类型(Abstract Data Types) (ADT) 时，密封层次结构也很有用，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.*</span>

sealed <span style="color:#339;font-weight:bold">interface</span> Tree&lt;T&gt; {}
<span style="color:#007">@Singleton</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Empty</span> <span style="color:#088;font-weight:bold">implements</span> Tree {
    <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Empty</span><span style="color:#710">'</span></span> }
}
<span style="color:#007">@Canonical</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Node</span>&lt;T&gt; <span style="color:#088;font-weight:bold">implements</span> Tree&lt;T&gt; {
    T value
    Tree&lt;T&gt; left, right
}

Tree&lt;<span style="color:#0a8;font-weight:bold">Integer</span>&gt; tree = <span style="color:#080;font-weight:bold">new</span> Node&lt;&gt;(<span style="color:#00D">42</span>, <span style="color:#080;font-weight:bold">new</span> Node&lt;&gt;(<span style="color:#00D">0</span>, Empty.instance, Empty.instance), Empty.instance)
<span style="color:#080;font-weight:bold">assert</span> tree.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Node(42, Node(0, Empty, Empty), Empty)</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>密封层次结构与Record类也可以配合使用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sealed <span style="color:#339;font-weight:bold">interface</span> Expr {}
record ConstExpr(<span style="color:#339;font-weight:bold">int</span> i) <span style="color:#088;font-weight:bold">implements</span> Expr {}
record PlusExpr(Expr e1, Expr e2) <span style="color:#088;font-weight:bold">implements</span> Expr {}
record MinusExpr(Expr e1, Expr e2) <span style="color:#088;font-weight:bold">implements</span> Expr {}
record NegExpr(Expr e) <span style="color:#088;font-weight:bold">implements</span> Expr {}

<span style="color:#080;font-weight:bold">def</span> threePlusNegOne = <span style="color:#080;font-weight:bold">new</span> PlusExpr(<span style="color:#080;font-weight:bold">new</span> ConstExpr(<span style="color:#00D">3</span>), <span style="color:#080;font-weight:bold">new</span> NegExpr(<span style="color:#080;font-weight:bold">new</span> ConstExpr(<span style="color:#00D">1</span>)))
<span style="color:#080;font-weight:bold">assert</span> threePlusNegOne.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">PlusExpr[e1=ConstExpr[i=3], e2=NegExpr[e=ConstExpr[i=1]]]</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_与_java_的差异"><a class="link" href="#_与_java_的差异">4.7.1. 与 Java 的差异</a></h4>
<div class="ulist">
<ul>
<li>
<p>Java provides no default modifier for subclasses of sealed classes
and requires that one of <code>final</code>, <code>sealed</code> or <code>non-sealed</code> be specified.
Groovy defaults to <em>non-sealed</em> but you can still use <code>non-sealed/@NonSealed</code> if you wish.
We anticipate the style checking tool CodeNarc will eventually have a rule that
looks for the presence of <code>non-sealed</code> so developers wanting that stricter
style will be able to use CodeNarc and that rule if they want.</p>
</li>
<li>
<p>目前，Groovy 不会检查 permittedSubclasses 中提到的所有类在编译时是否可用并与基本密封类一起编译。这可能会在 Groovy 的未来版本中发生变化。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy支持 native封闭类, 也支持通过注解将class标记为封闭类</p>
</div>
<div class="paragraph">
<p>@SealedOptions 注解支持 mode 注解属性，该属性可以采用三个值之一（ AUTO 为默认值）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NATIVE</dt>
<dd>
<p>Produces a class similar to what Java would do.
Produces an error when compiling on JDKs earlier than JDK17.</p>
</dd>
<dt class="hdlist1">EMULATE</dt>
<dd>
<p>Indicates the class is sealed using the <code>@Sealed</code> annotation.
This mechanism works with the Groovy compiler for JDK8+ but is not recognised by the Java compiler.</p>
</dd>
<dt class="hdlist1">AUTO</dt>
<dd>
<p>Produces a native record for JDK17+ and emulates the record otherwise.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Whether you use the <code>sealed</code> keyword or the <code>@Sealed</code> annotation
is independent of the mode.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closures"><a class="link" href="#_closures">5. Closures</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍 Groovy 闭包。 Groovy 中的闭包是一个开放的、匿名的代码块，可以接受参数、返回值和分配给变量。闭包可以引用在其周围范围内声明的变量。与闭包的正式定义相反，Groovy 语言中的 <code>Closure</code> 还可以包含在其周围范围之外定义的自由变量。虽然打破了闭包的正式概念，但它提供了本章中描述的各种优点。</p>
</div>
<div class="sect2">
<h3 id="_语法_2"><a class="link" href="#_语法_2">5.1. 语法</a></h3>
<div class="sect3">
<h4 id="_定义闭包"><a class="link" href="#_定义闭包">5.1.1. 定义闭包</a></h4>
<div class="paragraph">
<p>闭包定义遵循以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">{ [closureParameters -&gt; ] statements }</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>[closureParameters-&gt;]</code> 是可选的以逗号分隔的参数列表，这些参数类似于方法参数列表，并且这些参数可以是类型化的或非类型化的。</p>
</div>
<div class="paragraph">
<p>statements是 0 个或多个 Groovy 语句。</p>
</div>
<div class="paragraph">
<p>当指定参数列表时， <code>-&gt;</code> 字符是必需的，用于将参数与闭包主体分隔开。<em>statements</em> 部分由 0、1 或多个 Groovy 语句组成。</p>
</div>
<div class="paragraph">
<p>下面是一些合法的闭包定义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">{ item++ }                                          // <b class="conum">(1)</b>

{ -&gt; item++ }                                       // <b class="conum">(2)</b>

{ println <span style="color:#950">it</span> }                                      // <b class="conum">(3)</b>

{ <span style="color:#950">it</span> -&gt; println <span style="color:#950">it</span> }                                // <b class="conum">(4)</b>

{ name -&gt; println name }                            // <b class="conum">(5)</b>

{ <span style="color:#0a8;font-weight:bold">String</span> x, <span style="color:#339;font-weight:bold">int</span> y -&gt;                                // <b class="conum">(6)</b>
    println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hey </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> the value is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>y<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
}

{ reader -&gt;                                         // <b class="conum">(7)</b>
    <span style="color:#080;font-weight:bold">def</span> line = reader.readLine()
    line.trim()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>该闭包引用了名为 <code>item</code> 的变量</p>
</li>
<li>
<p>可以通过添加箭头 (<code>-&gt;</code>) 将闭包参数与代码显式分离</p>
</li>
<li>
<p>该闭包使用了隐式参数 (<code>it</code>)</p>
</li>
<li>
<p>另一种版本，其中 <code>it</code> 是显式参数</p>
</li>
<li>
<p>在这种情况下，通常最好为参数使用显式名称</p>
</li>
<li>
<p>接受两个类型参数的闭包</p>
</li>
<li>
<p>一个闭包可以包含多个语句</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="closure-as-object"><a class="link" href="#closure-as-object">5.1.2. 闭包作为对象</a></h4>
<div class="paragraph">
<p>闭包是 <code>groovy.lang.Closure</code> 类的实例，可以像任何其他变量一样分配给变量或字段，尽管它是一个代码块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> listener = { e -&gt; println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Clicked on </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>e</span><span style="color:#D20">.source</span><span style="color:#710">&quot;</span></span> }      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> listener <span style="color:#080;font-weight:bold">instanceof</span> Closure
Closure callback = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Done!</span><span style="color:#710">'</span></span> }                      // <b class="conum">(2)</b>
Closure&lt;<span style="color:#0a8;font-weight:bold">Boolean</span>&gt; isTextFile = {
    <span style="color:#0a8;font-weight:bold">File</span> <span style="color:#950">it</span> -&gt; <span style="color:#950">it</span>.name.endsWith(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">.txt</span><span style="color:#710">'</span></span>)                     // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>您可以将闭包分配给变量，它是 <code>groovy.lang.Closure</code> 的实例</p>
</li>
<li>
<p>如果不使用 <code>def</code> 或 <code>var</code> ，可以使用 <code>groovy.lang.Closure</code> 作为类型</p>
</li>
<li>
<p>或者，您可以使用 <code>groovy.lang.Closure</code> 的泛型类型指定闭包的返回类型</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_调用闭包"><a class="link" href="#_调用闭包">5.1.3. 调用闭包</a></h4>
<div class="paragraph">
<p>闭包作为匿名代码块，可以像任何其他方法一样被调用。如果你定义一个不带参数的闭包，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> code = { <span style="color:#00D">123</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以像方法一样通过变量来调用闭包, 只有在调用闭包时才会执行闭包内的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> code() == <span style="color:#00D">123</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以明确地使用 call 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> code.call() == <span style="color:#00D">123</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果闭包接受参数，原理是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> isOdd = { <span style="color:#339;font-weight:bold">int</span> i -&gt; i%<span style="color:#00D">2</span> != <span style="color:#00D">0</span> }                           // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> isOdd(<span style="color:#00D">3</span>) == <span style="color:#069">true</span>                                     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> isOdd.call(<span style="color:#00D">2</span>) == <span style="color:#069">false</span>                               // <b class="conum">(3)</b>

<span style="color:#080;font-weight:bold">def</span> isEven = { <span style="color:#950">it</span>%<span style="color:#00D">2</span> == <span style="color:#00D">0</span> }                                  // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> isEven(<span style="color:#00D">3</span>) == <span style="color:#069">false</span>                                   // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> isEven.call(<span style="color:#00D">2</span>) == <span style="color:#069">true</span>                               // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>定义一个接受 <code>int</code> 作为参数的闭包</p>
</li>
<li>
<p>可以直接调用</p>
</li>
<li>
<p>或使用 <code>call</code> 方法</p>
</li>
<li>
<p>对于带有隐式参数 (<code>it</code>) 的闭包也是如此</p>
</li>
<li>
<p>可以直接使用 <code>(arg)</code> 调用</p>
</li>
<li>
<p>或使用 <code>call</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>与方法不同，闭包在调用时 <strong>总是</strong> 返回一个值。下一节讨论如何声明闭包参数、何时使用它们以及什么是<a href="#implicit-it">隐式
"it" 参数</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_参数"><a class="link" href="#_参数">5.2. 参数</a></h3>
<div class="sect3">
<h4 id="_普通参数"><a class="link" href="#_普通参数">5.2.1. 普通参数</a></h4>
<div class="paragraph">
<p>闭包的参数遵循与常规方法的参数相同的原则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可选类型</p>
</li>
<li>
<p>具有一个名字</p>
</li>
<li>
<p>具有可选的默认值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数之间用逗号分隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> closureWithOneArg = { str -&gt; str.toUpperCase() }
<span style="color:#080;font-weight:bold">assert</span> closureWithOneArg(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">groovy</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">GROOVY</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">def</span> closureWithOneArgAndExplicitType = { <span style="color:#0a8;font-weight:bold">String</span> str -&gt; str.toUpperCase() }
<span style="color:#080;font-weight:bold">assert</span> closureWithOneArgAndExplicitType(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">groovy</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">GROOVY</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">def</span> closureWithTwoArgs = { a,b -&gt; a+b }
<span style="color:#080;font-weight:bold">assert</span> closureWithTwoArgs(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>) == <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">def</span> closureWithTwoArgsAndExplicitTypes = { <span style="color:#339;font-weight:bold">int</span> a, <span style="color:#339;font-weight:bold">int</span> b -&gt; a+b }
<span style="color:#080;font-weight:bold">assert</span> closureWithTwoArgsAndExplicitTypes(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>) == <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">def</span> closureWithTwoArgsAndOptionalTypes = { a, <span style="color:#339;font-weight:bold">int</span> b -&gt; a+b }
<span style="color:#080;font-weight:bold">assert</span> closureWithTwoArgsAndOptionalTypes(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>) == <span style="color:#00D">3</span>

<span style="color:#080;font-weight:bold">def</span> closureWithTwoArgAndDefaultValue = { <span style="color:#339;font-weight:bold">int</span> a, <span style="color:#339;font-weight:bold">int</span> b=<span style="color:#00D">2</span> -&gt; a+b }
<span style="color:#080;font-weight:bold">assert</span> closureWithTwoArgAndDefaultValue(<span style="color:#00D">1</span>) == <span style="color:#00D">3</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="implicit-it"><a class="link" href="#implicit-it">5.2.2. 隐式参数</a></h4>
<div class="paragraph">
<p>当闭包未显式定义参数列表（使用 <code>-&gt;</code> ）时，闭包 <strong>始终</strong> 定义一个隐式参数，名为 <code>it</code> 。这意味着这段代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> greeting = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span><span style="color:#950">it</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> }
<span style="color:#080;font-weight:bold">assert</span> greeting(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Patrick</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Patrick!</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与此严格等效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> greeting = { <span style="color:#950">it</span> -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span><span style="color:#950">it</span></span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> }
<span style="color:#080;font-weight:bold">assert</span> greeting(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Patrick</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Patrick!</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想声明一个不接受参数的闭包，并且必须限制为不带参数的调用，那么你 <strong>必须</strong> 使用显式的空参数列表来声明它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> magicNumber = { -&gt; <span style="color:#00D">42</span> }

<span style="color:#777">// this call will fail because the closure doesn't accept any argument</span>
magicNumber(<span style="color:#00D">11</span>)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可变参数_2"><a class="link" href="#_可变参数_2">5.2.3. 可变参数</a></h4>
<div class="paragraph">
<p>闭包可以像任何其他方法一样声明变量参数。 如果最后一个参数具有可变长度, 或者是数组 , 那么闭包可以接受可变数量参数，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> concat1 = { <span style="color:#0a8;font-weight:bold">String</span>... args -&gt; args.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>) }           // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> concat1(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abc</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">def</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abcdef</span><span style="color:#710">'</span></span>                     // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> concat2 = { <span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> args -&gt; args.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>) }            // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> concat2(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abc</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">def</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abcdef</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">def</span> multiConcat = { <span style="color:#339;font-weight:bold">int</span> n, <span style="color:#0a8;font-weight:bold">String</span>... args -&gt;                // <b class="conum">(4)</b>
    args.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>)*n
}
<span style="color:#080;font-weight:bold">assert</span> multiConcat(<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abc</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">def</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abcdefabcdef</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>接受可变数量的字符串作为第一个参数</p>
</li>
<li>
<p>可以使用任意数量的参数调用它，而 <strong>不必</strong> 将它们显式包装到数组中</p>
</li>
<li>
<p>如果 <em>args</em> 参数声明为数组，则可以直接使用相同的行为</p>
</li>
<li>
<p>只要 <strong>最后一个</strong> 参数是数组或显式 可变长度 类型</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_委托delegation策略"><a class="link" href="#_委托delegation策略">5.3. 委托(Delegation)策略</a></h3>
<div class="sect3">
<h4 id="_groovy_闭包与_lambda_表达式"><a class="link" href="#_groovy_闭包与_lambda_表达式">5.3.1. Groovy 闭包与 lambda 表达式</a></h4>
<div class="paragraph">
<p>Groovy 将闭包定义为 <a href="#closure-as-object">Closure类的实例</a>。它与  <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda expressions in Java 8</a> 非常不同。委托是 Groovy 闭包中的一个关键概念，而 lambda 中没有等效概念。<em>更改委托</em> 或 <em>更改闭包的委托策略</em> 的能力使得在 Groovy 中设计漂亮的领域特定语言 (DSL) 成为可能。</p>
</div>
</div>
<div class="sect3">
<h4 id="closure-owner"><a class="link" href="#closure-owner">5.3.2. Owner, delegate 和 this</a></h4>
<div class="paragraph">
<p>要理解delegate的概念，我们首先要解释一下闭包中 <code>this</code> 的含义。闭包实际上定义了 3 个不同的东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>this</code> 对应于定义闭包的 <em>封闭类</em></p>
</li>
<li>
<p><code>owner</code> 对应于定义闭包的 <em>封闭对象</em> ，可以是类，也可以是闭包</p>
</li>
<li>
<p><code>delegate</code> 对应于第三方对象,  当闭包的调用者未定义时，方法调用或属性将被解析到 <code>delegate</code>。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="closure-this"><a class="link" href="#closure-this">5.3.2.1. 闭包中的this</a></h5>
<div class="paragraph">
<p>在闭包中，调用 <code>getThisObject</code> 将返回定义闭包的封闭类。它相当于使用显式 <code>this</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Enclosing</span> {
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> whatIsThisObject = { getThisObject() }          // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">assert</span> whatIsThisObject() == <span style="color:#950">this</span>                   // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">def</span> whatIsThis = { <span style="color:#950">this</span> }                           // <b class="conum">(3)</b>
        <span style="color:#080;font-weight:bold">assert</span> whatIsThis() == <span style="color:#950">this</span>                         // <b class="conum">(4)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">EnclosedInInnerClass</span> {
    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Inner</span> {
        Closure cl = { <span style="color:#950">this</span> }                               // <b class="conum">(5)</b>
    }
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> inner = <span style="color:#080;font-weight:bold">new</span> Inner()
        <span style="color:#080;font-weight:bold">assert</span> inner.cl() == inner                          // <b class="conum">(6)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">NestedClosures</span> {
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> nestedClosures = {
            <span style="color:#080;font-weight:bold">def</span> cl = { <span style="color:#950">this</span> }                               // <b class="conum">(7)</b>
            cl()
        }
        <span style="color:#080;font-weight:bold">assert</span> nestedClosures() == <span style="color:#950">this</span>                     // <b class="conum">(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在 <code>Enclosing</code> 类中定义，并返回 <code>getThisObject</code></p>
</li>
<li>
<p>调用闭包将返回定义闭包的 <code>Enclosing</code> 实例</p>
</li>
<li>
<p>一般来说，只会使用快捷方式 <code>this</code></p>
</li>
<li>
<p>它返回 <strong>完全</strong> 相同的对象</p>
</li>
<li>
<p>如果闭包是在内部类中定义的</p>
</li>
<li>
<p>闭包中的 <code>this</code> 将返回内部类，而不是顶级类</p>
</li>
<li>
<p>在嵌套闭包的情况下，就像这里 <code>cl</code> 被定义在 <code>nestedClosures</code> 范围内一样</p>
</li>
<li>
<p>那么 <code>this</code> 对应于最接近的外部类，而不是封闭的闭包！</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当然可以通过这种方式从封闭类中调用方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> age
    <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#D20"> is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>age</span><span style="color:#D20"> years old</span><span style="color:#710">&quot;</span></span> }

    <span style="color:#0a8;font-weight:bold">String</span> dump() {
        <span style="color:#080;font-weight:bold">def</span> cl = {
            <span style="color:#0a8;font-weight:bold">String</span> msg = <span style="color:#950">this</span>.toString()               // <b class="conum">(1)</b>
            println msg
            msg
        }
        cl()
    }
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Janice</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>:<span style="color:#00D">74</span>)
<span style="color:#080;font-weight:bold">assert</span> p.dump() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Janice is 74 years old</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>闭包调用 <code>this</code> 上的 <code>toString</code> ，这实际上会调用封闭对象（即 <code>Person</code> 实例）上的 <code>toString</code> 方法</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_闭包的owner属性"><a class="link" href="#_闭包的owner属性">5.3.2.2. 闭包的Owner属性</a></h5>
<div class="paragraph">
<p>闭包的 <code>owner</code> 与 <a href="#closure-this">闭包中的this</a> 的定义非常相似，但有一个细微的区别：它将返回直接封闭的对象，无论是闭包还是类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Enclosing</span> {
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> whatIsOwnerMethod = { getOwner() }               // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">assert</span> whatIsOwnerMethod() == <span style="color:#950">this</span>                   // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">def</span> whatIsOwner = { owner }                          // <b class="conum">(3)</b>
        <span style="color:#080;font-weight:bold">assert</span> whatIsOwner() == <span style="color:#950">this</span>                         // <b class="conum">(4)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">EnclosedInInnerClass</span> {
    <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Inner</span> {
        Closure cl = { owner }                               // <b class="conum">(5)</b>
    }
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> inner = <span style="color:#080;font-weight:bold">new</span> Inner()
        <span style="color:#080;font-weight:bold">assert</span> inner.cl() == inner                           // <b class="conum">(6)</b>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">NestedClosures</span> {
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> nestedClosures = {
            <span style="color:#080;font-weight:bold">def</span> cl = { owner }                               // <b class="conum">(7)</b>
            cl()
        }
        <span style="color:#080;font-weight:bold">assert</span> nestedClosures() == nestedClosures            // <b class="conum">(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在 <code>Enclosing</code> 类中定义，并返回 <code>getOwner</code></p>
</li>
<li>
<p>调用闭包将返回定义闭包的 <code>Enclosing</code> 实例</p>
</li>
<li>
<p>一般来说，您只想使用快捷方式 <code>owner</code> 表示法</p>
</li>
<li>
<p>它返回 <strong>完全</strong> 相同的对象</p>
</li>
<li>
<p>如果闭包是在内部类中定义的</p>
</li>
<li>
<p>闭包中的 <code>owner</code> 将返回 <em>内部类</em>，而不是顶级类</p>
</li>
<li>
<p>但在嵌套闭包的情况下，就像这里 <code>cl</code> 被定义在 <code>nestedClosures</code> 范围内一样</p>
</li>
<li>
<p>那么 <code>owner</code> 对应于封闭的闭包，与 <code>this</code> 是不同的对象！</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_闭包的delegate"><a class="link" href="#_闭包的delegate">5.3.2.3. 闭包的Delegate</a></h5>
<div class="paragraph">
<p>可以使用 <code>delegate</code> 属性或调用 <code>getDelegate</code> 方法来访问闭包的委托。它是在 Groovy 中构建领域特定语言的强大概念。虽然 <a href="#closure-this">this</a> 和 <a href="#closure-owner">owner</a> 指的是闭包的词法范围，但 <code>delegate</code> 是闭包将使用的用户定义的对象。默认情况下，<code>delegate</code> 设置为 `owner `：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Enclosing</span> {
    <span style="color:#339;font-weight:bold">void</span> run() {
        <span style="color:#080;font-weight:bold">def</span> cl = { getDelegate() }                          // <b class="conum">(1)</b>
        <span style="color:#080;font-weight:bold">def</span> cl2 = { delegate }                              // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">assert</span> cl() == cl2()                                // <b class="conum">(3)</b>
        <span style="color:#080;font-weight:bold">assert</span> cl() == <span style="color:#950">this</span>                                 // <b class="conum">(4)</b>
        <span style="color:#080;font-weight:bold">def</span> enclosed = {
            { -&gt; delegate }.call()                          // <b class="conum">(5)</b>
        }
        <span style="color:#080;font-weight:bold">assert</span> enclosed() == enclosed                       // <b class="conum">(6)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>您可以调用 <code>getDelegate</code> 方法获取闭包的委托</p>
</li>
<li>
<p>或使用 <code>delegate</code> 属性</p>
</li>
<li>
<p>两者都返回相同的对象</p>
</li>
<li>
<p>这是封闭类或闭包</p>
</li>
<li>
<p>特别是在嵌套闭包的情况下</p>
</li>
<li>
<p><code>delegate</code> 将对应于 <code>owner</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>闭包的委托可以更改为 <strong>任何对象</strong>。让我们通过创建两个类来说明这一点，这两个类不是彼此的子类，但都定义了一个名为 <code>name</code> 的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Thing</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Norman</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> t = <span style="color:#080;font-weight:bold">new</span> Thing(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Teapot</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们定义一个闭包来获取委托上的 <code>name</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> upperCasedName = { delegate.name.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后通过改变闭包的委托，可以看到目标对象发生了变化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">upperCasedName.delegate = p
<span style="color:#080;font-weight:bold">assert</span> upperCasedName() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">NORMAN</span><span style="color:#710">'</span></span>
upperCasedName.delegate = t
<span style="color:#080;font-weight:bold">assert</span> upperCasedName() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">TEAPOT</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，行为与在闭包的词法作用域中定义 <code>target</code> 变量没有什么不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> target = p
<span style="color:#080;font-weight:bold">def</span> upperCasedNameUsingVar = { target.name.toUpperCase() }
<span style="color:#080;font-weight:bold">assert</span> upperCasedNameUsingVar() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">NORMAN</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，他们存在重大差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在最后一个示例中，<code>target</code> 是从闭包内引用的局部变量</p>
</li>
<li>
<p>委托可以透明地使用，也就是说，无需在方法调用前添加 <code>delegate.</code> 前缀，如下一段所述。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_delegation策略"><a class="link" href="#_delegation策略">5.3.2.4. Delegation策略</a></h5>
<div class="paragraph">
<p>每当在闭包中，在没有显式设置调用者的情况下访问属性时，就会涉及委托策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Igor</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> cl = { name.toUpperCase() }                 // <b class="conum">(1)</b>
cl.delegate = p                                 // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> cl() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">IGOR</span><span style="color:#710">'</span></span>                           // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>name</code> 没有引用闭包词法范围内的变量</p>
</li>
<li>
<p>我们可以将闭包的委托更改为 <code>Person</code> 的实例</p>
</li>
<li>
<p>方法调用将会成功</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此代码起作用的原因是 <code>name</code> 属性将在 <code>delegate</code> 对象上解析！这是解决闭包内的属性或方法调用的一种非常强大的方法。不需要设置显式的 <code>delegate.</code> , 即可进行调用，因为闭包的默认委托策略使得它如此。闭包实际上定义了多种您可以选择的解决策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Closure.OWNER_FIRST</code> 是 <strong>默认策略</strong>。如果 <strong>owner</strong> 存在属性/方法，则将调用它。如果没有，则使用`delegate`。</p>
</li>
<li>
<p><code>Closure.DELEGATE_FIRST</code> 首先使用 <strong>delegate</strong>，然后使用 <strong>owner</strong></p>
</li>
<li>
<p><code>Closure.OWNER_ONLY</code> 只会解析 <strong>owner</strong> 的属性/方法查找, <strong>delegate</strong> 将被忽略。</p>
</li>
<li>
<p><code>Closure.DELEGATE_ONLY</code> 将仅解析 <strong>delegate</strong> 上的属性/方法查找： <strong>owner</strong> 将被忽略。</p>
</li>
<li>
<p><code>Closure.TO_SELF</code> 可供需要高级元编程技术并希望实现自定义解析策略的开发人员使用：解析不会针对 <code>owner</code> 或 <code>delegate</code> 进行，而仅针对闭包类本身进行。仅当您实现自己的 <code>Closure</code> 子类时才有意义。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用以下代码来说明默认的“owner first”策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#080;font-weight:bold">def</span> pretty = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">My name is </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span> }             // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> toString() {
        pretty()
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Thing</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name                                     // <b class="conum">(2)</b>
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Sarah</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> t = <span style="color:#080;font-weight:bold">new</span> Thing(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Teapot</span><span style="color:#710">'</span></span>)

<span style="color:#080;font-weight:bold">assert</span> p.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">My name is Sarah</span><span style="color:#710">'</span></span>           // <b class="conum">(3)</b>
p.pretty.delegate = t                               // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> p.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">My name is Sarah</span><span style="color:#710">'</span></span>           // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>为了便于说明，我们定义了一个引用 <code>name</code> 的闭包成员</p>
</li>
<li>
<p><code>Person</code> 和 <code>Thing</code> 类都定义了 <code>name</code> 属性</p>
</li>
<li>
<p>使用默认策略， <code>name</code> 属性首先在 <code>owner</code> 上解析</p>
</li>
<li>
<p>因此，如果我们将 <code>delegate</code> 更改为 <code>t</code> ，它是 <code>Thing</code> 的实例</p>
</li>
<li>
<p>结果没有变化： <code>name</code> 首先在闭包的 <code>owner</code> 上解析</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然而，可以改变闭包的解析策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
<span style="color:#080;font-weight:bold">assert</span> p.toString() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">My name is Teapot</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过更改 <code>resolveStrategy</code> ，Groovy 会解析 "隐式 this" 引用的方式：在这种情况下，将首先在delegate中查找 <code>name</code> ，如果没有找到，在owner上查找。由于 <code>name</code> 在 <code>delegate(Thing 的实例)</code> 中定义的了, 因此使用该值。</p>
</div>
<div class="paragraph">
<p>"delegate first" 和 "delegate only" 或者 "owner first" 和 "owner only" 之间的区别可以通过如下来说明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> age
    <span style="color:#080;font-weight:bold">def</span> fetchAge = { age }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Thing</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Jessica</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>:<span style="color:#00D">42</span>)
<span style="color:#080;font-weight:bold">def</span> t = <span style="color:#080;font-weight:bold">new</span> Thing(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Printer</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> cl = p.fetchAge
cl.delegate = p
<span style="color:#080;font-weight:bold">assert</span> cl() == <span style="color:#00D">42</span>          // <b class="conum">(1)</b>
cl.delegate = t
<span style="color:#080;font-weight:bold">assert</span> cl() == <span style="color:#00D">42</span>          // <b class="conum">(1)</b>

cl.resolveStrategy = Closure.DELEGATE_ONLY
cl.delegate = p
<span style="color:#080;font-weight:bold">assert</span> cl() == <span style="color:#00D">42</span>          // <b class="conum">(2)</b>
cl.delegate = t
<span style="color:#080;font-weight:bold">try</span> {
    cl()                   // <b class="conum">(3)</b>
    <span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">false</span>
} <span style="color:#080;font-weight:bold">catch</span> (MissingPropertyException ex) {
    <span style="color:#777">// &quot;age&quot; is not defined on the delegate</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>对于  "owner first" ，delegate是什么都无所谓</p>
</li>
<li>
<p>对于 "delegate only", <code>p</code> 作为delegate可以成功</p>
</li>
<li>
<p>对于 "delegate only" , <code>t</code> 作为 delegate 会失败</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在此示例中，我们定义了两个类，它们都具有 <code>name</code> 属性，但只有 <code>Person</code> 类声明了 <code>age</code> 。 <code>Person</code> 类还声明了一个引用 <code>age</code> 的闭包。我们可以将默认的解析策略从 "owner first" 更改为 "delegate only"。由于闭包的owner是 <code>Person</code> 类，因此我们可以检查delegate是否是 <code>Person</code> 的实例，则调用闭包是成功的，但是如果 delegate 是 <code>Thing</code> 的实例，它失败并返回 <code>groovy.lang.MissingPropertyException</code> 。尽管闭包是在 <code>Person</code> 类中定义的，但不使用owner。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
有关如何使用此功能来开发 DSL 的全面说明可以在手册的 <a href="../core-domain-specific-languages.html">dedicated section of the manual</a>. 中找到。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_delegation策略_in_the_presence_of_metaprogramming"><a class="link" href="#_delegation策略_in_the_presence_of_metaprogramming">5.3.2.5. Delegation策略 in the presence of metaprogramming</a></h5>
<div class="paragraph">
<p>在描述 "owner first" 委托策略时，我们谈到使用owner的属性/方法（如果它 <em>存在</em> ），否则使用delegate的相应属性/方法。还有一个类似的但与其相反 "delegate first" 的策略。与其使用 <em>存在</em> 一词，不如使用 <em>处理</em> 一词更为准确。这意味着对于 "owner first"，如果属性/方法存在于owner中，或者它具有 propertyMissing/methodMissing 钩子函数，则owner将处理成员访问。</p>
</div>
<div class="paragraph">
<p>我们可以通过对上一个示例进行稍微修改的版本来看到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> age
    <span style="color:#080;font-weight:bold">def</span> fetchAge = { age }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Thing</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">propertyMissing</span>(<span style="color:#0a8;font-weight:bold">String</span> name) { -<span style="color:#00D">1</span> }
}

<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Jessica</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>:<span style="color:#00D">42</span>)
<span style="color:#080;font-weight:bold">def</span> t = <span style="color:#080;font-weight:bold">new</span> Thing(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Printer</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> cl = p.fetchAge
cl.resolveStrategy = Closure.DELEGATE_FIRST
cl.delegate = p
<span style="color:#080;font-weight:bold">assert</span> cl() == <span style="color:#00D">42</span>
cl.delegate = t
<span style="color:#080;font-weight:bold">assert</span> cl() == -<span style="color:#00D">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，即使我们的 <code>Thing</code> 类实例（cl的最后一次使用中的delegate）没有 <code>age</code> 属性，但它通过其 <code>propertyMissing</code> 钩子函数处理丢失的属性, 意味着 <code>age</code> 将是 <code>-1</code>。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gstring_中的闭包"><a class="link" href="#_gstring_中的闭包">5.4. GString 中的闭包</a></h3>
<div class="paragraph">
<p>以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">def</span> gs = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">x = </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x = 1</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码的行为正如您所期望的，但如果添加以下内容会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">x = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x = 2</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你会看到断言失败了！有两个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GString 仅延迟计算表达式的 <code>toString</code> 形式</p>
</li>
<li>
<p>GString 中的语法 <code>${x}</code> 并 <strong>不</strong> 代表闭包，而是 <code>$x</code> 的表达式，这会在在创建 GString 时进行评估.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的示例中， <code>GString</code> 是通过一个引用 <code>x</code> 的表达式来创建的。创建 GString 时， <code>x</code> 的值为1，so the <code>GString</code> is created with a value of 1。当触发断言时，通过使用 <code>toString</code> 将 <code>1</code> 转换为 <code>String</code> 。当我们将 <code>x</code> 更改为 <code>2</code> 时，我们确实更改了 <code>x</code> 的值，但它是另外一个对象，并且 GString 仍然引用旧的对象(1)。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>GString</code> 只有当他 <em>引用的值</em> 是可变的时, <code>GString</code> 的 <code>toString</code> 形式才会改变。如果只是引用发生变化，则不会发生任何事情。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
可以理解为将 <code>x</code> 作为参数传递到了 <code>GString</code> 中, 只有 <code>x</code> 引用的对象发生了改变, <code>GString</code> 才会改变. 如果将其他值赋给 <code>x</code> , 对 <code>GString</code>  没有任何影响
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您需要在 GString 中使用真正的闭包，例如强制执行变量的惰性求值，则需要使用替代语法 <code>${→ x}</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">def</span> gs = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">x = </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>-&gt; x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x = 1</span><span style="color:#710">'</span></span>

x = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x = 2</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们用这段代码来说明它与值可变有何不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#0a8;font-weight:bold">String</span> toString() { name }          // <b class="conum">(1)</b>
}
<span style="color:#080;font-weight:bold">def</span> sam = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Sam</span><span style="color:#710">'</span></span>)        // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> lucy = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lucy</span><span style="color:#710">'</span></span>)      // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> p = sam                             // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">def</span> gs = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Name: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>p<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>                   // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Sam</span><span style="color:#710">'</span></span>                // <b class="conum">(6)</b>
p = lucy                                // <b class="conum">(7)</b>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Sam</span><span style="color:#710">'</span></span>                // <b class="conum">(8)</b>
sam.name = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lucy</span><span style="color:#710">'</span></span>                       // <b class="conum">(9)</b>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Lucy</span><span style="color:#710">'</span></span>               // <b class="conum">(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>Person</code> 类有一个 <code>toString</code> 方法，返回 <code>name</code> 属性</p>
</li>
<li>
<p>我们创建了第一个名为 <em>Sam</em> 的 <code>Person</code></p>
</li>
<li>
<p>我们创建另一个名为 <em>Lucy</em> 的 <code>Person</code></p>
</li>
<li>
<p><code>p</code> 变量设置为 <code>Sam</code></p>
</li>
<li>
<p>创建了一个闭包，引用 <code>p</code> 的值，也就是说 <em>Sam</em></p>
</li>
<li>
<p>所以当我们计算字符串时，它返回  <em>Sam</em></p>
</li>
<li>
<p>如果我们将 p 更改为 <em>Lucy</em></p>
</li>
<li>
<p>该字符串的计算结果仍为 <em>Sam</em> ，因为它是创建 <code>GString</code> 时 <code>p</code> 的值</p>
</li>
<li>
<p>所以如果我们对 <em>Sam</em> 进行修改，将名字改为 <em>Lucy</em></p>
</li>
<li>
<p>这次 <code>GString</code> 已正确改变</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，如果您不想依赖可变对象或包装对象，则必须在 <code>GString</code> 通过显式声明空参数列表来使用闭包的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#0a8;font-weight:bold">String</span> toString() { name }
}
<span style="color:#080;font-weight:bold">def</span> sam = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Sam</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> lucy = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lucy</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">def</span> p = sam
<span style="color:#777">// Create a GString with lazy evaluation of &quot;p&quot;</span>
<span style="color:#080;font-weight:bold">def</span> gs = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Name: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>-&gt; p<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Sam</span><span style="color:#710">'</span></span>
p = lucy
<span style="color:#080;font-weight:bold">assert</span> gs == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Name: Lucy</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_闭包强制转换"><a class="link" href="#_闭包强制转换">5.5. 闭包强制转换</a></h3>
<div class="paragraph">
<p>闭包可以转换为接口或单一抽象方法类型。请参阅手册的<a href="core-semantics.html#closure-coercion">这一部分</a>以获取完整的说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_函数式编程"><a class="link" href="#_函数式编程">5.6. 函数式编程</a></h3>
<div class="paragraph">
<p>闭包是 Groovy 中函数式编程范例的核心。函数上的一些函数式编程操作可直接在 <code>Closure</code> 类上使用，如本节中所示。</p>
</div>
<div class="sect3">
<h4 id="_柯里化"><a class="link" href="#_柯里化">5.6.1. 柯里化</a></h4>
<div class="paragraph">
<p>在 Groovy 中，柯里化指的是部分应用的概念。由于 Groovy 对闭包应用了不同的作用域规则，因此它与函数式编程中的柯里化的真正概念并不相符。 Groovy 中的柯里化将允许您设置闭包的一个参数，并且它将返回一个接受少一个参数的新闭包。</p>
</div>
<div class="sect4">
<h5 id="_左柯里化"><a class="link" href="#_左柯里化">5.6.1.1. 左柯里化</a></h5>
<div class="paragraph">
<p>左柯里化是指设置闭包最左边的参数，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> nCopies = { <span style="color:#339;font-weight:bold">int</span> n, <span style="color:#0a8;font-weight:bold">String</span> str -&gt; str*n }    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> twice = nCopies.curry(<span style="color:#00D">2</span>)                    // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> twice(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bla</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">blabla</span><span style="color:#710">'</span></span>                 // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> twice(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bla</span><span style="color:#710">'</span></span>) == nCopies(<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bla</span><span style="color:#710">'</span></span>)        // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>nCopies</code> 闭包定义了两个参数</p>
</li>
<li>
<p><code>curry</code> 会将第一个参数设置为 2 ，创建一个接受单个 <code>String</code> 的新闭包（函数）</p>
</li>
<li>
<p>因此新函数调用只需使用 <code>String</code> 即可调用</p>
</li>
<li>
<p>等于调用带有两个参数的 <code>nCopies</code></p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_右柯里化"><a class="link" href="#_右柯里化">5.6.1.2. 右柯里化</a></h5>
<div class="paragraph">
<p>与左柯里化类似，可以设置闭包最右边的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> nCopies = { <span style="color:#339;font-weight:bold">int</span> n, <span style="color:#0a8;font-weight:bold">String</span> str -&gt; str*n }    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> blah = nCopies.rcurry(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bla</span><span style="color:#710">'</span></span>)                // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> blah(<span style="color:#00D">2</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">blabla</span><span style="color:#710">'</span></span>                      // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> blah(<span style="color:#00D">2</span>) == nCopies(<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bla</span><span style="color:#710">'</span></span>)             // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>nCopies</code> 闭包定义了两个参数</p>
</li>
<li>
<p><code>rcurry</code> 将最后一个参数设置为 <code>bla</code> ，创建一个接受单个 <code>int</code> 的新闭包（函数）</p>
</li>
<li>
<p>因此新函数调用只需使用一个 <code>int</code> 即可调用</p>
</li>
<li>
<p>相当于调用带有两个参数的 <code>nCopies</code></p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_基于索引的柯里化"><a class="link" href="#_基于索引的柯里化">5.6.1.3. 基于索引的柯里化</a></h5>
<div class="paragraph">
<p>如果闭包接受超过 2 个参数，则可以使用 <code>ncurry</code> 设置任意参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> volume = { <span style="color:#339;font-weight:bold">double</span> l, <span style="color:#339;font-weight:bold">double</span> w, <span style="color:#339;font-weight:bold">double</span> h -&gt; l*w*h }      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> fixedWidthVolume = volume.ncurry(<span style="color:#00D">1</span>, <span style="color:#60E">2d</span>)                 // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> volume(<span style="color:#60E">3d</span>, <span style="color:#60E">2d</span>, <span style="color:#60E">4d</span>) == fixedWidthVolume(<span style="color:#60E">3d</span>, <span style="color:#60E">4d</span>)       // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">def</span> fixedWidthAndHeight = volume.ncurry(<span style="color:#00D">1</span>, <span style="color:#60E">2d</span>, <span style="color:#60E">4d</span>)          // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> volume(<span style="color:#60E">3d</span>, <span style="color:#60E">2d</span>, <span style="color:#60E">4d</span>) == fixedWidthAndHeight(<span style="color:#60E">3d</span>)        // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>volume</code> 函数定义了3个参数</p>
</li>
<li>
<p><code>ncurry</code> 会将第二个参数 (index = 1) 设置为 <code>2d</code> ，创建一个接受l和h的新体积函数</p>
</li>
<li>
<p>该函数相当于调用省略了w的 <code>volume</code></p>
</li>
<li>
<p>还可以设置多个参数，从指定索引开始</p>
</li>
<li>
<p>结果函数接受的参数数量与初始参数减去 <code>ncurry</code> 设置的参数数量相同</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_记忆化"><a class="link" href="#_记忆化">5.6.2. 记忆化</a></h4>
<div class="paragraph">
<p>记忆化允许缓存闭包调用的结果。如果函数（闭包）完成的计算很慢，但您知道该函数将经常使用相同的参数调用，那么这很有趣。一个典型的例子是斐波那契套件。一个简单的实现可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> fib
fib = { <span style="color:#339;font-weight:bold">long</span> n -&gt; n&lt;<span style="color:#00D">2</span>?n:fib(n-<span style="color:#00D">1</span>)+fib(n-<span style="color:#00D">2</span>) }
<span style="color:#080;font-weight:bold">assert</span> fib(<span style="color:#00D">15</span>) == <span style="color:#00D">610</span> <span style="color:#777">// slow!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个幼稚的实现，因为“fib”经常使用相同的参数递归调用，从而导致指数算法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算 fib(15) 需要 fib(14) 和 fib(13) 的结果</p>
</li>
<li>
<p>计算 fib(14) 需要 fib(13) 和 fib(12) 的结果</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于调用是递归的，您已经可以看到我们将一次又一次地计算相同的值，尽管它们可以被缓存。这种简单的实现可以通过使用 <code>memoize</code> 缓存调用结果来“修复”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">fib = { <span style="color:#339;font-weight:bold">long</span> n -&gt; n&lt;<span style="color:#00D">2</span>?n:fib(n-<span style="color:#00D">1</span>)+fib(n-<span style="color:#00D">2</span>) }.memoize()
<span style="color:#080;font-weight:bold">assert</span> fib(<span style="color:#00D">25</span>) == <span style="color:#00D">75025</span> <span style="color:#777">// fast!</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The cache works <strong>using the actual values of the arguments</strong>. 这意味着如果您将记忆化与原始或装箱原始类型以外的其他类型一起使用，则应该非常小心。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用替代方法调整缓存的行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>memoizeAtMost</code> 将生成一个新的闭包，最多缓存 n 个值</p>
</li>
<li>
<p><code>memoizeAtLeast</code> 将生成一个新的闭包，该闭包缓存至少 n 个值</p>
</li>
<li>
<p><code>memoizeBetween</code> will generate a new closure which caches at least n values and at most n values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有 memoize 变体中使用的缓存都是 LRU 缓存。</p>
</div>
</div>
<div class="sect3">
<h4 id="_闭包组合"><a class="link" href="#_闭包组合">5.6.3. 闭包组合</a></h4>
<div class="paragraph">
<p>闭包组合对应于函数组合的概念(通过组合两个或多个函数（链式调用）)来创建一个新函数，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> plus2  = { <span style="color:#950">it</span> + <span style="color:#00D">2</span> }
<span style="color:#080;font-weight:bold">def</span> times3 = { <span style="color:#950">it</span> * <span style="color:#00D">3</span> }

<span style="color:#080;font-weight:bold">def</span> times3plus2 = plus2 &lt;&lt; times3
<span style="color:#080;font-weight:bold">assert</span> times3plus2(<span style="color:#00D">3</span>) == <span style="color:#00D">11</span>
<span style="color:#080;font-weight:bold">assert</span> times3plus2(<span style="color:#00D">4</span>) == plus2(times3(<span style="color:#00D">4</span>))

<span style="color:#080;font-weight:bold">def</span> plus2times3 = times3 &lt;&lt; plus2
<span style="color:#080;font-weight:bold">assert</span> plus2times3(<span style="color:#00D">3</span>) == <span style="color:#00D">15</span>
<span style="color:#080;font-weight:bold">assert</span> plus2times3(<span style="color:#00D">5</span>) == times3(plus2(<span style="color:#00D">5</span>))

<span style="color:#777">// reverse composition</span>
<span style="color:#080;font-weight:bold">assert</span> times3plus2(<span style="color:#00D">3</span>) == (times3 &gt;&gt; plus2)(<span style="color:#00D">3</span>)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_trampoline"><a class="link" href="#_trampoline">5.6.4. Trampoline</a></h4>
<div class="paragraph">
<p>递归算法通常受到物理限制的限制：最大堆栈高度。例如，如果您调用一个递归调用自身太深的方法，您最终将收到一个 <code>StackOverflowException</code> 。</p>
</div>
<div class="paragraph">
<p>在这些情况下有帮助的方法是使用 <code>Closure</code> 及其 <code>Trampoline</code> 功能。</p>
</div>
<div class="paragraph">
<p>Closures are wrapped in a <code>TrampolineClosure</code>. Upon calling, a trampolined <code>Closure</code> will call the original <code>Closure</code> waiting
for its result. If the outcome of the call is another instance of a <code>TrampolineClosure</code>, created perhaps as a result
to a call to the <code>trampoline()</code> method, the <code>Closure</code> will again be invoked. This repetitive invocation of returned
trampolined Closures instances will continue until a value other than a trampolined <code>Closure</code> is returned. That value
will become the final result of the trampoline. That way, calls are made serially, rather than filling the stack.</p>
</div>
<div class="paragraph">
<p>下面是使用 trampoline() 实现阶乘函数的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> factorial
factorial = { <span style="color:#339;font-weight:bold">int</span> n, <span style="color:#080;font-weight:bold">def</span> accu = <span style="color:#00D">1G</span> -&gt;
    <span style="color:#080;font-weight:bold">if</span> (n &lt; <span style="color:#00D">2</span>) <span style="color:#080;font-weight:bold">return</span> accu
    factorial.trampoline(n - <span style="color:#00D">1</span>, n * accu)
}
factorial = factorial.trampoline()

<span style="color:#080;font-weight:bold">assert</span> factorial(<span style="color:#00D">1</span>)    == <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> factorial(<span style="color:#00D">3</span>)    == <span style="color:#00D">1</span> * <span style="color:#00D">2</span> * <span style="color:#00D">3</span>
<span style="color:#080;font-weight:bold">assert</span> factorial(<span style="color:#00D">1000</span>) <span style="color:#777">// == 402387260.. plus another 2560 digits</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_方法指针"><a class="link" href="#_方法指针">5.6.5. 方法指针</a></h4>
<div class="paragraph">
<p>能够使用常规方法作为闭包通常很实用。例如，您可能想要使用闭包的柯里化功能，但这些功能不适用于普通方法。在 Groovy 中，您可以使用<a href="core-operators.html#method-pointer-operator">方法指针操作符</a>从任何方法获取闭包。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_语义学"><a class="link" href="#_语义学">6. 语义学</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍 Groovy 编程语言的语义。</p>
</div>
<div class="sect2">
<h3 id="_语句"><a class="link" href="#_语句">6.1. 语句</a></h3>
<div class="sect3">
<h4 id="_变量定义"><a class="link" href="#_变量定义">6.1.1. 变量定义</a></h4>
<div class="paragraph">
<p>可以使用变量的类型（如 String ）或使用关键字 def （或 var ）后跟变量名称来定义变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> x
<span style="color:#080;font-weight:bold">def</span> y
<span style="color:#339;font-weight:bold">var</span> z</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您不想给出显式类型时， def 和 var 充当类型占位符，即替换类型名称。由于您在编译时不关心类型或者依赖于类型推断（具有 Groovy 的静态性质）</p>
</div>
<div class="paragraph">
<p>变量定义必须具有类型或占位符。如果省略，类型名称将被视为引用现有变量（可能是之前声明的）</p>
</div>
<div class="paragraph">
<p>对于脚本，未声明的变量被假定来自脚本绑定。在其他情况下，您将得到丢失的属性（动态 Groovy）或编译时错误（静态 Groovy）。如果您将 def 和 var 视为 Object 的别名，您立刻就会明白。</p>
</div>
<div class="paragraph">
<p>变量定义可以提供一个初始值，在这种情况下，就像将声明和赋值（我们接下来将介绍）合二为一。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
变量定义类型可以通过使用泛型来细化，例如 List&lt;String&gt; names 。要了解有关泛型支持的更多信息，请阅读<a href="core-object-orientation.html#generics">generics section</a>部分。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_变量赋值"><a class="link" href="#_变量赋值">6.1.2. 变量赋值</a></h4>
<div class="paragraph">
<p>您可以为变量赋值以供以后使用。请尝试以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">x = <span style="color:#00D">1</span>
println x

x = <span style="color:#080;font-weight:bold">new</span> java.util.Date()
println x

x = -<span style="color:#60E">3.1499392</span>
println x

x = <span style="color:#069">false</span>
println x

x = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hi</span><span style="color:#710">&quot;</span></span>
println x</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_多重赋值"><a class="link" href="#_多重赋值">6.1.2.1. 多重赋值</a></h5>
<div class="paragraph">
<p>Groovy 支持多重赋值，即可以一次赋值多个变量，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> (a, b, c) = [<span style="color:#00D">10</span>, <span style="color:#00D">20</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">10</span> &amp;&amp; b == <span style="color:#00D">20</span> &amp;&amp; c == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您愿意，您可以提供类型作为声明的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> (<span style="color:#339;font-weight:bold">int</span> i, <span style="color:#0a8;font-weight:bold">String</span> j) = [<span style="color:#00D">10</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">assert</span> i == <span style="color:#00D">10</span> &amp;&amp; j == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了在声明变量时使用之外，它也适用于现有变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> nums = [<span style="color:#00D">1</span>, <span style="color:#00D">3</span>, <span style="color:#00D">5</span>]
<span style="color:#080;font-weight:bold">def</span> a, b, c
(a, b, c) = nums
<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">1</span> &amp;&amp; b == <span style="color:#00D">3</span> &amp;&amp; c == <span style="color:#00D">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法适用于数组和列表，以及返回其中任意一个的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> (_, month, year) = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">18th June 2009</span><span style="color:#710">&quot;</span></span>.split()
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">In </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>month</span><span style="color:#D20"> of </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>year</span><span style="color:#710">&quot;</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">In June of 2009</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_上溢和下溢"><a class="link" href="#_上溢和下溢">6.1.2.2. 上溢和下溢</a></h5>
<div class="paragraph">
<p>如果左侧有太多变量，多余的变量将用 null 填充：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> (a, b, c) = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>]
<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">1</span> &amp;&amp; b == <span style="color:#00D">2</span> &amp;&amp; c == <span style="color:#069">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果右侧有太多变量，则多余的变量将被忽略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> (a, b) = [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>]
<span style="color:#080;font-weight:bold">assert</span> a == <span style="color:#00D">1</span> &amp;&amp; b == <span style="color:#00D">2</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_使用多重赋值进行对象解构"><a class="link" href="#_使用多重赋值进行对象解构">6.1.2.3. 使用多重赋值进行对象解构</a></h5>
<div class="paragraph">
<p>在描述 Groovy 运算符的部分中，已经介绍了<a href="core-operators.html#subscript-operator">下标</a> 的情况，解释了如何重写 getAt() / putAt() 方法。
In the section describing Groovy&#8217;s operators,
the case of the <a href="core-operators.html#subscript-operator">subscript operator</a> has been covered,
explaining how you can override the <code>getAt()</code>/<code>putAt()</code> method.</p>
</div>
<div class="paragraph">
<p>通过这种技术，我们可以组合多个赋值和下标运算符方法来实现对象解构。</p>
</div>
<div class="paragraph">
<p>考虑以下不可变的 Coordinates 类，其中包含一对经度和纬度双精度值，并注意我们对 getAt() 方法的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@Immutable</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Coordinates</span> {
    <span style="color:#339;font-weight:bold">double</span> latitude
    <span style="color:#339;font-weight:bold">double</span> longitude

    <span style="color:#339;font-weight:bold">double</span> getAt(<span style="color:#339;font-weight:bold">int</span> idx) {
        <span style="color:#080;font-weight:bold">if</span> (idx == <span style="color:#00D">0</span>) latitude
        <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (idx == <span style="color:#00D">1</span>) longitude
        <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#C00;font-weight:bold">Exception</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Wrong coordinate index, use 0 or 1</span><span style="color:#710">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们实例化这个类并解构它的经度和纬度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> coordinates = <span style="color:#080;font-weight:bold">new</span> Coordinates(<span style="color:#606">latitude</span>: <span style="color:#60E">43.23</span>, <span style="color:#606">longitude</span>: <span style="color:#60E">3.67</span>) // <b class="conum">(1)</b>

<span style="color:#080;font-weight:bold">def</span> (la, lo) = coordinates                                          // <b class="conum">(2)</b>

<span style="color:#080;font-weight:bold">assert</span> la == <span style="color:#60E">43.23</span>                                                  // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> lo == <span style="color:#60E">3.67</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们创建 Coordinates 类的实例</p>
</li>
<li>
<p>然后，我们使用多重赋值来获取单独的经度和纬度值</p>
</li>
<li>
<p>我们可以断言他们的值。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_控制结构"><a class="link" href="#_控制结构">6.1.3. 控制结构</a></h4>
<div class="sect4">
<h5 id="_条件结构"><a class="link" href="#_条件结构">6.1.3.1. 条件结构</a></h5>
<div class="sect5">
<h6 id="_if_else"><a class="link" href="#_if_else">if / else</a></h6>
<div class="paragraph">
<p>Groovy 支持 Java 中常见的 if - else 语法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#069">false</span>
<span style="color:#080;font-weight:bold">def</span> y = <span style="color:#069">false</span>

<span style="color:#080;font-weight:bold">if</span> ( !x ) {
    x = <span style="color:#069">true</span>
}

<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#069">true</span>

<span style="color:#080;font-weight:bold">if</span> ( x ) {
    x = <span style="color:#069">false</span>
} <span style="color:#080;font-weight:bold">else</span> {
    y = <span style="color:#069">true</span>
}

<span style="color:#080;font-weight:bold">assert</span> x == y</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy 还支持普通的 Java“嵌套”if then else if 语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">if</span> ( ... ) {
    ...
} <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (...) {
    ...
} <span style="color:#080;font-weight:bold">else</span> {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_switch_case"><a class="link" href="#_switch_case">switch / case</a></h6>
<div class="paragraph">
<p>Groovy 中的 switch 语句向后兼容 Java 代码；因此有必要在每个case结束时使用 <code>break</code> 。</p>
</div>
<div class="paragraph">
<p>其中一个区别是 Groovy switch 语句可以处理任何类型的 switch 值，并且可以执行不同类型的匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#60E">1.23</span>
<span style="color:#080;font-weight:bold">def</span> result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">switch</span> (x) {
    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo</span><span style="color:#710">&quot;</span></span>:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">found foo</span><span style="color:#710">&quot;</span></span>
        <span style="color:#777">// lets fall through</span>

    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bar</span><span style="color:#710">&quot;</span></span>:
        result += <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bar</span><span style="color:#710">&quot;</span></span>

    <span style="color:#080;font-weight:bold">case</span> [<span style="color:#00D">4</span>, <span style="color:#00D">5</span>, <span style="color:#00D">6</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">inList</span><span style="color:#710">'</span></span>]:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">list</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">12</span>..<span style="color:#00D">30</span>:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">range</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">case</span> <span style="color:#0a8;font-weight:bold">Integer</span>:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">integer</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">case</span> <span style="color:#0a8;font-weight:bold">Number</span>:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">number</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">case</span> ~<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">fo*</span><span style="color:#404">/</span></span>: <span style="color:#777">// toString() representation of x matches the pattern?</span>
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo regex</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">case</span> { <span style="color:#950">it</span> &lt; <span style="color:#00D">0</span> }: <span style="color:#777">// or { x &lt; 0 }</span>
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">negative</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">break</span>

    <span style="color:#080;font-weight:bold">default</span>:
        result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">default</span><span style="color:#710">&quot;</span></span>
}

<span style="color:#080;font-weight:bold">assert</span> result == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">number</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Switch 支持以下类型的比较：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Class case values match if the switch value is an instance of the class</p>
</li>
<li>
<p>Regular expression case values match if the <code>toString()</code> representation of the switch value matches the regex</p>
</li>
<li>
<p>Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)</p>
</li>
<li>
<p>Closure case values match if the calling the closure returns a result which is true according to the <a href="#the-groovy-truth">Groovy truth</a></p>
</li>
<li>
<p>If none of the above are used then the case value matches if the case value equals the switch value</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
When using a closure case value, the default <code>it</code> parameter is actually the switch value (in our example, variable <code>x</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Groovy 还支持 switch 表达式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> partner = <span style="color:#080;font-weight:bold">switch</span>(person) {
    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Romeo</span><span style="color:#710">'</span></span>  -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Juliet</span><span style="color:#710">'</span></span>
    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Adam</span><span style="color:#710">'</span></span>   -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Eve</span><span style="color:#710">'</span></span>
    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Antony</span><span style="color:#710">'</span></span> -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Cleopatra</span><span style="color:#710">'</span></span>
    <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Bonnie</span><span style="color:#710">'</span></span> -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Clyde</span><span style="color:#710">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_循环结构"><a class="link" href="#_循环结构">6.1.3.2. 循环结构</a></h5>
<div class="sect5">
<h6 id="_经典的for循环"><a class="link" href="#_经典的for循环">经典的for循环</a></h6>
<div class="paragraph">
<p>Groovy 支持标准的 Java/C for 循环</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> message = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; <span style="color:#00D">5</span>; i++) {
    message += <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hi </span><span style="color:#710">'</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> message == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hi Hi Hi Hi Hi </span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_增强的经典_java_风格的_for_循环"><a class="link" href="#_增强的经典_java_风格的_for_循环">增强的经典 Java 风格的 for 循环</a></h6>
<div class="paragraph">
<p>现在支持使用逗号分隔表达式的 Java 经典 for 循环的更复杂的形式。例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> facts = <span style="color:#339;font-weight:bold">[]</span>
<span style="color:#080;font-weight:bold">def</span> count = <span style="color:#00D">5</span>
<span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> fact = <span style="color:#00D">1</span>, i = <span style="color:#00D">1</span>; i &lt;= count; i++, fact *= i) {
    facts &lt;&lt; fact
}
<span style="color:#080;font-weight:bold">assert</span> facts == [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">6</span>, <span style="color:#00D">24</span>, <span style="color:#00D">120</span>]</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_与for循环结合的多重赋值"><a class="link" href="#_与for循环结合的多重赋值">与for循环结合的多重赋值</a></h6>
<div class="paragraph">
<p>Groovy 从 Groovy 1.6 开始就支持多重赋值语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// multi-assignment with types</span>
<span style="color:#080;font-weight:bold">def</span> (<span style="color:#0a8;font-weight:bold">String</span> x, <span style="color:#339;font-weight:bold">int</span> y) = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>]
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>x</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>y</span><span style="color:#710">&quot;</span></span> == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo 42</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些现在可以出现在 for 循环中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// multi-assignment goes loopy</span>
<span style="color:#080;font-weight:bold">def</span> baNums = <span style="color:#339;font-weight:bold">[]</span>
<span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">def</span> (<span style="color:#0a8;font-weight:bold">String</span> u, <span style="color:#339;font-weight:bold">int</span> v) = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>, <span style="color:#00D">42</span>]; v &lt; <span style="color:#00D">45</span>; u++, v++) {
    baNums &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>u</span><span style="color:#D20"> </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>v</span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> baNums == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar 42</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bas 43</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bat 44</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_for_in_循环"><a class="link" href="#_for_in_循环">for in 循环</a></h6>
<div class="paragraph">
<p>Groovy 中的 for 循环要简单得多，并且适用于任何类型的数组、集合、Map 等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// iterate over a range</span>
<span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">for</span> ( i <span style="color:#080;font-weight:bold">in</span> <span style="color:#00D">0</span>..<span style="color:#00D">9</span> ) {
    x += i
}
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">45</span>

<span style="color:#777">// iterate over a list</span>
x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">for</span> ( i <span style="color:#080;font-weight:bold">in</span> [<span style="color:#00D">0</span>, <span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">4</span>] ) {
    x += i
}
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">10</span>

<span style="color:#777">// iterate over an array</span>
<span style="color:#080;font-weight:bold">def</span> array = (<span style="color:#00D">0</span>..<span style="color:#00D">4</span>).toArray()
x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">for</span> ( i <span style="color:#080;font-weight:bold">in</span> array ) {
    x += i
}
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">10</span>

<span style="color:#777">// iterate over a map</span>
<span style="color:#080;font-weight:bold">def</span> map = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">abc</span><span style="color:#710">'</span></span>:<span style="color:#00D">1</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">def</span><span style="color:#710">'</span></span>:<span style="color:#00D">2</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">xyz</span><span style="color:#710">'</span></span>:<span style="color:#00D">3</span>]
x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">for</span> ( e <span style="color:#080;font-weight:bold">in</span> map ) {
    x += e.value
}
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">6</span>

<span style="color:#777">// iterate over values in a map</span>
x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">for</span> ( v <span style="color:#080;font-weight:bold">in</span> map.values() ) {
    x += v
}
<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">6</span>

<span style="color:#777">// iterate over the characters in a string</span>
<span style="color:#080;font-weight:bold">def</span> text = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">abc</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> list = <span style="color:#339;font-weight:bold">[]</span>
<span style="color:#080;font-weight:bold">for</span> (c <span style="color:#080;font-weight:bold">in</span> text) {
    list.add(c)
}
<span style="color:#080;font-weight:bold">assert</span> list == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">b</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">c</span><span style="color:#710">&quot;</span></span>]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Groovy 还支持带有冒号的 Java 冒号变体： <code>for (char c : text) {}</code>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_while_循环"><a class="link" href="#_while_循环">while 循环</a></h6>
<div class="paragraph">
<p>Groovy 像 Java 一样支持常见的 <code>while {&#8230;&#8203;}</code> 循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">0</span>
<span style="color:#080;font-weight:bold">def</span> y = <span style="color:#00D">5</span>

<span style="color:#080;font-weight:bold">while</span> ( y-- &gt; <span style="color:#00D">0</span> ) {
    x++
}

<span style="color:#080;font-weight:bold">assert</span> x == <span style="color:#00D">5</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_dowhile_循环"><a class="link" href="#_dowhile_循环">do/while 循环</a></h6>
<div class="paragraph">
<p>现在支持 Java 类 do/while 循环。例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">// classic Java-style do..while loop</span>
<span style="color:#080;font-weight:bold">def</span> count = <span style="color:#00D">5</span>
<span style="color:#080;font-weight:bold">def</span> fact = <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">do</span> {
    fact *= count--
} <span style="color:#080;font-weight:bold">while</span>(count &gt; <span style="color:#00D">1</span>)
<span style="color:#080;font-weight:bold">assert</span> fact == <span style="color:#00D">120</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_异常处理"><a class="link" href="#_异常处理">6.1.3.3. 异常处理</a></h5>
<div class="paragraph">
<p>异常处理与Java相同。</p>
</div>
</div>
<div class="sect4">
<h5 id="_try_catch_finally"><a class="link" href="#_try_catch_finally">6.1.3.4. try / catch / finally</a></h5>
<div class="paragraph">
<p>您可以指定 try-catch-finally 、 try-catch 或 try-finally 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">try</span> {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">moo</span><span style="color:#710">'</span></span>.toLong()   <span style="color:#777">// this will generate an exception</span>
    <span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">false</span>     <span style="color:#777">// asserting that this point should never be reached</span>
} <span style="color:#080;font-weight:bold">catch</span> ( e ) {
    <span style="color:#080;font-weight:bold">assert</span> e <span style="color:#080;font-weight:bold">in</span> <span style="color:#C00;font-weight:bold">NumberFormatException</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将代码放在匹配的“try”子句后面的“finally”子句中，这样无论“try”子句中的代码是否抛出异常，finally子句中的代码都将始终执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> z
<span style="color:#080;font-weight:bold">try</span> {
    <span style="color:#080;font-weight:bold">def</span> i = <span style="color:#00D">7</span>, j = <span style="color:#00D">0</span>
    <span style="color:#080;font-weight:bold">try</span> {
        <span style="color:#080;font-weight:bold">def</span> k = i / j
        <span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">false</span>        <span style="color:#777">//never reached due to Exception in previous line</span>
    } <span style="color:#080;font-weight:bold">finally</span> {
        z = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">reached here</span><span style="color:#710">'</span></span>  <span style="color:#777">//always executed even if Exception thrown</span>
    }
} <span style="color:#080;font-weight:bold">catch</span> ( e ) {
    <span style="color:#080;font-weight:bold">assert</span> e <span style="color:#080;font-weight:bold">in</span> <span style="color:#C00;font-weight:bold">ArithmeticException</span>
    <span style="color:#080;font-weight:bold">assert</span> z == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">reached here</span><span style="color:#710">'</span></span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_多重捕获"><a class="link" href="#_多重捕获">6.1.3.5. 多重捕获</a></h5>
<div class="paragraph">
<p>使用多 catch 块（自 Groovy 2.0 起），我们能够定义多个要由同一 catch 块捕获和处理的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">try</span> {
    <span style="color:#777">/* ... */</span>
} <span style="color:#080;font-weight:bold">catch</span> ( <span style="color:#C00;font-weight:bold">IOException</span> | <span style="color:#C00;font-weight:bold">NullPointerException</span> e ) {
    <span style="color:#777">/* one block to handle 2 exceptions */</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_try_with_resources"><a class="link" href="#_try_with_resources">6.1.3.6. Try with resources</a></h5>
<div class="paragraph">
<p>Groovy 通常为自动资源管理 (ARM) 提供 Java 7 的 try -with-resources 语句的更好替代方案。现在，迁移到 Groovy 但仍想使用旧样式的 Java 程序员支持该语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">FromResource</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">ByteArrayInputStream</span> {
    <span style="color:#007">@Override</span>
    <span style="color:#339;font-weight:bold">void</span> close() <span style="color:#088;font-weight:bold">throws</span> <span style="color:#C00;font-weight:bold">IOException</span> {
        <span style="color:#950">super</span>.close()
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">FromResource closing</span><span style="color:#710">&quot;</span></span>
    }

    FromResource(<span style="color:#0a8;font-weight:bold">String</span> input) {
        <span style="color:#950">super</span>(input.toLowerCase().bytes)
    }
}

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ToResource</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">ByteArrayOutputStream</span> {
    <span style="color:#007">@Override</span>
    <span style="color:#339;font-weight:bold">void</span> close() <span style="color:#088;font-weight:bold">throws</span> <span style="color:#C00;font-weight:bold">IOException</span> {
        <span style="color:#950">super</span>.close()
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ToResource closing</span><span style="color:#710">&quot;</span></span>
    }
}

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">wrestle</span>(s) {
    <span style="color:#080;font-weight:bold">try</span> (
            FromResource from = <span style="color:#080;font-weight:bold">new</span> FromResource(s)
            ToResource to = <span style="color:#080;font-weight:bold">new</span> ToResource()
    ) {
        to &lt;&lt; from
        <span style="color:#080;font-weight:bold">return</span> to.toString()
    }
}

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">wrestle2</span>(s) {
    FromResource from = <span style="color:#080;font-weight:bold">new</span> FromResource(s)
    <span style="color:#080;font-weight:bold">try</span> (from; ToResource to = <span style="color:#080;font-weight:bold">new</span> ToResource()) { <span style="color:#777">// Enhanced try-with-resources in Java 9+</span>
        to &lt;&lt; from
        <span style="color:#080;font-weight:bold">return</span> to.toString()
    }
}

<span style="color:#080;font-weight:bold">assert</span> wrestle(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ARM was here!</span><span style="color:#710">&quot;</span></span>).contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">arm</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> wrestle2(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ARM was here!</span><span style="color:#710">&quot;</span></span>).contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">arm</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ToResource closing
FromResource closing
ToResource closing
FromResource closing</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_断言"><a class="link" href="#_断言">6.1.4. 断言</a></h4>
<div class="paragraph">
<p>与 Groovy 与 Java 共享 assert 关键字不同，后者在 Groovy 中的行为非常不同。首先，Groovy 中的断言始终会执行，与 JVM 的 -ea 标志无关。它使其成为单元测试的一流选择。</p>
</div>
<div class="paragraph">
<p>断言分为 3 部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>assert [left expression] == [right expression] : (optional message)</pre>
</div>
</div>
<div class="paragraph">
<p>断言的结果与 Java 中得到的结果非常不同。如果断言为真，那么什么也不会发生。如果断言为假，则它提供所断言表达式的每个子表达式的值的可视化表示。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">1</span>+<span style="color:#00D">1</span> == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Caught: Assertion failed:

assert 1+1 == 3
        |  |
        2  false</pre>
</div>
</div>
<div class="paragraph">
<p>当表达式更复杂时，断言变得非常有趣，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">def</span> y = <span style="color:#00D">7</span>
<span style="color:#080;font-weight:bold">def</span> z = <span style="color:#00D">5</span>
<span style="color:#080;font-weight:bold">def</span> calc = { a,b -&gt; a*b+<span style="color:#00D">1</span> }
<span style="color:#080;font-weight:bold">assert</span> calc(x,y) == [x,z].sum()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印每个子表达式的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> calc(x,y) == [x,z].sum()
       |    | |  |   | |  |
       <span style="color:#00D">15</span>   <span style="color:#00D">2</span> <span style="color:#00D">7</span>  |   <span style="color:#00D">2</span> <span style="color:#00D">5</span>  <span style="color:#00D">7</span>
                 <span style="color:#069">false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不想要像上面那样漂亮的打印错误消息，您可以通过更改断言的可选消息部分来回退到自定义错误消息，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">2</span>
<span style="color:#080;font-weight:bold">def</span> y = <span style="color:#00D">7</span>
<span style="color:#080;font-weight:bold">def</span> z = <span style="color:#00D">5</span>
<span style="color:#080;font-weight:bold">def</span> calc = { a,b -&gt; a*b+<span style="color:#00D">1</span> }
<span style="color:#080;font-weight:bold">assert</span> calc(x,y) == z*z : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Incorrect computation result</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印以下错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = <span style="color:#00D">5</span>, z = <span style="color:#00D">5</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_标签语句"><a class="link" href="#_标签语句">6.1.5. 标签语句</a></h4>
<div class="paragraph">
<p>任何语句都可以与标签相关联。标签不会影响代码的语义，可用于使代码更易于阅读，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#606">given</span>:
    <span style="color:#080;font-weight:bold">def</span> x = <span style="color:#00D">1</span>
    <span style="color:#080;font-weight:bold">def</span> y = <span style="color:#00D">2</span>
<span style="color:#606">when</span>:
    <span style="color:#080;font-weight:bold">def</span> z = x+y
<span style="color:#606">then</span>:
    <span style="color:#080;font-weight:bold">assert</span> z == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管没有更改带标签语句的语义，但可以使用 break 指令中的标签作为跳转目标，如下例所示。然而，即使允许这样做，这种编码风格通常也被认为是一种不好的做法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> i=<span style="color:#00D">0</span>;i&lt;<span style="color:#00D">10</span>;i++) {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">int</span> j=<span style="color:#00D">0</span>;j&lt;i;j++) {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">j=</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>j</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">if</span> (j == <span style="color:#00D">5</span>) {
            <span style="color:#080;font-weight:bold">break</span> exit
        }
    }
    <span style="color:#606">exit</span>: println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">i=</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>i</span><span style="color:#710">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要明白的是，默认情况下标签对代码的语义没有影响，但是它们属于抽象语法树 (AST)，因此 AST 转换可以使用该信息对代码执行转换，因此导致不同的语义。 Spock 框架尤其这样做是为了使测试更容易。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_表达式"><a class="link" href="#_表达式">6.2. 表达式</a></h3>
<div class="paragraph">
<p>表达式是 Groovy 程序的构建块，用于引用现有值并执行代码来创建新值。</p>
</div>
<div class="paragraph">
<p>Groovy 支持许多与 Java 相同类型的表达式，包括：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Expressions like Java</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>表达式</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>描述</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>foo</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>the name of a variable, field, parameter, &#8230;&#8203;</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>this</code>, <code>super</code>, <code>it</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>special names</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code>, <code>10</code>, <code>"bar"</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>literals</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>String.class</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Class literal</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>(</code> <em>expression</em> <code>)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>parenthesised expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>foo++</code>, <code>~bar</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Unary <a href="core-operators.html">operator</a> expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>foo + bar</code>, <code>bar * baz</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Binary <a href="core-operators.html">operator</a> expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>foo ? bar : baz</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Ternary <a href="core-operators.html">operator</a> expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>(Integer x, Integer y) &#8594; x + y</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Lambda expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span> == <span style="color:#080;font-weight:bold">switch</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) {
  <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span> -&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>switch expressions</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Groovy 还有一些自己的特殊表达式：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Special expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Example expression(s)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Description</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>String</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Abbreviated class literal (when not ambiguous)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>{ x, y &#8594; x + y }</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Closure expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>[1, 3, 5]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>literal list expressions</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>[a:2, b:4, c:6]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>literal map expressions</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Groovy 还扩展了 Java 中用于成员访问的普通点表示法。 Groovy 通过指定某些感兴趣数据的层次结构中的路径，为访问层次结构数据结构提供特殊支持。这些 Groovy 路径表达式称为 GPath 表达式。</p>
</div>
<div class="sect3">
<h4 id="gpath_expressions"><a class="link" href="#gpath_expressions">6.2.1. GPath 表达式</a></h4>
<div class="paragraph">
<p>GPath 是集成到 Groovy 中的路径表达式语言，它允许识别部分嵌套结构化数据。从这个意义上说，它与 XPath 对于 XML 具有相似的目标和范围。 GPath 通常用于处理 XML 的上下文中，但它实际上适用于任何对象图。 XPath 使用类似文件系统的路径表示法，即由斜杠分隔各部分的树层次结构 / ，GPath 使用点对象表示法来执行对象导航。</p>
</div>
<div class="paragraph">
<p>例如，您可以指定感兴趣的对象或元素的路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a.b.c</code> &#8594; 对于 XML，获取 a 内 b 内的所有 c 元素</p>
</li>
<li>
<p><code>a.b.c</code> &#8594; 对于 POJO，获取 a 的所有 b 属性的 c 属性（有点像 a.getB().getC() 在 JavaBean 中）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这两种情况下，GPath 表达式都可以被视为对象视图的查询。对于 POJO，对象视图常是由通过对象实例化和组合编写的程序构建的；对于 XML 处理，对象视图是 parsing XML 文本的结果，通常使用 XmlParser 或 XmlSlurper 等类。有关在 Groovy 中使用 XML 的更多详细信息，请参阅<a href="xml-userguide.html#processing-xml">解析 XML</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>当查询从 XmlParser 或 XmlSlurper 生成的对象视图时，GPath 表达式可以引用使用 @ 表示法的元素上定义的属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a["@href"]</code> &#8594; map-like表示法 : 所有 a 元素的 href 属性</p>
</li>
<li>
<p><code>a.'@href'</code>  &#8594; 属性表示法 : 另一种表达方式</p>
</li>
<li>
<p><code>a.@href</code>    &#8594; 直接表示法 : 另一种表达方式</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_对象导航"><a class="link" href="#_对象导航">6.2.1.1. 对象导航</a></h5>
<div class="paragraph">
<p>让我们看一个简单对象图上的 GPath 表达式的示例，该对象图是使用 java 反射获得的。假设您位于一个类的非静态方法中，该方法具有另一个名为 aMethodFoo 的方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">void</span> aMethodFoo() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">This is aMethodFoo.</span><span style="color:#710">&quot;</span></span> } // <b class="conum">(0)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下 GPath 表达式将获取该方法的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">aMethodFoo</span><span style="color:#710">'</span></span>] == <span style="color:#950">this</span>.class.methods.name.grep(~<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">.*Foo</span><span style="color:#404">/</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>更准确地说，上面的 GPath 表达式生成一个 String 列表，每个字符串都是 this 上现有方法的名称，其中该名称以 Foo 结尾。</p>
</div>
<div class="paragraph">
<p>现在，考虑到该类中还定义了以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">void</span> aMethodBar() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">This is aMethodBar.</span><span style="color:#710">&quot;</span></span> } // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">void</span> anotherFooMethod() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">This is anotherFooMethod.</span><span style="color:#710">&quot;</span></span> } // <b class="conum">(2)</b>
<span style="color:#339;font-weight:bold">void</span> aSecondMethodBar() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">This is aSecondMethodBar.</span><span style="color:#710">&quot;</span></span> } // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么以下 GPath 表达式将获取 (1) 和 (3) 的名称，但不会获取 (2) 或 (0) 的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">aMethodBar</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">aSecondMethodBar</span><span style="color:#710">'</span></span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Set</span> == <span style="color:#950">this</span>.class.methods.name.grep(~<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">.*Bar</span><span style="color:#404">/</span></span>) <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Set</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_表达式解构"><a class="link" href="#_表达式解构">6.2.1.2. 表达式解构</a></h5>
<div class="paragraph">
<p>我们可以分解表达式 this.class.methods.name.grep(~/.*Bar/) 以了解 GPath 的计算方式：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>this.class</code></dt>
<dd>
<p>属性访问器相当于 Java 中的 this.getClass() ，生成一个 Class 对象。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods</code></dt>
<dd>
<p>属性访问器，相当于 this.getClass().getMethods() ，生成 Method 对象的数组。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name</code></dt>
<dd>
<p>对数组的每个元素应用属性访问器并生成结果列表。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name.grep(&#8230;&#8203;)</code></dt>
<dd>
<p>对 this.class.methods.name 生成的列表的每个元素调用方法 grep 并生成结果列表。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
像 this.class.methods 这样的子表达式会生成一个数组，因为这就是在 Java 中调用 this.getClass().getMethods() 会生成的结果。 GPath 表达式没有约定，其中 s 表示列表或类似内容。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>GPath 表达式的一项强大功能是，将对集合的属性访问转换为对集合的每个元素的属性访问，并将结果收集到集合中。因此，表达式 this.class.methods.name 在Java中可以表达如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt; methodNames = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt;();
<span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">Method</span> method : <span style="color:#950">this</span>.getClass().getMethods()) {
   methodNames.add(method.getName());
}
<span style="color:#080;font-weight:bold">return</span> methodNames;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组访问表示法也可以用在存在集合的 GPath 表达式中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">aSecondMethodBar</span><span style="color:#710">'</span></span> == <span style="color:#950">this</span>.class.methods.name.grep(~<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">.*Bar</span><span style="color:#404">/</span></span>).sort()[<span style="color:#00D">1</span>]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
GPath 表达式中的数组访问是从零开始的
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_用于_xml_导航的_gpath"><a class="link" href="#_用于_xml_导航的_gpath">6.2.1.3. 用于 XML 导航的 GPath</a></h5>
<div class="paragraph">
<p>下面是一个包含 XML 文档和各种形式的 GPath 表达式的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> xmlText = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;&quot;&quot;</span><span style="color:#D20">
              | &lt;root&gt;
              |   &lt;level&gt;
              |      &lt;sublevel id='1'&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;mykey&lt;/key&gt;
              |          &lt;value&gt;value 123&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |      &lt;/sublevel&gt;
              |      &lt;sublevel id='2'&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;anotherKey&lt;/key&gt;
              |          &lt;value&gt;42&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;mykey&lt;/key&gt;
              |          &lt;value&gt;fizzbuzz&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |      &lt;/sublevel&gt;
              |   &lt;/level&gt;
              | &lt;/root&gt;
              </span><span style="color:#710">&quot;&quot;&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> root = <span style="color:#080;font-weight:bold">new</span> XmlSlurper().parseText(xmlText.stripMargin())
<span style="color:#080;font-weight:bold">assert</span> root.level.size() == <span style="color:#00D">1</span> // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> root.level.sublevel.size() == <span style="color:#00D">2</span> // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> root.level.sublevel.findAll { <span style="color:#950">it</span>.@id == <span style="color:#00D">1</span> }.size() == <span style="color:#00D">1</span> // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> root.level.sublevel[<span style="color:#00D">1</span>].keyVal[<span style="color:#00D">0</span>].key.text() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">anotherKey</span><span style="color:#710">'</span></span> // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>root 下有一个 level 节点</p>
</li>
<li>
<p>root/level 下有两个 sublevel 节点</p>
</li>
<li>
<p>有一个元素 sublevel 具有属性 id ，其值为 1</p>
</li>
<li>
<p>root/level 下的第二个 sublevel 元素的第一个 keyVal 元素的 key 元素的文本值为 'anotherKey'
有关 XML GPath 表达式的更多详细信息，请参阅 XML 用户指南<a href="xml-userguide.html#processing-xml">XML User Guide</a>。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_promotion_and_coercion"><a class="link" href="#_promotion_and_coercion">6.3. Promotion and coercion</a></h3>
<div class="sect3">
<h4 id="_number_promotion"><a class="link" href="#_number_promotion">6.3.1. Number promotion</a></h4>
<div class="paragraph">
<p>The rules of number promotion are specified in the section on <a href="core-syntax.html#_math_operations">math operations</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="closure-coercion"><a class="link" href="#closure-coercion">6.3.2. Closure to type coercion</a></h4>
<div class="sect4">
<h5 id="_将闭包分配给_sam_类型"><a class="link" href="#_将闭包分配给_sam_类型">6.3.2.1. 将闭包分配给 SAM 类型</a></h5>
<div class="paragraph">
<p>A SAM type is a type which defines a single abstract method. This includes:</p>
</div>
<div class="listingblock">
<div class="title">Functional interfaces</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> <span style="color:#0a8;font-weight:bold">Predicate</span>&lt;T&gt; {
    <span style="color:#339;font-weight:bold">boolean</span> accept(T obj)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Abstract classes with single abstract method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Greeter</span> {
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#0a8;font-weight:bold">String</span> getName()
    <span style="color:#339;font-weight:bold">void</span> greet() {
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>name</span><span style="color:#710">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any closure can be converted into a SAM type using the <code>as</code> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Predicate</span> filter = { <span style="color:#950">it</span>.contains <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">G</span><span style="color:#710">'</span></span> } <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Predicate</span>
<span style="color:#080;font-weight:bold">assert</span> filter.accept(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>) == <span style="color:#069">true</span>

Greeter greeter = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span> } <span style="color:#080;font-weight:bold">as</span> Greeter
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the <code>as Type</code> expression is optional since Groovy 2.2.0. You can omit it and simply write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Predicate</span> filter = { <span style="color:#950">it</span>.contains <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">G</span><span style="color:#710">'</span></span> }
<span style="color:#080;font-weight:bold">assert</span> filter.accept(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>) == <span style="color:#069">true</span>

Greeter greeter = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span> }
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>which means you are also allowed to use method pointers, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">boolean</span> doFilter(<span style="color:#0a8;font-weight:bold">String</span> s) { s.contains(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">G</span><span style="color:#710">'</span></span>) }

<span style="color:#0a8;font-weight:bold">Predicate</span> filter = <span style="color:#950">this</span>.&amp;doFilter
<span style="color:#080;font-weight:bold">assert</span> filter.accept(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>) == <span style="color:#069">true</span>

Greeter greeter = GroovySystem.&amp;getVersion
greeter.greet()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_calling_a_method_accepting_a_sam_type_with_a_closure"><a class="link" href="#_calling_a_method_accepting_a_sam_type_with_a_closure">6.3.2.2. Calling a method accepting a SAM type with a closure</a></h5>
<div class="paragraph">
<p>The second and probably more important use case for closure to SAM type coercion is calling a method which accepts
a SAM type. Imagine the following method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">public</span> &lt;T&gt; <span style="color:#0a8;font-weight:bold">List</span>&lt;T&gt; filter(<span style="color:#0a8;font-weight:bold">List</span>&lt;T&gt; source, <span style="color:#0a8;font-weight:bold">Predicate</span>&lt;T&gt; predicate) {
    source.findAll { predicate.accept(<span style="color:#950">it</span>) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can call it with a closure, without having to create an explicit implementation of the interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> filter([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Java</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>], { <span style="color:#950">it</span>.contains <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">G</span><span style="color:#710">'</span></span>} <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Predicate</span>) == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> filter([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Java</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>]) { <span style="color:#950">it</span>.contains <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">G</span><span style="color:#710">'</span></span>} == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Groovy</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the
closure outside the parenthesis, improving the readability of your code.</p>
</div>
</div>
<div class="sect4">
<h5 id="_closure_to_arbitrary_type_coercion"><a class="link" href="#_closure_to_arbitrary_type_coercion">6.3.2.3. Closure to arbitrary type coercion</a></h5>
<div class="paragraph">
<p>In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let&#8217;s define the
following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> FooBar {
    <span style="color:#339;font-weight:bold">int</span> foo()
    <span style="color:#339;font-weight:bold">void</span> bar()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can coerce a closure into the interface using the <code>as</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> impl = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span>; <span style="color:#00D">123</span> } <span style="color:#080;font-weight:bold">as</span> FooBar</code></pre>
</div>
</div>
<div class="paragraph">
<p>This produces a class for which all methods are implemented using the closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> impl.foo() == <span style="color:#00D">123</span>
impl.bar()</code></pre>
</div>
</div>
<div class="paragraph">
<p>But it is also possible to coerce a closure to any class. For example, we can replace the <code>interface</code> that we defined
with <code>class</code> without changing the assertions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">FooBar</span> {
    <span style="color:#339;font-weight:bold">int</span> foo() { <span style="color:#00D">1</span> }
    <span style="color:#339;font-weight:bold">void</span> bar() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span> }
}

<span style="color:#080;font-weight:bold">def</span> impl = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ok</span><span style="color:#710">'</span></span>; <span style="color:#00D">123</span> } <span style="color:#080;font-weight:bold">as</span> FooBar

<span style="color:#080;font-weight:bold">assert</span> impl.foo() == <span style="color:#00D">123</span>
impl.bar()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map_to_type_coercion"><a class="link" href="#_map_to_type_coercion">6.3.3. Map to type coercion</a></h4>
<div class="paragraph">
<p>Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an
alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are
interpreted as method names, while the values are the method implementation. The following example illustrates the
coercion of a map into an <code>Iterator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> map
map = [
  <span style="color:#606">i</span>: <span style="color:#00D">10</span>,
  <span style="color:#606">hasNext</span>: { map.i &gt; <span style="color:#00D">0</span> },
  <span style="color:#606">next</span>: { map.i-- },
]
<span style="color:#080;font-weight:bold">def</span> iter = map <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Iterator</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods
that are actually called, but if a method is called that doesn&#8217;t exist in the map a <code>MissingMethodException</code> or an
<code>UnsupportedOperationException</code> is thrown, depending on the arguments passed to the call,
as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> X {
    <span style="color:#339;font-weight:bold">void</span> f()
    <span style="color:#339;font-weight:bold">void</span> g(<span style="color:#339;font-weight:bold">int</span> n)
    <span style="color:#339;font-weight:bold">void</span> h(<span style="color:#0a8;font-weight:bold">String</span> s, <span style="color:#339;font-weight:bold">int</span> n)
}

x = [ <span style="color:#606">f</span>: {println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">f called</span><span style="color:#710">&quot;</span></span>} ] <span style="color:#080;font-weight:bold">as</span> X
x.f() <span style="color:#777">// method exists</span>
x.g() <span style="color:#777">// MissingMethodException here</span>
x.g(<span style="color:#00D">5</span>) <span style="color:#777">// UnsupportedOperationException here</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The type of the exception depends on the call itself:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MissingMethodException</code> if the arguments of the call do not match those from the interface/class</p>
</li>
<li>
<p><code>UnsupportedOperationException</code> if the arguments of the call match one of the overloaded methods of the interface/class</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_string_to_enum_coercion"><a class="link" href="#_string_to_enum_coercion">6.3.4. String to enum coercion</a></h4>
<div class="paragraph">
<p>Groovy allows transparent <code>String</code> (or <code>GString</code>) to enum values coercion. Imagine you define the following enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">enum</span> State {
    up,
    down
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then you can assign a string to the enum without having to use an explicit <code>as</code> coercion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">State st = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">up</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to use a <code>GString</code> as the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> val = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">up</span><span style="color:#710">&quot;</span></span>
State st = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>val<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">assert</span> st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this would throw a runtime error (<code>IllegalArgumentException</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">State st = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">not an enum value</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is also possible to use implicit coercion in switch statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">State switchState(State st) {
    <span style="color:#080;font-weight:bold">switch</span> (st) {
        <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">up</span><span style="color:#710">'</span></span>:
            <span style="color:#080;font-weight:bold">return</span> State.down <span style="color:#777">// explicit constant</span>
        <span style="color:#080;font-weight:bold">case</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">down</span><span style="color:#710">'</span></span>:
            <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">up</span><span style="color:#710">'</span></span> <span style="color:#777">// implicit coercion for return types</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>in particular, see how the <code>case</code> use string constants. But if you call a method that uses an enum with a <code>String</code>
argument, you still have to use an explicit <code>as</code> coercion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> switchState(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">up</span><span style="color:#710">'</span></span> <span style="color:#080;font-weight:bold">as</span> State) == State.down
<span style="color:#080;font-weight:bold">assert</span> switchState(State.down) == State.up</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_type_coercion"><a class="link" href="#_custom_type_coercion">6.3.5. Custom type coercion</a></h4>
<div class="paragraph">
<p>It is possible for a class to define custom coercion strategies by implementing the <code>asType</code> method. Custom coercion
is invoked using the <code>as</code> operator and is never implicit. As an example,
imagine you defined two classes, <code>Polar</code> and <code>Cartesian</code>, like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Polar</span> {
    <span style="color:#339;font-weight:bold">double</span> r
    <span style="color:#339;font-weight:bold">double</span> phi
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Cartesian</span> {
   <span style="color:#339;font-weight:bold">double</span> x
   <span style="color:#339;font-weight:bold">double</span> y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define
the <code>asType</code> method in the <code>Polar</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">asType</span>(<span style="color:#0a8;font-weight:bold">Class</span> target) {
    <span style="color:#080;font-weight:bold">if</span> (Cartesian==target) {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Cartesian(<span style="color:#606">x</span>: r*cos(phi), <span style="color:#606">y</span>: r*sin(phi))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which allows you to use the <code>as</code> coercion operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> sigma = <span style="color:#60E">1E-16</span>
<span style="color:#080;font-weight:bold">def</span> polar = <span style="color:#080;font-weight:bold">new</span> Polar(<span style="color:#606">r</span>:<span style="color:#60E">1.0</span>,<span style="color:#606">phi</span>:PI/<span style="color:#00D">2</span>)
<span style="color:#080;font-weight:bold">def</span> cartesian = polar <span style="color:#080;font-weight:bold">as</span> Cartesian
<span style="color:#080;font-weight:bold">assert</span> abs(cartesian.x-sigma) &lt; sigma</code></pre>
</div>
</div>
<div class="paragraph">
<p>Putting it all together, the <code>Polar</code> class looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Polar</span> {
    <span style="color:#339;font-weight:bold">double</span> r
    <span style="color:#339;font-weight:bold">double</span> phi
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">asType</span>(<span style="color:#0a8;font-weight:bold">Class</span> target) {
        <span style="color:#080;font-weight:bold">if</span> (Cartesian==target) {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Cartesian(<span style="color:#606">x</span>: r*cos(phi), <span style="color:#606">y</span>: r*sin(phi))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but it is also possible to define <code>asType</code> outside of the <code>Polar</code> class, which can be practical if you want to define
custom coercion strategies for "closed" classes or classes for which you don&#8217;t own the source code, for example using
a metaclass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Polar.metaClass.asType = { <span style="color:#0a8;font-weight:bold">Class</span> target -&gt;
    <span style="color:#080;font-weight:bold">if</span> (Cartesian==target) {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Cartesian(<span style="color:#606">x</span>: r*cos(phi), <span style="color:#606">y</span>: r*sin(phi))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_class_literals_vs_variables_and_the_as_operator"><a class="link" href="#_class_literals_vs_variables_and_the_as_operator">6.3.6. Class literals vs variables and the as operator</a></h4>
<div class="paragraph">
<p>Using the <code>as</code> keyword is only possible if you have a static reference to a class, like in the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Greeter {
    <span style="color:#339;font-weight:bold">void</span> greet()
}
<span style="color:#080;font-weight:bold">def</span> greeter = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Groovy!</span><span style="color:#710">'</span></span> } <span style="color:#080;font-weight:bold">as</span> Greeter <span style="color:#777">// Greeter is known statically</span>
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>But what if you get the class by reflection, for example by calling <code>Class.forName</code>?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Class</span> clazz = <span style="color:#0a8;font-weight:bold">Class</span>.forName(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Greeter</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trying to use the reference to the class with the <code>as</code> keyword would fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">greeter = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Groovy!</span><span style="color:#710">'</span></span> } <span style="color:#080;font-weight:bold">as</span> clazz
<span style="color:#777">// throws:</span>
<span style="color:#777">// unable to resolve class clazz</span>
<span style="color:#777">// @ line 9, column 40.</span>
<span style="color:#777">//   greeter = { println 'Hello, Groovy!' } as clazz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is failing because the <code>as</code> keyword only works with class literals. Instead, you need to call the <code>asType</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">greeter = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, Groovy!</span><span style="color:#710">'</span></span> }.asType(clazz)
greeter.greet()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_可省略的"><a class="link" href="#_可省略的">6.4. 可省略的</a></h3>
<div class="sect3">
<h4 id="_可选的括号"><a class="link" href="#_可选的括号">6.4.1. 可选的括号</a></h4>
<div class="paragraph">
<p>如果至少有一个参数并且没有歧义，方法调用可以省略括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello World</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> maximum = <span style="color:#0a8;font-weight:bold">Math</span>.max <span style="color:#00D">5</span>, <span style="color:#00D">10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>无参数的方法调用或不明确的方法调用需要括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println()
println(<span style="color:#0a8;font-weight:bold">Math</span>.max(<span style="color:#00D">5</span>, <span style="color:#00D">10</span>))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可选的分号"><a class="link" href="#_可选的分号">6.4.2. 可选的分号</a></h4>
<div class="paragraph">
<p>在 Groovy 中，如果该行仅包含单个语句，则可以省略该行末尾的分号。</p>
</div>
<div class="paragraph">
<p>这意味着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以更惯用地写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一行中的多个语句需要分号来分隔它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">boolean</span> a = <span style="color:#069">true</span>; <span style="color:#080;font-weight:bold">assert</span> a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可选的return关键字"><a class="link" href="#_可选的return关键字">6.4.3. 可选的return关键字</a></h4>
<div class="paragraph">
<p>在 Groovy 中，返回方法或闭包主体中计算的最后一个表达式。这意味着 return 关键字是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> add(<span style="color:#339;font-weight:bold">int</span> a, <span style="color:#339;font-weight:bold">int</span> b) {
    <span style="color:#080;font-weight:bold">return</span> a+b
}
<span style="color:#080;font-weight:bold">assert</span> add(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>) == <span style="color:#00D">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以缩短为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> add(<span style="color:#339;font-weight:bold">int</span> a, <span style="color:#339;font-weight:bold">int</span> b) {
    a+b
}
<span style="color:#080;font-weight:bold">assert</span> add(<span style="color:#00D">1</span>, <span style="color:#00D">2</span>) == <span style="color:#00D">3</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可选的public关键字"><a class="link" href="#_可选的public关键字">6.4.4. 可选的public关键字</a></h4>
<div class="paragraph">
<p>默认情况下，Groovy 类和方法是 public 。因此这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Server</span> {
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a server</span><span style="color:#710">&quot;</span></span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此类相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Server</span> {
    <span style="color:#0a8;font-weight:bold">String</span> toString() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">a server</span><span style="color:#710">&quot;</span></span> }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-groovy-truth"><a class="link" href="#the-groovy-truth">6.5. 表达式的真假</a></h3>
<div class="paragraph">
<p>Groovy 通过应用以下规则来确定表达式是真还是假。</p>
</div>
<div class="sect3">
<h4 id="_boolean_expressions"><a class="link" href="#_boolean_expressions">6.5.1. Boolean expressions</a></h4>
<div class="paragraph">
<p>如果相应的布尔值为 true ，则为 True。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#069">true</span>
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#069">false</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_集合和数组"><a class="link" href="#_集合和数组">6.5.2. 集合和数组</a></h4>
<div class="paragraph">
<p>非空集合和数组都是true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>]
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#339;font-weight:bold">[]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matchers"><a class="link" href="#_matchers">6.5.3. Matchers</a></h4>
<div class="paragraph">
<p>如果匹配器至少有一个匹配项，则为 true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">a</span><span style="color:#404">/</span></span>)
<span style="color:#080;font-weight:bold">assert</span> !(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span> =~ <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">b</span><span style="color:#404">/</span></span>)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_迭代器和枚举"><a class="link" href="#_迭代器和枚举">6.5.4. 迭代器和枚举</a></h4>
<div class="paragraph">
<p>具有下一个元素的迭代器和枚举被强制为 true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> [<span style="color:#00D">0</span>].iterator()
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#339;font-weight:bold">[]</span>.iterator()
<span style="color:#0a8;font-weight:bold">Vector</span> v = [<span style="color:#00D">0</span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">Vector</span>
<span style="color:#0a8;font-weight:bold">Enumeration</span> enumeration = v.elements()
<span style="color:#080;font-weight:bold">assert</span> enumeration
enumeration.nextElement()
<span style="color:#080;font-weight:bold">assert</span> !enumeration</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_maps_2"><a class="link" href="#_maps_2">6.5.5. Maps</a></h4>
<div class="paragraph">
<p>非空map被评估为 true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">one</span><span style="color:#710">'</span></span> : <span style="color:#00D">1</span>]
<span style="color:#080;font-weight:bold">assert</span> ![:]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_strings"><a class="link" href="#_strings">6.5.6. Strings</a></h4>
<div class="paragraph">
<p>非空字符串、GString 和 CharSequences 被强制为 true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> !<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> nonEmpty = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>nonEmpty</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">def</span> empty = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">assert</span> !<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>empty</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_numbers"><a class="link" href="#_numbers">6.5.7. Numbers</a></h4>
<div class="paragraph">
<p>非零数为真。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">assert</span> <span style="color:#60E">3.5</span>
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#00D">0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_object_references"><a class="link" href="#_object_references">6.5.8. Object References</a></h4>
<div class="paragraph">
<p>非空对象引用被强制为 true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Object</span>()
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#069">null</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_asboolean_方法自定义真假"><a class="link" href="#_使用_asboolean_方法自定义真假">6.5.9. 使用 asBoolean() 方法自定义真假</a></h4>
<div class="paragraph">
<p>为了自定义是否将对象评估为 true 还是 false, 可以实现 asBoolean() 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Color</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name

    <span style="color:#339;font-weight:bold">boolean</span> asBoolean(){
        name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span> ? <span style="color:#069">true</span> : <span style="color:#069">false</span> 
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy 将调用此方法将您的对象强制为布尔值，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Color</span>(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">green</span><span style="color:#710">'</span></span>)
<span style="color:#080;font-weight:bold">assert</span> !<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Color</span>(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">red</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型_2"><a class="link" href="#_类型_2">6.6. 类型</a></h3>
<div class="sect3">
<h4 id="_可选类型"><a class="link" href="#_可选类型">6.6.1. 可选类型</a></h4>
<div class="paragraph">
<p>可选类型是指即使您没有在变量上设置显式类型，程序也可以运行。作为一种动态语言，Groovy 自然地实现了该功能，例如当您声明变量时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> aString = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>                      // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> aString.toUpperCase()                // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>foo 使用显式类型声明， String</p>
</li>
<li>
<p>我们可以在 String 上调用 toUpperCase 方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Groovy 会让你这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> aString = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>                         // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> aString.toUpperCase()                // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>foo 使用 def 声明</p>
</li>
<li>
<p>我们仍然可以调用 toUpperCase 方法，因为 aString 的类型是在运行时解析的</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>所以在这里使用显式类型并不重要。当您将此功能与<a href="#static-type-checking">静态类型检查</a>结合起来时，它特别有趣，因为类型检查器执行类型推断。</p>
</div>
<div class="paragraph">
<p>同样，Groovy 并不强制要求在方法中声明参数的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> concat(<span style="color:#0a8;font-weight:bold">String</span> a, <span style="color:#0a8;font-weight:bold">String</span> b) {
    a+b
}
<span style="color:#080;font-weight:bold">assert</span> concat(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foobar</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 def 作为返回类型和参数类型进行重写，以便利用鸭子类型，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">concat</span>(<span style="color:#080;font-weight:bold">def</span> a, <span style="color:#080;font-weight:bold">def</span> b) {                              // <b class="conum">(1)</b>
    a+b
}
<span style="color:#080;font-weight:bold">assert</span> concat(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foobar</span><span style="color:#710">'</span></span>                  // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> concat(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>) == <span style="color:#00D">3</span>                                 // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>返回类型和参数类型都使用 def</p>
</li>
<li>
<p>它使得可以使用 String 的方法</p>
</li>
<li>
<p>但也可以使用 int ，因为定义了 plus 方法</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
建议在适用于任何类型的方法上使用 def 关键字，但从技术上讲，我们可以使用 Object 代替，结果是相同的：<strong>在 Groovy 中， def 严格等同于使用 Object</strong> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后, 可以从返回类型和描述符中完全删除该类型。但是，如果您想从返回类型中删除它，则需要为该方法添加显式修饰符，以便编译器可以区分方法声明和方法调用，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#088;font-weight:bold">private</span> concat(a,b) {                                   // <b class="conum">(1)</b>
    a+b
}
<span style="color:#080;font-weight:bold">assert</span> concat(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foobar</span><span style="color:#710">'</span></span>                  // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> concat(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>) == <span style="color:#00D">3</span>                                 // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>如果我们想省略返回类型，则必须设置显式修饰符。</p>
</li>
<li>
<p>仍然可以使用 String 的方法</p>
</li>
<li>
<p>还有 int</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
在公共 API 的方法参数或方法返回类型中，省略类型通常被认为是一种不好的做法。虽然在局部变量中使用 def 并不是真正的问题，因为变量的可见性仅限于方法本身，而在方法参数上设置时， def 将转换为 &lt; b2&gt; 出现在方法签名中，使得用户很难知道参数的预期类型。这意味着您应该将此限制于明确依赖鸭子类型的情况。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="static-type-checking"><a class="link" href="#static-type-checking">6.6.2. 静态类型检查</a></h4>
<div class="paragraph">
<p>默认情况下，Groovy 在编译时执行最少的类型检查. 由于它主要是一种动态语言，因此在编译期执行常规编译器都会执行的检查是不可能的. 通过运行时元编程添加的方法可能会改变类或对象的运行时行为。让我们在下面的例子中说明原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {                                                          // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> firstName
    <span style="color:#0a8;font-weight:bold">String</span> lastName
}
<span style="color:#080;font-weight:bold">def</span> p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">firstName</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Raymond</span><span style="color:#710">'</span></span>, <span style="color:#606">lastName</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Devos</span><span style="color:#710">'</span></span>)             // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> p.formattedName == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Raymond Devos</span><span style="color:#710">'</span></span>                               // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Person 类仅定义两个属性， firstName 和 lastName</p>
</li>
<li>
<p>我们可以创建一个 Person 的实例</p>
</li>
<li>
<p>并调用名为 formattedName 的方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在动态语言中，像上面的示例这样的代码不抛出任何错误是很常见的。怎么会这样？在 Java 中，这通常会在编译时失败。然而，在 Groovy 中，它不会在编译时失败，也不会在运行时失败。事实上，要使其在运行时工作，一种可能性是依赖运行时元编程。因此，只需在 Person 类的声明之后添加这一行就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Person.metaClass.getFormattedName = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>delegate</span><span style="color:#D20">.firstName </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>delegate</span><span style="color:#D20">.lastName</span><span style="color:#710">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着一般来说，在 Groovy 中，您不能对对象的声明类型之外的类型做出任何假设，即使您知道它，您也无法在编译时确定将调用哪个方法。从编写 DSL 到测试，它引起了很多兴趣，这将在本手册的其他部分中讨论。</p>
</div>
<div class="paragraph">
<p>然而，如果您的程序不依赖于动态功能，并且您来自静态世界（特别是来自 Java 思维方式），那么在编译时没有捕获此类“错误”可能会令人惊讶。正如我们在前面的示例中所看到的，编译器无法确定这是一个错误。为了让它意识到这一点，您必须显式指示编译器您正在切换到类型检查模式。这可以通过使用 @groovy.transform.TypeChecked 注释类或方法来完成。</p>
</div>
<div class="paragraph">
<p>当类型检查被激活时，编译器会执行更多的工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型推断被激活，这意味着即使您在局部变量上使用 def ，类型检查器也将能够从赋值中推断变量的类型</p>
</li>
<li>
<p>方法调用在编译时解析，这意味着如果未在类上声明方法，编译器将抛出错误</p>
</li>
<li>
<p>一般来说，你习惯在静态语言中查找的所有编译时错误都会出现：找不到方法、找不到属性、方法调用的类型不兼容、数字精度错误……</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在本节中，我们将描述类型检查器在各种情况下的行为，并描述 @TypeChecked 的限制。</p>
</div>
<div class="sect4">
<h5 id="_typechecked_注释"><a class="link" href="#_typechecked_注释">6.6.2.1. @TypeChecked 注释</a></h5>
<div class="sect5">
<h6 id="_在编译时激活类型检查"><a class="link" href="#_在编译时激活类型检查">在编译时激活类型检查</a></h6>
<div class="paragraph">
<p>groovy.transform.TypeChecked 注释启用类型检查。它可以放在一个类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Calculator</span> {
    <span style="color:#339;font-weight:bold">int</span> sum(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在一个方法上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Calculator</span> {
    <span style="color:#007">@groovy</span>.transform.TypeChecked
    <span style="color:#339;font-weight:bold">int</span> sum(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，注释类的所有方法、属性、字段、内部类等都将进行类型检查，而在第二种情况下，只有方法和它包含的潜在闭包或匿名内部类将进行类型检查。</p>
</div>
</div>
<div class="sect5">
<h6 id="_跳过类型检查"><a class="link" href="#_跳过类型检查">跳过类型检查</a></h6>
<div class="paragraph">
<p>类型检查的范围可以受到限制。例如，如果一个类经过类型检查，您可以通过使用 @TypeChecked(TypeCheckingMode.SKIP) 注释来指示类型检查器跳过该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.TypeChecked</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.TypeCheckingMode</span>

<span style="color:#007">@TypeChecked</span>                                        // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">GreetingService</span> {
    <span style="color:#0a8;font-weight:bold">String</span> greeting() {                             // <b class="conum">(2)</b>
        doGreet()
    }

    <span style="color:#007">@TypeChecked</span>(TypeCheckingMode.SKIP)             // <b class="conum">(3)</b>
    <span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> doGreet() {
        <span style="color:#080;font-weight:bold">def</span> b = <span style="color:#080;font-weight:bold">new</span> SentenceBuilder()
        b.Hello.my.name.is.John                     // <b class="conum">(4)</b>
        b
    }
}
<span style="color:#080;font-weight:bold">def</span> s = <span style="color:#080;font-weight:bold">new</span> GreetingService()
<span style="color:#080;font-weight:bold">assert</span> s.greeting() == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello my name is John</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>GreetingService 类被标记为类型检查</p>
</li>
<li>
<p>所以 greeting 方法会自动进行类型检查</p>
</li>
<li>
<p>但 doGreet 被标记为 SKIP</p>
</li>
<li>
<p>类型检查器不会抱怨这里缺少属性</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在前面的示例中， SentenceBuilder 依赖于动态代码。没有真正的 Hello 方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法标记有 TypeCheckingMode.SKIP ，因此会跳过此方法的类型检查，因此即使类的其余部分经过类型检查，代码也会编译。</p>
</div>
<div class="paragraph">
<p>以下部分描述了 Groovy 中类型检查的语义。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_类型检查赋值"><a class="link" href="#_类型检查赋值">6.6.2.2. 类型检查赋值</a></h5>
<div class="paragraph">
<p>当且仅当满足以下条件时， A 类型的对象 o 才可以分配给 T 类型的变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code> equals <code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Date</span> now = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 是 String 、 boolean 、 Boolean 或 Class 之一</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> s = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>() <span style="color:#777">// implicit call to toString</span>
<span style="color:#0a8;font-weight:bold">Boolean</span> boxed = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">some string</span><span style="color:#710">'</span></span>       <span style="color:#777">// Groovy truth</span>
<span style="color:#339;font-weight:bold">boolean</span> prim = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">some string</span><span style="color:#710">'</span></span>        <span style="color:#777">// Groovy truth</span>
<span style="color:#0a8;font-weight:bold">Class</span> clazz = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">java.lang.String</span><span style="color:#710">'</span></span>    <span style="color:#777">// class coercion</span></code></pre>
</div>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>*或 o 为 null 并且 T 是引用类型</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> s = <span style="color:#069">null</span>         <span style="color:#777">// passes</span>
<span style="color:#339;font-weight:bold">int</span> i = <span style="color:#069">null</span>            <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> i = <span style="color:#080;font-weight:bold">new</span> <span style="color:#339;font-weight:bold">int</span>[<span style="color:#00D">4</span>]        <span style="color:#777">// passes</span>
<span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> i = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">String</span>[<span style="color:#00D">4</span>]     <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 是一个数组， A 是一个collection或stream，并且 A 的元素类型可分配给 T 的元素类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> i = [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>]               <span style="color:#777">// passes</span>
<span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> i = [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>, <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>()]     <span style="color:#777">// fails</span>
<span style="color:#0a8;font-weight:bold">Set</span> set = [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>]
<span style="color:#0a8;font-weight:bold">Number</span><span style="color:#339;font-weight:bold">[]</span> na = set               <span style="color:#777">// passes</span>
<span style="color:#080;font-weight:bold">def</span> stream = <span style="color:#0a8;font-weight:bold">Arrays</span>.stream(<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>)
<span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> i = stream                <span style="color:#777">// passes</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或者 T 是 A 的父类</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">AbstractList</span> list = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>()     <span style="color:#777">// passes</span>
<span style="color:#0a8;font-weight:bold">LinkedList</span> list = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>()       <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或者 T 是 A 实现的接口</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">List</span> list = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>()             <span style="color:#777">// passes</span>
<span style="color:#0a8;font-weight:bold">RandomAccess</span> list = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">LinkedList</span>()    <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 或 A 是原始类型，它们的装箱类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> i = <span style="color:#00D">0</span>
<span style="color:#0a8;font-weight:bold">Integer</span> bi = <span style="color:#00D">1</span>
<span style="color:#339;font-weight:bold">int</span> x = <span style="color:#0a8;font-weight:bold">Integer</span>.valueOf(<span style="color:#00D">123</span>)
<span style="color:#339;font-weight:bold">double</span> d = <span style="color:#0a8;font-weight:bold">Float</span>.valueOf(<span style="color:#60E">5f</span>)</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Runnable</span> r = { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello</span><span style="color:#710">'</span></span> }
<span style="color:#339;font-weight:bold">interface</span> SAMType {
    <span style="color:#339;font-weight:bold">int</span> doSomething()
}
SAMType sam = { <span style="color:#00D">123</span> }
<span style="color:#080;font-weight:bold">assert</span> sam.doSomething() == <span style="color:#00D">123</span>
<span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AbstractSAM</span> {
    <span style="color:#339;font-weight:bold">int</span> calc() { <span style="color:#00D">2</span>* value() }
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">int</span> value()
}
AbstractSAM c = { <span style="color:#00D">123</span> }
<span style="color:#080;font-weight:bold">assert</span> c.calc() == <span style="color:#00D">246</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 和 A 派生自 java.lang.Number 并符合下表</p>
</li>
</ul>
</div>
<table id="number-assignment" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Number types (java.lang.XXX)</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">T</th>
<th class="tableblock halign-left valign-top">A</th>
<th class="tableblock halign-left valign-top">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any but BigDecimal or BigInteger</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Double</span> d1 = <span style="color:#60E">4d</span>
<span style="color:#0a8;font-weight:bold">Double</span> d2 = <span style="color:#60E">4f</span>
<span style="color:#0a8;font-weight:bold">Double</span> d3 = <span style="color:#00D">4l</span>
<span style="color:#0a8;font-weight:bold">Double</span> d4 = <span style="color:#00D">4</span>i
<span style="color:#0a8;font-weight:bold">Double</span> d5 = (<span style="color:#339;font-weight:bold">short</span>) <span style="color:#00D">4</span>
<span style="color:#0a8;font-weight:bold">Double</span> d6 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger or Double</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Float</span> f1 = <span style="color:#60E">4f</span>
<span style="color:#0a8;font-weight:bold">Float</span> f2 = <span style="color:#00D">4l</span>
<span style="color:#0a8;font-weight:bold">Float</span> f3 = <span style="color:#00D">4</span>i
<span style="color:#0a8;font-weight:bold">Float</span> f4 = (<span style="color:#339;font-weight:bold">short</span>) <span style="color:#00D">4</span>
<span style="color:#0a8;font-weight:bold">Float</span> f5 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double or Float</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Long</span> l1 = <span style="color:#00D">4l</span>
<span style="color:#0a8;font-weight:bold">Long</span> l2 = <span style="color:#00D">4</span>i
<span style="color:#0a8;font-weight:bold">Long</span> l3 = (<span style="color:#339;font-weight:bold">short</span>) <span style="color:#00D">4</span>
<span style="color:#0a8;font-weight:bold">Long</span> l4 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double, Float or Long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Integer</span> i1 = <span style="color:#00D">4</span>i
<span style="color:#0a8;font-weight:bold">Integer</span> i2 = (<span style="color:#339;font-weight:bold">short</span>) <span style="color:#00D">4</span>
<span style="color:#0a8;font-weight:bold">Integer</span> i3 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double, Float, Long or Integer</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Short</span> s1 = (<span style="color:#339;font-weight:bold">short</span>) <span style="color:#00D">4</span>
<span style="color:#0a8;font-weight:bold">Short</span> s2 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">Byte</span> b1 = (<span style="color:#339;font-weight:bold">byte</span>) <span style="color:#00D">4</span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_list_和_map_构造器"><a class="link" href="#_list_和_map_构造器">6.6.2.3. List 和 map 构造器</a></h5>
<div class="paragraph">
<p>可以将List字面量或Map字面量 A 赋值给 T 类型的变量，前提是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A 是一个List字面量， T 有一个构造函数，其参数与List字面量中元素的类型匹配</p>
</li>
<li>
<p>A 是一个Map字面量， T 有一个无参数构造函数, 并且对于 <code>Map</code> 中的每个key, 都有一个与之对应的属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TupleConstructor
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> firstName
    <span style="color:#0a8;font-weight:bold">String</span> lastName
}
Person classic = <span style="color:#080;font-weight:bold">new</span> Person(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ada</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lovelace</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 “list constructor” ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Person list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ada</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lovelace</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者 "map constructor":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Person map = [<span style="color:#606">firstName</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ada</span><span style="color:#710">'</span></span>, <span style="color:#606">lastName</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lovelace</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用 map 构造函数，则会对map的键进行额外检查，以检查是否定义了同名的属性。例如，以下内容将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TupleConstructor
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> firstName
    <span style="color:#0a8;font-weight:bold">String</span> lastName
}
Person map = [<span style="color:#606">firstName</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Ada</span><span style="color:#710">'</span></span>, <span style="color:#606">lastName</span>:<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Lovelace</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">24</span>]     // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>类型检查器将在编译时抛出错误 No such property: age for class: Person</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_方法检查"><a class="link" href="#_方法检查">6.6.2.4. 方法检查</a></h5>
<div class="paragraph">
<p>在类型检查模式下，方法在编译时解析。解析通过名称和参数进行。返回类型与方法选择无关。入参和出参按照以下规则进行匹配：</p>
</div>
<div class="paragraph">
<p>当且仅当满足以下条件时， A 类型的实参 o 才可用于 T 类型的形参：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code> equals <code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> sum(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y) {
    x+y
}
<span style="color:#080;font-weight:bold">assert</span> sum(<span style="color:#00D">3</span>,<span style="color:#00D">4</span>) == <span style="color:#00D">7</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 是 String ， A 是 GString</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">String</span> str) {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>str</span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> format(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span><span style="color:#00D">3</span>+<span style="color:#00D">4</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: 7</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 o 为 null 并且 T 是引用类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#339;font-weight:bold">int</span> value) {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>value</span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> format(<span style="color:#00D">7</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: 7</span><span style="color:#710">&quot;</span></span>
format(<span style="color:#069">null</span>)           <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 是一个数组， A 是一个数组，并且 A 的元素类型可分配给 T 的元素类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span> values) {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>values.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20"> </span><span style="color:#710">'</span></span>)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> format([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#0a8;font-weight:bold">String</span><span style="color:#339;font-weight:bold">[]</span>) == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: a b</span><span style="color:#710">&quot;</span></span>
format([<span style="color:#00D">1</span>,<span style="color:#00D">2</span>] <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span>)              <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或者 T 是 A 的父类</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">AbstractList</span> list) {
    list.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">,</span><span style="color:#710">'</span></span>)
}
format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>())              <span style="color:#777">// passes</span>
<span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">LinkedList</span> list) {
    list.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">,</span><span style="color:#710">'</span></span>)
}
format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>())              <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或者 T 是 A 实现的接口</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">List</span> list) {
    list.join(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">,</span><span style="color:#710">'</span></span>)
}
format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>())                  <span style="color:#777">// passes</span>
<span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">RandomAccess</span> list) {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>
}
format(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">LinkedList</span>())                 <span style="color:#777">// fails</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 或 A 是原始类型，它们的包装类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> sum(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#0a8;font-weight:bold">Integer</span> y) {
    x+y
}
<span style="color:#080;font-weight:bold">assert</span> sum(<span style="color:#00D">3</span>, <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>(<span style="color:#00D">4</span>)) == <span style="color:#00D">7</span>
<span style="color:#080;font-weight:bold">assert</span> sum(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>(<span style="color:#00D">3</span>), <span style="color:#00D">4</span>) == <span style="color:#00D">7</span>
<span style="color:#080;font-weight:bold">assert</span> sum(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>(<span style="color:#00D">3</span>), <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>(<span style="color:#00D">4</span>)) == <span style="color:#00D">7</span>
<span style="color:#080;font-weight:bold">assert</span> sum(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Integer</span>(<span style="color:#00D">3</span>), <span style="color:#00D">4</span>) == <span style="color:#00D">7</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 扩展 groovy.lang.Closure 且 A 是 SAM 类型（single abstract method type）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> SAMType {
    <span style="color:#339;font-weight:bold">int</span> doSomething()
}
<span style="color:#339;font-weight:bold">int</span> twice(SAMType sam) { <span style="color:#00D">2</span>*sam.doSomething() }
<span style="color:#080;font-weight:bold">assert</span> twice { <span style="color:#00D">123</span> } == <span style="color:#00D">246</span>
<span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AbstractSAM</span> {
    <span style="color:#339;font-weight:bold">int</span> calc() { <span style="color:#00D">2</span>* value() }
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">int</span> value()
}
<span style="color:#339;font-weight:bold">int</span> eightTimes(AbstractSAM sam) { <span style="color:#00D">4</span>*sam.calc() }
<span style="color:#080;font-weight:bold">assert</span> eightTimes { <span style="color:#00D">123</span> } == <span style="color:#00D">984</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>或 T 和 A 派生自 java.lang.Number 并符合与<a href="#number-assignment">数字赋值</a>相同的规则</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在编译时未找到具有适当名称和参数的方法，则会引发错误。以下示例说明了与“正常”Groovy 的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyService</span> {
    <span style="color:#339;font-weight:bold">void</span> doSomething() {
        printLine <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Do something</span><span style="color:#710">'</span></span>            // <b class="conum">(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>printLine 是一个错误，但由于我们处于动态模式，因此在编译时不会捕获该错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面的示例Groovy能够正常编译。但是，如果您尝试创建 MyService 的实例并调用 doSomething 方法，那么它将在运行时失败，因为 printLine 不存在。当然，我们已经展示了 Groovy 如何使其成为完全有效的调用，例如通过捕获 MethodMissingException 或实现自定义元类，但如果您知道自己不属于这种情况， 可以使用 @TypeChecked 来开启检查</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MyService</span> {
    <span style="color:#339;font-weight:bold">void</span> doSomething() {
        printLine <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Do something</span><span style="color:#710">'</span></span>            // <b class="conum">(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>printLine 这次是编译时错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>只需添加 @TypeChecked 将触发编译时方法解析。类型检查器将尝试在 MyService 类上查找接受 String 的方法 printLine ，但找不到。编译将失败并显示以下消息：</p>
</div>
<div class="paragraph">
<p><code>Cannot find matching method MyService#printLine(java.lang.String)</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
了解类型检查器背后的逻辑很重要：它是编译时检查，因此根据定义，类型检查器不知道您所做的任何类型的运行时元编程。这意味着如果您激活类型检查，任何在关闭类型检查时正常编译的代码都可能编译失败。如果您想到鸭子类型，则尤其如此：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Duck</span> {
    <span style="color:#339;font-weight:bold">void</span> quack() {              // <b class="conum">(1)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Quack!</span><span style="color:#710">'</span></span>
    }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">QuackingBird</span> {
    <span style="color:#339;font-weight:bold">void</span> quack() {              // <b class="conum">(2)</b>
        println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Quack!</span><span style="color:#710">'</span></span>
    }
}
<span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> accept(quacker) {
    quacker.quack()             // <b class="conum">(3)</b>
}
accept(<span style="color:#080;font-weight:bold">new</span> Duck())              // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们定义一个 Duck 类，它定义一个 quack 方法</p>
</li>
<li>
<p>我们定义了另一个 QuackingBird 类，它也定义了 quack 方法</p>
</li>
<li>
<p>quacker 是松散类型的，由于该方法是 @TypeChecked ，我们将获得编译时错误</p>
</li>
<li>
<p>但在没有类型检查的Groovy中, 这会通过</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>有可能的解决方法，例如引入接口，但基本上，通过激活类型检查，您可以获得类型安全，但会失去该语言的一些功能。幸运的是 Groovy 引入一些功能，例如流类型，以缩小类型检查和非类型检查 Groovy 之间的差距。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="type-inference"><a class="link" href="#type-inference">6.6.2.5. 类型推断</a></h5>
<div class="sect5">
<h6 id="_原则"><a class="link" href="#_原则">原则</a></h6>
<div class="paragraph">
<p>当代码用 @TypeChecked 注释时，编译器会执行类型推断。它不仅仅依赖于静态类型，还使用各种技术来推断变量的类型、返回类型、字面量……，以便即使您激活类型检查器，代码也尽可能保持干净。</p>
</div>
<div class="paragraph">
<p>最简单的例子是推断变量的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> message = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Welcome to Groovy!</span><span style="color:#710">'</span></span>              // <b class="conum">(1)</b>
println message.toUpperCase()                   // <b class="conum">(2)</b>
println message.upper() <span style="color:#777">// compile time error   </span><b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 def 关键字声明变量</p>
</li>
<li>
<p>类型检查器允许调用 toUpperCase</p>
</li>
<li>
<p>调用 upper 将在编译时失败</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对 toUpperCase 的调用有效的原因是 message 的类型被推断为 String 。</p>
</div>
</div>
<div class="sect5">
<h6 id="_类型推断中的变量和字段"><a class="link" href="#_类型推断中的变量和字段">类型推断中的变量和字段</a></h6>
<div class="paragraph">
<p>值得注意的是，虽然编译器对局部变量执行类型推断，但它不会对字段执行任何类型的推断，总是回退到字段的声明类型。为了说明这一点，让我们看一下这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SomeClass</span> {
    <span style="color:#080;font-weight:bold">def</span> someUntypedField                                                                // <b class="conum">(1)</b>
    <span style="color:#0a8;font-weight:bold">String</span> someTypedField                                                               // <b class="conum">(2)</b>

    <span style="color:#339;font-weight:bold">void</span> someMethod() {
        someUntypedField = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">123</span><span style="color:#710">'</span></span>                                                        // <b class="conum">(3)</b>
        someUntypedField = someUntypedField.toUpperCase()  <span style="color:#777">// compile-time error        </span>// <b class="conum">(4)</b>
    }

    <span style="color:#339;font-weight:bold">void</span> someSafeMethod() {
        someTypedField = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">123</span><span style="color:#710">'</span></span>                                                          // <b class="conum">(5)</b>
        someTypedField = someTypedField.toUpperCase()                                   // <b class="conum">(6)</b>
    }

    <span style="color:#339;font-weight:bold">void</span> someMethodUsingLocalVariable() {
        <span style="color:#080;font-weight:bold">def</span> localVariable = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">123</span><span style="color:#710">'</span></span>                                                       // <b class="conum">(7)</b>
        someUntypedField = localVariable.toUpperCase()                                  // <b class="conum">(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>someUntypedField 使用 def 作为声明类型</p>
</li>
<li>
<p>someTypedField 使用 String 作为声明类型</p>
</li>
<li>
<p>我们可以将任何内容分配给 someUntypedField</p>
</li>
<li>
<p>但调用 toUpperCase 在编译时失败，因为该字段没有类型</p>
</li>
<li>
<p>我们可以将 String 分配给 String 类型的字段</p>
</li>
<li>
<p>这次允许 toUpperCase</p>
</li>
<li>
<p>如果我们将 String 分配给局部变量</p>
</li>
<li>
<p>允许在局部变量上调用 toUpperCase(因为会类型推断)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为什么会有这样的差异？原因是线程安全。在编译时，我们无法对字段的类型做出任何保证。任何线程都可以随时访问任何字段，并且在方法中为字段分配某种类型的变量的那一刻和之后使用该行的时间之间，另一个线程可能已经更改了该字段的内容。局部变量的情况并非如此：我们知道它们是否“转义”，因此我们可以确保变量的类型随着时间的推移保持不变（或不变）。请注意，即使字段是最终字段，JVM 也不对其做出保证，因此无论字段是否为最终字段，类型检查器的行为都不会有所不同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
这就是我们建议使用类型化字段的原因之一。虽然由于类型推断，对局部变量使用 def 是完全没问题的，但字段的情况并非如此，字段也属于类的公共 API，因此类型很重要。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_集合字面量类型推断"><a class="link" href="#_集合字面量类型推断">集合字面量类型推断</a></h6>
<div class="paragraph">
<p>Groovy 提供了各种类型字面量的语法。 Groovy 中有集合字面量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>lists, using the <code>[]</code> literal</p>
</li>
<li>
<p>maps, using the <code>[:]</code> literal</p>
</li>
<li>
<p>range，使用 from..to （包含）、 from..&lt;to （右排除）、 from&lt;..to （左排除）和 from&lt;..&lt;to （完全排除）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>字面量的推断类型取决于字面量的元素，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Literal</th>
<th class="tableblock halign-left valign-top">Inferred type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list = <span style="color:#339;font-weight:bold">[]</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.List</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.List&lt;String&gt;</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>foo<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>bar<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.List&lt;GString&gt;</code> be careful, a <code>GString</code> is <strong>not</strong> a <code>String</code>!</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> map = [:]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.LinkedHashMap</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> map1 = [<span style="color:#606">someKey</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">someValue</span><span style="color:#710">'</span></span>]
<span style="color:#080;font-weight:bold">def</span> map2 = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">someKey</span><span style="color:#710">'</span></span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">someValue</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.LinkedHashMap&lt;String,String&gt;</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> map = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>someKey<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">someValue</span><span style="color:#710">'</span></span>]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>java.util.LinkedHashMap&lt;GString,String&gt;</code> be careful, the key is a <code>GString</code>!</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> intRange = (<span style="color:#00D">0</span>..<span style="color:#00D">10</span>)</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>groovy.lang.IntRange</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> charRange = (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>..<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">z</span><span style="color:#710">'</span></span>)</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>groovy.lang.Range&lt;String&gt;</code> : uses the type of the bounds to infer the component type of the range</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>正如您所看到的，除了 IntRange 明显的例外，推断类型使用泛型来描述集合的内容。如果集合包含不同类型的元素，类型检查器仍然执行元素的类型推断，但使用<a href="#section-lub">最小上限</a>的概念。</p>
</div>
</div>
<div class="sect5">
<h6 id="section-lub"><a class="link" href="#section-lub">最小上限</a></h6>
<div class="paragraph">
<p>在 Groovy 中， A 和 B 两种类型的最小上限被定义为以下类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A 和 B 的公共超类</p>
</li>
<li>
<p>A 和 B 实现的共同接口</p>
</li>
<li>
<p>如果 A 或 B 是原始类型并且 A 不等于 B ，则 A 和 B 是其包装类型的最小上限</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 A 和 B 只有一 (1) 个公共接口，并且它们的公共超类是 Object ，那么两者的 LUB 就是公共接口。</p>
</div>
<div class="paragraph">
<p>最小上限表示可以分配 A 和 B 的最小类型。例如，如果 A 和 B 都是 String ，那么两者的 LUB（最小上限）也是 String 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Top</span> {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bottom1</span> <span style="color:#088;font-weight:bold">extends</span> Top {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bottom2</span> <span style="color:#088;font-weight:bold">extends</span> Top {}

<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(<span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#0a8;font-weight:bold">String</span>) == <span style="color:#0a8;font-weight:bold">String</span>                    // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(<span style="color:#0a8;font-weight:bold">ArrayList</span>, <span style="color:#0a8;font-weight:bold">LinkedList</span>) == <span style="color:#0a8;font-weight:bold">AbstractList</span>       // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(<span style="color:#0a8;font-weight:bold">ArrayList</span>, <span style="color:#0a8;font-weight:bold">List</span>) == <span style="color:#0a8;font-weight:bold">List</span>                     // <b class="conum">(3)</b>
<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(<span style="color:#0a8;font-weight:bold">List</span>, <span style="color:#0a8;font-weight:bold">List</span>) == <span style="color:#0a8;font-weight:bold">List</span>                          // <b class="conum">(4)</b>
<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(Bottom1, Bottom2) == Top                     // <b class="conum">(5)</b>
<span style="color:#080;font-weight:bold">assert</span> leastUpperBound(<span style="color:#0a8;font-weight:bold">List</span>, <span style="color:#0a8;font-weight:bold">Serializable</span>) == <span style="color:#0a8;font-weight:bold">Object</span>                // <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>String 和 String 的LUB是 String</p>
</li>
<li>
<p>ArrayList 和 LinkedList 的 LUB 是它们共同的超类型， AbstractList</p>
</li>
<li>
<p>ArrayList 和 List 的LUB是它们唯一的公共接口， List</p>
</li>
<li>
<p>两个相同接口的LUB就是接口本身</p>
</li>
<li>
<p>Bottom1 和 Bottom2 的 LUB 是它们的超类 Top</p>
</li>
<li>
<p>两种没有共同点的类型的LUB是 Object</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在这些示例中，LUB 始终可表示为普通的、JVM 支持的类型。但 Groovy 在内部将 LUB 表示为一种可能更复杂的类型，并且您无法使用它来定义变量。为了说明这一点，让我们继续这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Foo {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Top</span> {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bottom</span> <span style="color:#088;font-weight:bold">extends</span> Top <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Serializable</span>, Foo {}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SerializableFooImpl</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Serializable</span>, Foo {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bottom 和 SerializableFooImpl 的最小上限是多少？它们没有共同的超类（除了 Object ），但它们共享 2 个接口（ Serializable 和 Foo ），因此它们的最小上限是表示两个接口（ Serializable 和 Foo ）的联合的类型。这种类型无法在源代码中定义，但 Groovy 知道它。</p>
</div>
<div class="paragraph">
<p>在集合类型推断（以及一般的泛型类型推断）的上下文中，这变得很方便，因为组件的类型被推断为最小上限。我们可以在以下示例中说明为什么这很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> Greeter { <span style="color:#339;font-weight:bold">void</span> greet() }                  // <b class="conum">(1)</b>
<span style="color:#339;font-weight:bold">interface</span> Salute { <span style="color:#339;font-weight:bold">void</span> salute() }                  // <b class="conum">(2)</b>

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">A</span> <span style="color:#088;font-weight:bold">implements</span> Greeter, Salute {                // <b class="conum">(3)</b>
    <span style="color:#339;font-weight:bold">void</span> greet() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, I'm A!</span><span style="color:#710">&quot;</span></span> }
    <span style="color:#339;font-weight:bold">void</span> salute() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Bye from A!</span><span style="color:#710">&quot;</span></span> }
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">B</span> <span style="color:#088;font-weight:bold">implements</span> Greeter, Salute {                // <b class="conum">(4)</b>
    <span style="color:#339;font-weight:bold">void</span> greet() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello, I'm B!</span><span style="color:#710">&quot;</span></span> }
    <span style="color:#339;font-weight:bold">void</span> salute() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Bye from B!</span><span style="color:#710">&quot;</span></span> }
    <span style="color:#339;font-weight:bold">void</span> exit() { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">No way!</span><span style="color:#710">'</span></span> }               // <b class="conum">(5)</b>
}
<span style="color:#080;font-weight:bold">def</span> list = [<span style="color:#080;font-weight:bold">new</span> A(), <span style="color:#080;font-weight:bold">new</span> B()]                       // <b class="conum">(6)</b>
list.each {
    <span style="color:#950">it</span>.greet()                                      // <b class="conum">(7)</b>
    <span style="color:#950">it</span>.salute()                                     // <b class="conum">(8)</b>
    <span style="color:#950">it</span>.exit()                                       // <b class="conum">(9)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Greeter 接口定义了一个方法， greet</p>
</li>
<li>
<p>Salute 接口定义了一个方法， salute</p>
</li>
<li>
<p>类 A 实现了 Greeter 和 Salute</p>
</li>
<li>
<p>与 B 相同</p>
</li>
<li>
<p>但 B 定义了一个额外的 exit 方法</p>
</li>
<li>
<p>list 的类型被推断为“ A 和 <code>B</code> 的 LUB 列表”</p>
</li>
<li>
<p>因此可以通过 Greeter 接口调用 A 和 B 上定义的 greet</p>
</li>
<li>
<p>并且可以通过 Salute 接口调用 A 和 B 上定义的 salute</p>
</li>
<li>
<p>然而调用 exit 是一个编译时错误，因为它不属于 A 和 B 的LUB（仅在 B 中定义） ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>错误消息将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method Greeter or Salute#exit()</pre>
</div>
</div>
<div class="paragraph">
<p>这表明 exit 方法既没有定义在 Greeter 上，也没有定义在 Salute 上，这两个接口定义在 A 和 B 。</p>
</div>
</div>
<div class="sect5">
<h6 id="_instanceof"><a class="link" href="#_instanceof">instanceof</a></h6>
<div class="paragraph">
<p>在正常的、非类型检查的 Groovy 中，您可以编写如下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Greeter</span> {
    <span style="color:#0a8;font-weight:bold">String</span> greeting() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello</span><span style="color:#710">'</span></span> }
}

<span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#080;font-weight:bold">def</span> o) {
    <span style="color:#080;font-weight:bold">if</span> (o <span style="color:#080;font-weight:bold">instanceof</span> Greeter) {     // <b class="conum">(1)</b>
        println o.greeting()        // <b class="conum">(2)</b>
    }
}

doSomething(<span style="color:#080;font-weight:bold">new</span> Greeter())</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用 instanceof 来保护方法调用</p>
</li>
<li>
<p>调用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该方法调用之所以有效，是因为动态调度（该方法是在运行时选择的）。 Java 中的等效代码需要在调用 greeting 方法之前将 o 转换为 Greeter ，因为方法是在编译时选择的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">if</span> (o <span style="color:#080;font-weight:bold">instanceof</span> Greeter) {
    <span style="color:#0a8;font-weight:bold">System</span>.out.println(((Greeter)o).greeting());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，在 Groovy 中，即使您在 doSomething 方法上添加 @TypeChecked （从而激活类型检查），也不需要强制转换。编译器嵌入了instanceof 推理，使强制转换成为可选的。</p>
</div>
</div>
<div class="sect5">
<h6 id="section-flow-typing"><a class="link" href="#section-flow-typing">流类型</a></h6>
<div class="paragraph">
<p>流类型是 Groovy 类型检查模式中的一个重要概念，也是类型推断的扩展。这个想法是编译器能够推断代码流中变量的类型，而不仅仅是在初始化时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> flowTyping() {
    <span style="color:#080;font-weight:bold">def</span> o = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>                       // <b class="conum">(1)</b>
    o = o.toUpperCase()                 // <b class="conum">(2)</b>
    o = <span style="color:#60E">9d</span>                              // <b class="conum">(3)</b>
    o = <span style="color:#0a8;font-weight:bold">Math</span>.sqrt(o)                    // <b class="conum">(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>首先，使用 def 声明 o 并分配一个 String</p>
</li>
<li>
<p>编译器推断 o 是 String ，因此允许调用 toUpperCase</p>
</li>
<li>
<p>o 被重新分配为 double</p>
</li>
<li>
<p>调用 Math.sqrt 通过编译，因为编译器知道此时 o 是 double</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此类型检查器知道变量的具体类型随着时间的推移而变化。特别是，如果您将最后一个分配替换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">o = <span style="color:#60E">9d</span>
o = o.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，类型检查器将在编译时失败，因为当调用 toUpperCase 时，它知道 o 是 double ，因此这是一个类型错误。</p>
</div>
<div class="paragraph">
<p>It is important to understand that it is not the fact of declaring a variable with <code>def</code> that triggers type inference.
流类型适用于任何类型的任何变量。使用显式类型声明变量只会限制可以分配给该变量的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> flowTypingWithExplicitType() {
    <span style="color:#0a8;font-weight:bold">List</span> list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>]           // <b class="conum">(1)</b>
    list = list*.toUpperCase()          // <b class="conum">(2)</b>
    list = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>                        // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>list 被声明为未经检查的 List 并分配了一个“String”列表文字</p>
</li>
<li>
<p>由于流类型，该行通过了编译：类型检查器知道 list 此时是 List&lt;String&gt;</p>
</li>
<li>
<p>但你不能将 String 分配给 List 所以这是一个类型检查错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您还可以注意到，即使声明变量时没有泛型信息，类型检查器也知道组件类型是什么。因此，这样的代码将编译失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> flowTypingWithExplicitType() {
    <span style="color:#0a8;font-weight:bold">List</span> list = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>]           // <b class="conum">(1)</b>
    list.add(<span style="color:#00D">1</span>)                         // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>list 被推断为 List&lt;String&gt;</p>
</li>
<li>
<p>因此将 int 添加到 List&lt;String&gt; 是一个编译时错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>修复此问题需要在声明中添加显式泛型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> flowTypingWithExplicitType() {
    <span style="color:#0a8;font-weight:bold">List</span>&lt;? <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Serializable</span>&gt; list = <span style="color:#339;font-weight:bold">[]</span>                      // <b class="conum">(1)</b>
    list.addAll([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">b</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">c</span><span style="color:#710">'</span></span>])                                  // <b class="conum">(2)</b>
    list.add(<span style="color:#00D">1</span>)                                                 // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>list 声明为 List&lt;? extends Serializable&gt; 并用空列表初始化</p>
</li>
<li>
<p>添加到列表中的元素符合列表的声明类型</p>
</li>
<li>
<p>因此允许将 int 添加到 List&lt;? extends Serializable&gt;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>引入流类型是为了减少经典 Groovy 和静态 Groovy 之间的语义差异。特别是考虑一下 Java 中这段代码的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Integer</span> compute(<span style="color:#0a8;font-weight:bold">String</span> str) {
    <span style="color:#080;font-weight:bold">return</span> str.length();
}
<span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">String</span> compute(<span style="color:#0a8;font-weight:bold">Object</span> o) {
    <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Nope</span><span style="color:#710">&quot;</span></span>;
}
<span style="color:#777">// ...</span>
<span style="color:#0a8;font-weight:bold">Object</span> string = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Some string</span><span style="color:#710">&quot;</span></span>;          // <b class="conum">(1)</b>
<span style="color:#0a8;font-weight:bold">Object</span> result = compute(string);        // <b class="conum">(2)</b>
<span style="color:#0a8;font-weight:bold">System</span>.out.println(result);             // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>o 被声明为 Object 并分配了 String</p>
</li>
<li>
<p>我们用 o 调用 compute 方法</p>
</li>
<li>
<p>并打印结果</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在 Java 中，此代码将输出 Nope ，因为方法选择是在编译时基于声明的类型完成的。因此，即使 o 在运行时是 String ，它仍然是调用的 Object 版本，因为 o 已被声明为一个 Object 。简而言之，在Java中，声明类型是最重要的，无论是变量类型、参数类型还是返回类型。</p>
</div>
<div class="paragraph">
<p>在 Groovy 中，我们可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">int</span> compute(<span style="color:#0a8;font-weight:bold">String</span> string) { string.length() }
<span style="color:#0a8;font-weight:bold">String</span> compute(<span style="color:#0a8;font-weight:bold">Object</span> o) { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Nope</span><span style="color:#710">&quot;</span></span> }
<span style="color:#0a8;font-weight:bold">Object</span> o = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">string</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">def</span> result = compute(o)
println result</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这一次，它将返回 6 ，因为该方法是在运行时根据实际参数类型选择的。因此在运行时， o 是 String ，因此使用 String 变体。请注意，此行为与类型检查无关，这是 Groovy 一般的工作方式：动态调度。</p>
</div>
<div class="paragraph">
<p>In type checked Groovy, we want to make sure the type checker selects the same method <strong>at compile time</strong>, that the runtime
would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow
typing. With flow typing, <code>o</code> is <em>inferred</em> as a <code>String</code> when the <code>compute</code> method is called, so the version which takes
a <code>String</code> and returns an <code>int</code> is chosen. This means that we can infer the return type of the method to be an <code>int</code>, and
not a <code>String</code>. This is important for subsequent calls and type safety.</p>
</div>
<div class="paragraph">
<p>So in type checked Groovy, flow typing is a very important concept, which also implies that if <code>@TypeChecked</code> is applied,
methods are selected based on the <em>inferred types</em> of the arguments, not on the declared types. This doesn&#8217;t ensure 100%
type safety, because the type checker <em>may</em> select a wrong method, but it ensures the closest semantics to dynamic Groovy.</p>
</div>
</div>
<div class="sect5">
<h6 id="_高级类型推断"><a class="link" href="#_高级类型推断">高级类型推断</a></h6>
<div class="paragraph">
<p>使用<a href="#section-flow-typing">流类型</a>和<a href="#section-lub">最小上限推断</a>的组合来执行高级类型推理并确保多种情况下的类型安全。特别是，程序控制结构可能会改变变量的推断类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Top</span> {
   <span style="color:#339;font-weight:bold">void</span> methodFromTop() {}
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bottom</span> <span style="color:#088;font-weight:bold">extends</span> Top {
   <span style="color:#339;font-weight:bold">void</span> methodFromBottom() {}
}
<span style="color:#080;font-weight:bold">def</span> o
<span style="color:#080;font-weight:bold">if</span> (someCondition) {
    o = <span style="color:#080;font-weight:bold">new</span> Top()                               // <b class="conum">(1)</b>
} <span style="color:#080;font-weight:bold">else</span> {
    o = <span style="color:#080;font-weight:bold">new</span> Bottom()                            // <b class="conum">(2)</b>
}
o.methodFromTop()                               // <b class="conum">(3)</b>
o.methodFromBottom()  <span style="color:#777">// compilation error      </span>// <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>如果 someCondition 为 true，则为 o 分配 Top</p>
</li>
<li>
<p>如果 someCondition 为 false，则为 o 分配 Bottom</p>
</li>
<li>
<p>调用 methodFromTop 是安全的</p>
</li>
<li>
<p>但调用 methodFromBottom 则不然，所以这是一个编译时错误</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When the type checker visits an <code>if/else</code> control structure, it checks all variables which are assigned in <code>if/else</code> branches
and computes the <a href="#section-lub">least upper bound</a> of all assignments. This type is the type of the inferred variable
after the <code>if/else</code> block, so in this example, <code>o</code> is assigned a <code>Top</code> in the <code>if</code> branch and a <code>Bottom</code> in the <code>else</code>
branch. The <a href="#section-lub">LUB</a> of those is a <code>Top</code>, so after the conditional branches, the compiler infers <code>o</code> as being
a <code>Top</code>. Calling <code>methodFromTop</code> will therefore be allowed, but not <code>methodFromBottom</code>.</p>
</div>
<div class="paragraph">
<p>The same reasoning exists with closures and in particular closure shared variables. A closure shared variable is a variable
which is defined outside of a closure, but used inside a closure, as in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> text = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, world!</span><span style="color:#710">'</span></span>                          // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> closure = {
    println text                                    // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a variable named <code>text</code> is declared</p>
</li>
<li>
<p><code>text</code> is used from inside a closure. It is a <em>closure shared variable</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Groovy allows developers to use those variables without requiring them to be final. This means that a closure shared
variable can be reassigned inside a closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#0a8;font-weight:bold">String</span> result
doSomething { <span style="color:#0a8;font-weight:bold">String</span> <span style="color:#950">it</span> -&gt;
    result = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Result: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span><span style="color:#950">it</span></span><span style="color:#710">&quot;</span></span>
}
result = result?.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that a closure is an independent block of code that can be executed (or not) at <strong>any</strong> time. In particular,
<code>doSomething</code> may be asynchronous, for example. This means that the body of a closure doesn&#8217;t belong to the main control
flow. For that reason, the type checker also computes, for each closure shared variable, the <a href="#section-lub">LUB</a> of all
assignments of the variable, and will use that <code>LUB</code> as the inferred type outside of the scope of the closure, like in
this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Top</span> {
   <span style="color:#339;font-weight:bold">void</span> methodFromTop() {}
}
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Bottom</span> <span style="color:#088;font-weight:bold">extends</span> Top {
   <span style="color:#339;font-weight:bold">void</span> methodFromBottom() {}
}
<span style="color:#080;font-weight:bold">def</span> o = <span style="color:#080;font-weight:bold">new</span> Top()                               // <b class="conum">(1)</b>
<span style="color:#0a8;font-weight:bold">Thread</span>.start {
    o = <span style="color:#080;font-weight:bold">new</span> Bottom()                            // <b class="conum">(2)</b>
}
o.methodFromTop()                               // <b class="conum">(3)</b>
o.methodFromBottom()  <span style="color:#777">// compilation error      </span>// <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a closure-shared variable is first assigned a <code>Top</code></p>
</li>
<li>
<p>inside the closure, it is assigned a <code>Bottom</code></p>
</li>
<li>
<p><code>methodFromTop</code> is allowed</p>
</li>
<li>
<p><code>methodFromBottom</code> is a compilation error</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here, it is clear that when <code>methodFromBottom</code> is called, there&#8217;s no guarantee, at compile-time or runtime that the
type of <code>o</code> will <em>effectively</em> be a <code>Bottom</code>. There are chances that it will be, but we can&#8217;t make sure, because it&#8217;s
asynchronous. So the type checker will only allow calls on the <a href="#section-lub">least upper bound</a>, which is here a <code>Top</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_closures_and_type_inference"><a class="link" href="#_closures_and_type_inference">6.6.2.6. Closures and type inference</a></h5>
<div class="paragraph">
<p>The type checker performs special inference on closures, resulting on additional checks on one side and improved fluency
on the other side.</p>
</div>
<div class="sect5">
<h6 id="_return_type_inference"><a class="link" href="#_return_type_inference">Return type inference</a></h6>
<div class="paragraph">
<p>The first thing that the type checker is capable of doing is inferring the <em>return type</em> of a closure. This is simply
 illustrated in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">int</span> testClosureReturnTypeInference(<span style="color:#0a8;font-weight:bold">String</span> arg) {
    <span style="color:#080;font-weight:bold">def</span> cl = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Arg: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>arg</span><span style="color:#710">&quot;</span></span> }                                // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">def</span> val = cl()                                          // <b class="conum">(2)</b>

    val.length()                                            // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a closure is defined, and it returns a string (more precisely a <code>GString</code>)</p>
</li>
<li>
<p>we call the closure and assign the result to a variable</p>
</li>
<li>
<p>the type checker inferred that the closure would return a string, so calling <code>length()</code> is allowed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, unlike a method which declares its return type explicitly, there&#8217;s no need to declare the return type
of a closure: its type is inferred from the body of the closure.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Closures vs methods</div>
<div class="paragraph">
<p>It&#8217;s worth noting that return type inference is only applicable to closures. While the type checker could do the
same on a method, it is in practice not desirable: <em>in general</em>, methods can be overridden and it is not statically
possible to make sure that the method which is called is not an overridden version. So flow typing would actually
think that a method returns something, while in reality, it could return something else, like illustrated in the
following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@TypeChecked</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">compute</span>() { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">some string</span><span style="color:#710">'</span></span> }             // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">computeFully</span>() {
        compute().toUpperCase()                 // <b class="conum">(2)</b>
    }
}
<span style="color:#007">@TypeChecked</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">B</span> <span style="color:#088;font-weight:bold">extends</span> A {
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">compute</span>() { <span style="color:#00D">123</span> }                       // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>class <code>A</code> defines a method <code>compute</code> which effectively returns a <code>String</code></p>
</li>
<li>
<p>this will fail compilation because the return type of <code>compute</code> is <code>def</code>(aka <code>Object</code>)</p>
</li>
<li>
<p>class <code>B</code> extends <code>A</code> and redefines <code>compute</code>, this type returning an <code>int</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, if the type checker relied on the inferred return type of a method, with <a href="#section-flow-typing">flow typing</a>,
the type checker could determine that it is ok to call <code>toUpperCase</code>. It is in fact an <strong>error</strong>, because a subclass can
override <code>compute</code> and return a different object. Here, <code>B#compute</code> returns an <code>int</code>, so someone calling <code>computeFully</code>
on an instance of <code>B</code> would see a runtime error. The compiler prevents this from happening by using the declared return
type of methods instead of the inferred return type.</p>
</div>
<div class="paragraph">
<p>For consistency, this behavior is the same for <strong>every</strong> method, even if they are static or final.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_parameter_type_inference"><a class="link" href="#_parameter_type_inference">Parameter type inference</a></h6>
<div class="paragraph">
<p>In addition to the return type, it is possible for a closure to infer its parameter types from the context. There are
two ways for the compiler to infer the parameter types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>through <em>implicit SAM type coercion</em></p>
</li>
<li>
<p>through API metadata</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To illustrate this, lets start with an example that will fail compilation due to the inability for the type checker
to infer the parameter types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Person</span> {
    <span style="color:#0a8;font-weight:bold">String</span> name
    <span style="color:#339;font-weight:bold">int</span> age
}

<span style="color:#339;font-weight:bold">void</span> inviteIf(Person p, Closure&lt;<span style="color:#0a8;font-weight:bold">Boolean</span>&gt; predicate) {           // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">if</span> (predicate.call(p)) {
        <span style="color:#777">// send invite</span>
        <span style="color:#777">// ...</span>
    }
}

<span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> failCompilation() {
    Person p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Gerard</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">55</span>)
    inviteIf(p) {                                               // <b class="conum">(2)</b>
        <span style="color:#950">it</span>.age &gt;= <span style="color:#00D">18</span> <span style="color:#777">// No such property: age                   </span>// <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the <code>inviteIf</code> method accepts a <code>Person</code> and a <code>Closure</code></p>
</li>
<li>
<p>we call it with a <code>Person</code> and a <code>Closure</code></p>
</li>
<li>
<p>yet <code>it</code> is not statically known as being a <code>Person</code> and compilation fails</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this example, the closure body contains <code>it.age</code>. With dynamic, not type checked code, this would work, because the
type of <code>it</code> would be a <code>Person</code> at runtime. Unfortunately, at compile-time, there&#8217;s no way to know what is the type
of <code>it</code>, just by reading the signature of <code>inviteIf</code>.</p>
</div>
<div class="sect6">
<h7 id="_explicit_closure_parameters"><a class="link" href="#_explicit_closure_parameters">Explicit closure parameters</a></h7>
<div class="paragraph">
<p>To be short, the type checker doesn&#8217;t have enough contextual information on the <code>inviteIf</code> method to determine statically
the type of <code>it</code>. This means that the method call needs to be rewritten like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">inviteIf(p) { Person <span style="color:#950">it</span> -&gt;                                  // <b class="conum">(1)</b>
    <span style="color:#950">it</span>.age &gt;= <span style="color:#00D">18</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the type of <code>it</code> needs to be declared explicitly</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By explicitly declaring the type of the <code>it</code> variable, you can work around the problem and make this code statically
checked.</p>
</div>
</div>
<div class="sect6">
<h7 id="_parameters_inferred_from_single_abstract_method_types"><a class="link" href="#_parameters_inferred_from_single_abstract_method_types">Parameters inferred from single-abstract method types</a></h7>
<div class="paragraph">
<p>For an API or framework designer, there are two ways to make this more elegant for users, so that they don&#8217;t have to
declare an explicit type for the closure parameters. The first one, and easiest, is to replace the closure with a
SAM type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">interface</span> <span style="color:#0a8;font-weight:bold">Predicate</span>&lt;On&gt; { <span style="color:#339;font-weight:bold">boolean</span> apply(On e) }                 // <b class="conum">(1)</b>

<span style="color:#339;font-weight:bold">void</span> inviteIf(Person p, <span style="color:#0a8;font-weight:bold">Predicate</span>&lt;Person&gt; predicate) {          // <b class="conum">(2)</b>
    <span style="color:#080;font-weight:bold">if</span> (predicate.apply(p)) {
        <span style="color:#777">// send invite</span>
        <span style="color:#777">// ...</span>
    }
}

<span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> passesCompilation() {
    Person p = <span style="color:#080;font-weight:bold">new</span> Person(<span style="color:#606">name</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Gerard</span><span style="color:#710">'</span></span>, <span style="color:#606">age</span>: <span style="color:#00D">55</span>)

    inviteIf(p) {                                               // <b class="conum">(3)</b>
        <span style="color:#950">it</span>.age &gt;= <span style="color:#00D">18</span>                                            // <b class="conum">(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>declare a <code>SAM</code> interface with an <code>apply</code> method</p>
</li>
<li>
<p><code>inviteIf</code> now uses a <code>Predicate&lt;Person&gt;</code> instead of a <code>Closure&lt;Boolean&gt;</code></p>
</li>
<li>
<p>there&#8217;s no need to declare the type of the <code>it</code> variable anymore</p>
</li>
<li>
<p><code>it.age</code> compiles properly, the type of <code>it</code> is inferred from the <code>Predicate#apply</code> method signature</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
By using this technique, we leverage the <em>automatic coercion of closures to SAM types</em> feature of Groovy.
Whether you should use a <em>SAM type</em> or a <em>Closure</em> really depends on what you need to do. In a lot of cases,
using a SAM interface is enough, especially if you consider functional interfaces as they are found in Java 8. However,
closures provide features that are not accessible to functional interfaces. In particular, closures can have a delegate,
and owner and can be manipulated as objects (for example, cloned, serialized, curried, &#8230;&#8203;) before being called. They can
also support multiple signatures (polymorphism). So if you need that kind of manipulation, it is preferable to switch to
the most advanced type inference annotations which are described below.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The original issue that needs to be solved when it comes to closure parameter type inference, that is to say, statically
determining the types of the arguments of a closure <em>without</em> having to have them explicitly declared, is that the Groovy
type system inherits the Java type system, which is insufficient to describe the types of the arguments.</p>
</div>
</div>
<div class="sect6">
<h7 id="_the_closureparams_annotation"><a class="link" href="#_the_closureparams_annotation">The <code>@ClosureParams</code> annotation</a></h7>
<div class="paragraph">
<p>Groovy provides an annotation, <code>@ClosureParams</code> which is aimed at completing type information. This annotation is primarily
aimed at framework and API developers who want to extend the capabilities of the type checker by providing type inference
metadata. This is important if your library makes use of closures and that you want the maximum level of tooling support
too.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s illustrate this by fixing the original example, introducing the <code>@ClosureParams</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.ClosureParams</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FirstParam</span>
<span style="color:#339;font-weight:bold">void</span> inviteIf(Person p, <span style="color:#007">@ClosureParams</span>(FirstParam) Closure&lt;<span style="color:#0a8;font-weight:bold">Boolean</span>&gt; predicate) {        // <b class="conum">(1)</b>
    <span style="color:#080;font-weight:bold">if</span> (predicate.call(p)) {
        <span style="color:#777">// send invite</span>
        <span style="color:#777">// ...</span>
    }
}
inviteIf(p) {                                                                       // <b class="conum">(2)</b>
    <span style="color:#950">it</span>.age &gt;= <span style="color:#00D">18</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the closure parameter is annotated with <code>@ClosureParams</code></p>
</li>
<li>
<p>it&#8217;s not necessary to use an explicit type for <code>it</code>, which is inferred</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>@ClosureParams</code> annotation minimally accepts one argument, which is named a <em>type hint</em>. A type hint is a class which
is responsible for completing type information at compile time for the closure. In this example, the type hint being used
is <code>groovy.transform.stc.FirstParam</code> which indicated to the type checker that the closure will accept one parameter
whose type is the type of the first parameter of the method. In this case, the first parameter of the method is <code>Person</code>,
so it indicates to the type checker that the first parameter of the closure is in fact a <code>Person</code>.</p>
</div>
<div class="paragraph">
<p>A second optional argument is named <em>options</em>. Its semantics depend on the <em>type hint</em> class. Groovy comes with
various bundled type hints, illustrated in the table below:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Predefined type hints</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type hint</th>
<th class="tableblock halign-left valign-top">Polymorphic?</th>
<th class="tableblock halign-left valign-top">Description and examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FirstParam</code><br>
<code>SecondParam</code><br>
<code>ThirdParam</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The first (resp. second, third) parameter type of the method<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FirstParam</span>
<span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#0a8;font-weight:bold">String</span> str, <span style="color:#007">@ClosureParams</span>(FirstParam) Closure c) {
    c(str)
}
doSomething(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) { println <span style="color:#950">it</span>.toUpperCase() }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.SecondParam</span>
<span style="color:#339;font-weight:bold">void</span> withHash(<span style="color:#0a8;font-weight:bold">String</span> str, <span style="color:#339;font-weight:bold">int</span> seed, <span style="color:#007">@ClosureParams</span>(SecondParam) Closure c) {
    c(<span style="color:#00D">31</span>*str.hashCode()+seed)
}
withHash(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, (<span style="color:#339;font-weight:bold">int</span>)<span style="color:#0a8;font-weight:bold">System</span>.currentTimeMillis()) {
    <span style="color:#339;font-weight:bold">int</span> mod = <span style="color:#950">it</span>%<span style="color:#00D">2</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.ThirdParam</span>
<span style="color:#0a8;font-weight:bold">String</span> format(<span style="color:#0a8;font-weight:bold">String</span> prefix, <span style="color:#0a8;font-weight:bold">String</span> postfix, <span style="color:#0a8;font-weight:bold">String</span> o, <span style="color:#007">@ClosureParams</span>(ThirdParam) Closure c) {
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>prefix</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>c(o)<span style="font-weight:bold;color:#666">}</span></span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">$</span>postfix</span><span style="color:#710">&quot;</span></span>
}
<span style="color:#080;font-weight:bold">assert</span> format(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">baz</span><span style="color:#710">'</span></span>) {
    <span style="color:#950">it</span>.toUpperCase()
} == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">fooBAZbar</span><span style="color:#710">'</span></span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FirstParam.FirstGenericType</code><br>
<code>SecondParam.FirstGenericType</code><br>
<code>ThirdParam.FirstGenericType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The first generic type of the first (resp. second, third) parameter of the method<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FirstParam</span>
<span style="color:#088;font-weight:bold">public</span> &lt;T&gt; <span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#0a8;font-weight:bold">List</span>&lt;T&gt; strings, <span style="color:#007">@ClosureParams</span>(FirstParam.FirstGenericType) Closure c) {
    strings.each {
        c(<span style="color:#950">it</span>)
    }
}
doSomething([<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">bar</span><span style="color:#710">'</span></span>]) { println <span style="color:#950">it</span>.toUpperCase() }
doSomething([<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>]) { println(<span style="color:#00D">2</span>*<span style="color:#950">it</span>) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Variants for <code>SecondGenericType</code> and <code>ThirdGenericType</code> exist for all <code>FirstParam</code>, <code>SecondParam</code> and <code>ThirdParam</code>
type hints.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SimpleType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A type hint for which the type of closure parameters comes from the options string.<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.SimpleType</span>
<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#007">@ClosureParams</span>(value=<span style="color:#0a8;font-weight:bold">SimpleType</span>,options=[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">java.lang.String</span><span style="color:#710">'</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">int</span><span style="color:#710">'</span></span>]) Closure c) {
    c(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>,<span style="color:#00D">3</span>)
}
doSomething { str, len -&gt;
    <span style="color:#080;font-weight:bold">assert</span> str.length() == len
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This type hint supports a <strong>single</strong> signature and each of the parameter is specified as a value of the <em>options</em> array
using a fully-qualified type name or a primitive type.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MapEntryOrKeyValue</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A dedicated type hint for closures that either work on a <code>Map.Entry</code> single parameter, or two parameters corresponding
to the key and the value.<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.MapEntryOrKeyValue</span>
<span style="color:#088;font-weight:bold">public</span> &lt;K,V&gt; <span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#0a8;font-weight:bold">Map</span>&lt;K,V&gt; map, <span style="color:#007">@ClosureParams</span>(MapEntryOrKeyValue) Closure c) {
    <span style="color:#777">// ...</span>
}
doSomething([<span style="color:#606">a</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>]) { k,v -&gt;
    <span style="color:#080;font-weight:bold">assert</span> k.toUpperCase() == v.toUpperCase()
}
doSomething([<span style="color:#606">abc</span>: <span style="color:#00D">3</span>]) { e -&gt;
    <span style="color:#080;font-weight:bold">assert</span> e.key.length() == e.value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This type hint <strong>requires</strong> that the first argument is a <code>Map</code> type, and infers the closure parameter types from the map
actual key/value types.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FromAbstractTypeMethods</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Infers closure parameter types from the abstract method of some type. A signature is inferred for <strong>each</strong> abstract method.<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FromAbstractTypeMethods</span>
<span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Foo</span> {
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">void</span> firstSignature(<span style="color:#339;font-weight:bold">int</span> x, <span style="color:#339;font-weight:bold">int</span> y)
    <span style="color:#088;font-weight:bold">abstract</span> <span style="color:#339;font-weight:bold">void</span> secondSignature(<span style="color:#0a8;font-weight:bold">String</span> str)
}
<span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#007">@ClosureParams</span>(value=FromAbstractTypeMethods, options=[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Foo</span><span style="color:#710">&quot;</span></span>]) Closure cl) {
    <span style="color:#777">// ...</span>
}
doSomething { a, b -&gt; a+b }
doSomething { s -&gt; s.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there are multiple signatures like in the example above, the type checker will <strong>only</strong> be able to infer the types of
the arguments if the arity of each method is different. In the example above, <code>firstSignature</code> takes 2 arguments and
<code>secondSignature</code> takes 1 argument, so the type checker can infer the argument types based on the number of arguments.
But see the optional resolver class attribute discussed next.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FromString</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Infers the closure parameter types from the <code>options</code> argument. The <code>options</code> argument consists of an array of comma-separated
non-primitive types. Each element of the array corresponds to a single signature, and each comma in an element separate
parameters of the signature. In short, this is the most generic type hint, and each string of the <code>options</code> map is <strong>parsed</strong>
as if it was a signature literal. While being very powerful, this type hint must be avoided if you can because it increases
the compilation times due to the necessity of parsing the type signatures.</p>
</div>
<div class="paragraph">
<p>A single signature for a closure accepting a <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FromString</span>
<span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#007">@ClosureParams</span>(value=FromString, options=[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">String</span><span style="color:#710">&quot;</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">String,Integer</span><span style="color:#710">&quot;</span></span>]) Closure cl) {
    <span style="color:#777">// ...</span>
}
doSomething { s -&gt; s.toUpperCase() }
doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A polymorphic closure, accepting either a <code>String</code> or a <code>String, Integer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FromString</span>
<span style="color:#339;font-weight:bold">void</span> doSomething(<span style="color:#007">@ClosureParams</span>(value=FromString, options=[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">String</span><span style="color:#710">&quot;</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">String,Integer</span><span style="color:#710">&quot;</span></span>]) Closure cl) {
    <span style="color:#777">// ...</span>
}
doSomething { s -&gt; s.toUpperCase() }
doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A polymorphic closure, accepting either a <code>T</code> or a pair <code>T,T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">groovy.transform.stc.FromString</span>
<span style="color:#088;font-weight:bold">public</span> &lt;T&gt; <span style="color:#339;font-weight:bold">void</span> doSomething(T e, <span style="color:#007">@ClosureParams</span>(value=FromString, options=[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T</span><span style="color:#710">&quot;</span></span>,<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T,T</span><span style="color:#710">&quot;</span></span>]) Closure cl) {
    <span style="color:#777">// ...</span>
}
doSomething(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) { s -&gt; s.toUpperCase() }
doSomething(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foo</span><span style="color:#710">'</span></span>) { s1,s2 -&gt; <span style="color:#080;font-weight:bold">assert</span> s1.toUpperCase() == s2.toUpperCase() }</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Even though you use <code>FirstParam</code>, <code>SecondParam</code> or <code>ThirdParam</code> as a type hint, it doesn&#8217;t strictly mean that the
argument which will be passed to the closure <strong>will</strong> be the first (resp. second, third) argument of the method call. It
only means that the <strong>type</strong> of the parameter of the closure will be the <strong>same</strong> as the type of the first (resp.  second,
 third) argument of the method call.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In short, the lack of the <code>@ClosureParams</code> annotation on a method accepting a <code>Closure</code> will <strong>not</strong> fail compilation. If
 present (and it can be present in Java sources as well as Groovy sources), then the type checker has <strong>more</strong> information
 and can perform additional type inference. This makes this feature particularly interesting for framework developers.</p>
</div>
<div class="paragraph">
<p>A third optional argument is named <em>conflictResolutionStrategy</em>. It can reference a class (extending from
<code>ClosureSignatureConflictResolver</code>) that can perform additional resolution of parameter types if more than
one are found after initial inference calculations are complete. Groovy comes with a default type resolver
which does nothing, and another which selects the first signature if multiple are found. The resolver is
only invoked if more than one signature is found and is by design a post processor. Any statements which need
injected typing information must pass one of the parameter signatures determined through type hints. The
resolver then picks among the returned candidate signatures.</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_delegatesto"><a class="link" href="#_delegatesto"><code>@DelegatesTo</code></a></h6>
<div class="paragraph">
<p>The <code>@DelegatesTo</code> annotation is used by the type checker to infer the type of the delegate. It allows the API designer
to instruct the compiler what is the type of the delegate and the delegation strategy. The <code>@DelegatesTo</code> annotation is
discussed in a <a href="core-domain-specific-languages.html#section-delegatesto">specific section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_static_compilation"><a class="link" href="#_static_compilation">6.6.3. Static compilation</a></h4>
<div class="sect4">
<h5 id="_dynamic_vs_static"><a class="link" href="#_dynamic_vs_static">6.6.3.1. Dynamic vs static</a></h5>
<div class="paragraph">
<p>In the <a href="#static-type-checking">type checking section</a>, we have seen that Groovy provides optional type checking thanks to the
<code>@TypeChecked</code> annotation. The type checker runs at compile time and performs a static analysis of dynamic code. The
program will behave exactly the same whether type checking has been enabled or not. This means that the <code>@TypeChecked</code>
annotation is neutral in regard to the semantics of a program. Even though it may be necessary to add type information
in the sources so that the program is considered type safe, in the end, the semantics of the program are the same.</p>
</div>
<div class="paragraph">
<p>While this may sound fine, there is actually one issue with this: type checking of dynamic code, done at compile time, is
by definition only correct if no runtime specific behavior occurs. For example, the following program passes type checking:</p>
</div>
<div id="typechecked-defeated" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Computer</span> {
    <span style="color:#339;font-weight:bold">int</span> compute(<span style="color:#0a8;font-weight:bold">String</span> str) {
        str.length()
    }
    <span style="color:#0a8;font-weight:bold">String</span> compute(<span style="color:#339;font-weight:bold">int</span> x) {
        <span style="color:#0a8;font-weight:bold">String</span>.valueOf(x)
    }
}

<span style="color:#007">@groovy</span>.transform.TypeChecked
<span style="color:#339;font-weight:bold">void</span> test() {
    <span style="color:#080;font-weight:bold">def</span> computer = <span style="color:#080;font-weight:bold">new</span> Computer()
    computer.with {
        <span style="color:#080;font-weight:bold">assert</span> compute(compute(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foobar</span><span style="color:#710">'</span></span>)) ==<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">6</span><span style="color:#710">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two <code>compute</code> methods. One accepts a <code>String</code> and returns an <code>int</code>, the other accepts an <code>int</code> and returns
a <code>String</code>. If you compile this, it is considered type safe: the inner <code>compute('foobar')</code> call will return an <code>int</code>,
and calling <code>compute</code> on this <code>int</code> will in turn return a <code>String</code>.</p>
</div>
<div class="paragraph">
<p>Now, before calling <code>test()</code>, consider adding the following line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Computer.metaClass.compute = { <span style="color:#0a8;font-weight:bold">String</span> str -&gt; <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using runtime metaprogramming, we&#8217;re actually modifying the behavior of the <code>compute(String)</code> method, so that instead of
returning the length of the provided argument, it will return a <code>Date</code>. If you execute the program, it will fail at
runtime. Since this line can be added from anywhere, in any thread, there&#8217;s absolutely no way for the type checker to
statically make sure that no such thing happens. In short, the type checker is vulnerable to monkey patching. This is
just one example, but this illustrates the concept that doing static analysis of a dynamic program is inherently wrong.</p>
</div>
<div class="paragraph">
<p>The Groovy language provides an alternative annotation to <code>@TypeChecked</code> which will actually make sure that the methods
which are inferred as being called <strong>will</strong> effectively be called at runtime. This annotation turns the Groovy compiler
into a <strong>static compiler</strong>, where all method calls are resolved at compile time <strong>and</strong> the generated bytecode makes sure
that this happens: the annotation is <code>@groovy.transform.CompileStatic</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="compilestatic-annotation"><a class="link" href="#compilestatic-annotation">6.6.3.2. The <code>@CompileStatic</code> annotation</a></h5>
<div class="paragraph">
<p>The <code>@CompileStatic</code> annotation can be added anywhere the <code>@TypeChecked</code> annotation can be used, that is to say on
a class or a method. It is not necessary to add both <code>@TypeChecked</code> and <code>@CompileStatic</code>, as <code>@CompileStatic</code> performs
everything <code>@TypeChecked</code> does, but in addition triggers static compilation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the <a href="#typechecked-defeated">example which failed</a>, but this time let&#8217;s replace the <code>@TypeChecked</code> annotation
with <code>@CompileStatic</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Computer</span> {
    <span style="color:#339;font-weight:bold">int</span> compute(<span style="color:#0a8;font-weight:bold">String</span> str) {
        str.length()
    }
    <span style="color:#0a8;font-weight:bold">String</span> compute(<span style="color:#339;font-weight:bold">int</span> x) {
        <span style="color:#0a8;font-weight:bold">String</span>.valueOf(x)
    }
}

<span style="color:#007">@groovy</span>.transform.CompileStatic
<span style="color:#339;font-weight:bold">void</span> test() {
    <span style="color:#080;font-weight:bold">def</span> computer = <span style="color:#080;font-weight:bold">new</span> Computer()
    computer.with {
        <span style="color:#080;font-weight:bold">assert</span> compute(compute(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">foobar</span><span style="color:#710">'</span></span>)) ==<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">6</span><span style="color:#710">'</span></span>
    }
}
Computer.metaClass.compute = { <span style="color:#0a8;font-weight:bold">String</span> str -&gt; <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Date</span>() }
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the <strong>only</strong> difference. If we execute this program, this time, there is no runtime error. The <code>test</code> method
became immune to monkey patching, because the <code>compute</code> methods which are called in its body are linked at compile
time, so even if the metaclass of <code>Computer</code> changes, the program still behaves <strong>as expected by the type checker</strong>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_key_benefits"><a class="link" href="#_key_benefits">6.6.3.3. Key benefits</a></h5>
<div class="paragraph">
<p>There are several benefits of using <code>@CompileStatic</code> on your code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>type safety</p>
</li>
<li>
<p>immunity to <a href="#compilestatic-annotation">monkey patching</a></p>
</li>
<li>
<p>performance improvements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The performance improvements depend on the kind of program you are executing. If it is I/O bound, the difference between
statically compiled code and dynamic code is barely noticeable. On highly CPU intensive code, since the bytecode which
is generated is very close, if not equal, to the one that Java would produce for an equivalent program, the performance
is greatly improved.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Using the <em>invokedynamic</em> version of Groovy, which is accessible to people using JDK 7 and above, the performance
of the dynamic code should be very close to the performance of statically compiled code. Sometimes, it can even be faster!
There is only one way to determine which version you should choose: measuring. The reason is that depending on your program
<strong>and</strong> the JVM that you use, the performance can be significantly different. In particular, the <em>invokedynamic</em> version of
Groovy is very sensitive to the JVM version in use.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型检查扩展"><a class="link" href="#_类型检查扩展">6.7. 类型检查扩展</a></h3>
<div class="sect3">
<h4 id="_编写类型检查扩展"><a class="link" href="#_编写类型检查扩展">6.7.1. 编写类型检查扩展</a></h4>
<div class="sect4">
<h5 id="_更智能的类型检查器"><a class="link" href="#_更智能的类型检查器">6.7.1.1. 更智能的类型检查器</a></h5>
<div class="paragraph">
<p>尽管 Groovy 是一种动态语言，但它可以在编译时与<a href="#static-type-checking">静态类型检查器</a>一起使用，并使用 @TypeChecked 注释启用。在这种模式下，编译器会变得更加冗长，并会抛出错误，例如拼写错误、不存在的方法等。不过，这也有一些限制，其中大部分来自 Groovy 本质上仍然是一种动态语言。例如，您将无法对使用标记生成器的代码进行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> builder = <span style="color:#080;font-weight:bold">new</span> MarkupBuilder(out)
builder.html {
    head {
        <span style="color:#777">// ...</span>
    }
    body {
        p <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Hello, world!</span><span style="color:#710">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， html 、 head 、 body 或 p 方法都不存在。但是，如果您执行该代码，它就会起作用，因为 Groovy 使用动态调度并在运行时转换这些方法调用。在此builder中，您可以使用的标签数量和属性都没有限制，这意味着类型检查器没有机会在编译时了解所有可能的方法（标签），除非您创建一个build专用于 HTML。</p>
</div>
<div class="paragraph">
<p>Groovy 是实现内部 DSL 的首选平台。灵活的语法与运行时和编译时元编程功能相结合，使 Groovy 成为一个有趣的选择，因为它允许程序员专注于 DSL 而不是工具或实现。由于 Groovy DSL 是 Groovy 代码，因此很容易获得 IDE 支持，而无需编写专用插件等。</p>
</div>
<div class="paragraph">
<p>In a lot of cases, DSL engines are written in Groovy (or Java) then user
code is executed as scripts, meaning that you have some kind of wrapper
on top of user logic. The wrapper may consist, for example, in a
<code>GroovyShell</code> or <code>GroovyScriptEngine</code> that performs some tasks transparently
before running the script (adding imports, applying AST transforms,
extending a base script,…). Often, user written scripts come to
production without testing because the DSL logic comes to a point
where <strong>any</strong> user may write code using the DSL syntax. In the end, a user
may just ignore that what they write is actually <strong>code</strong>. This adds some
challenges for the DSL implementer, such as securing execution of user
code or, in this case, early reporting of errors.</p>
</div>
<div class="paragraph">
<p>For example, imagine a DSL which goal is to drive a rover on Mars
remotely. Sending a message to the rover takes around 15 minutes. If the
rover executes the script and fails with an error (say a typo), you have
two problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>first, feedback comes only after 30 minutes (the time needed for the
rover to get the script and the time needed to receive the error)</p>
</li>
<li>
<p>second, some portion of the script has been executed and you may have
to change the fixed script significantly (implying that you need to know
the current state of the rover…)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查扩展机制，允许 DSL 引擎的开发人员通过应用在常规Groovy类上进行的静态类型来使这些脚本更安全。</p>
</div>
<div class="paragraph">
<p>这里的原则是尽早失败，也就是说尽快使脚本编译失败，并且如果可能的话向用户提供反馈（包括好的错误消息）。</p>
</div>
<div class="paragraph">
<p>简而言之，类型检查扩展背后的想法是让编译器了解 DSL 使用的所有运行时元编程技巧，以便脚本可以受益于与详细静态编译代码相同级别的编译时检查。我们将看到您可以通过执行普通类型检查器无法执行的检查来更进一步，为您的用户提供强大的编译时检查。</p>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Howdoesitwork"><a class="link" href="#Typecheckingextensions-Howdoesitwork">6.7.1.2. <code>extensions</code> 属性</a></h5>
<div class="paragraph">
<p>@TypeChecked 注释支持名为 extensions 的属性。该参数是类型检查扩展脚本的字符串数组。</p>
</div>
<div class="paragraph">
<p>这些脚本是在编译时在类路径中找到的。例如，您可以写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#007">@TypeChecked</span>(extensions=<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/path/to/myextension.groovy</span><span style="color:#710">'</span></span>)
<span style="color:#339;font-weight:bold">void</span> foo() { ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将使用 myextension.groovy 脚本中找到的正常类型检查器的规则对 foo 方法进行类型检查。请注意，虽然类型检查器内部支持多种机制来实现类型检查扩展（包括普通的旧 java 代码），但推荐的方法是使用这些类型检查扩展脚本。</p>
</div>
</div>
<div class="sect4">
<h5 id="_应用于类型检查的dsl"><a class="link" href="#_应用于类型检查的dsl">6.7.1.3. 应用于类型检查的DSL</a></h5>
<div class="paragraph">
<p>类型检查扩展背后的想法是使用 DSL 来扩展类型检查器功能。该 DSL 允许您使用“事件驱动”API 挂钩编译过程，更具体地说是类型检查阶段。例如，当类型检查器进入方法主体时，它会引发扩展的 <code>beforeVisitMethod</code> 事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">beforeVisitMethod { methodNode -&gt;
 println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Entering </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>methodNode.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Imagine that you have this rover DSL at hand. A user would write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">robot.move <span style="color:#00D">100</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have a class defined as such:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Robot</span> {
    <span style="color:#0a8;font-weight:bold">Robot</span> move(<span style="color:#339;font-weight:bold">int</span> qt) { <span style="color:#950">this</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The script can be type checked before being executed using the following
script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
config.addCompilationCustomizers(
    <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(TypeChecked)            // <b class="conum">(1)</b>
)
<span style="color:#080;font-weight:bold">def</span> shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)                         // <b class="conum">(2)</b>
<span style="color:#080;font-weight:bold">def</span> robot = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Robot</span>()
shell.setVariable(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robot</span><span style="color:#710">'</span></span>, robot)
shell.evaluate(script)                                      // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a compiler configuration adds the <code>@TypeChecked</code> annotation to all classes</p>
</li>
<li>
<p>use the configuration in a <code>GroovyShell</code></p>
</li>
<li>
<p>so that scripts compiled using the shell are compiled with <code>@TypeChecked</code> without the user having to add it explicitly</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using the compiler configuration above, we can apply <em>@TypeChecked</em>
transparently to the script. In that case, it will fail at compile
time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - The variable [robot] is undeclared.</pre>
</div>
</div>
<div class="paragraph">
<p>Now, we will slightly update the configuration to include the
``extensions'' parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">config.addCompilationCustomizers(
    <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(
        TypeChecked,
        <span style="color:#606">extensions</span>:[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robotextension.groovy</span><span style="color:#710">'</span></span>])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the following to your classpath:</p>
</div>
<div class="listingblock">
<div class="title">robotextension.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">unresolvedVariable { <span style="color:#339;font-weight:bold">var</span> -&gt;
    <span style="color:#080;font-weight:bold">if</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robot</span><span style="color:#710">'</span></span>==<span style="color:#339;font-weight:bold">var</span>.name) {
        storeType(<span style="color:#339;font-weight:bold">var</span>, classNodeFor(<span style="color:#0a8;font-weight:bold">Robot</span>))
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we’re telling the compiler that if an <em>unresolved variable</em> is found
and that the name of the variable is <em>robot</em>, then we can make sure that the type of this
variable is <code>Robot</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-TheAPI"><a class="link" href="#Typecheckingextensions-TheAPI">6.7.1.4. Type checking extensions API</a></h5>
<div class="sect5">
<h6 id="Typecheckingextensions-AST"><a class="link" href="#Typecheckingextensions-AST">AST</a></h6>
<div class="paragraph">
<p>The type checking API is a low level API, dealing with the Abstract
Syntax Tree. You will have to know your AST well to develop extensions,
even if the DSL makes it much easier than just dealing with AST code
from plain Java or Groovy.</p>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Events"><a class="link" href="#Typecheckingextensions-Events">Events</a></h6>
<div class="paragraph">
<p>The type checker sends the following events, to which an extension
script can react:</p>
</div>
<table id="event-setup" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>setup</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called after the type checker finished initialization</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>none</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">setup {
    <span style="color:#777">// this is called before anything else</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Can be used to perform setup of your extension</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-finish" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>finish</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called after the type checker completed type checking</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>none</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">finish {
    <span style="color:#777">// this is after completion</span>
    <span style="color:#777">// of all type checking</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Can be used to perform additional checks after the type checker has finished its job.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedVariable" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>unresolvedVariable</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker finds an
  unresolved variable</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>VariableExpression vexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">unresolvedVariable { VariableExpression vexp -&gt;
    <span style="color:#080;font-weight:bold">if</span> (vexp.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">people</span><span style="color:#710">'</span></span>) {
        storeType(vexp, LIST_TYPE)
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allows the developer to help the type checker with user-injected variables.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedProperty" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>unresolvedProperty</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker cannot find
  a property on the receiver</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>PropertyExpression pexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">unresolvedProperty { PropertyExpression pexp -&gt;
    <span style="color:#080;font-weight:bold">if</span> (pexp.propertyAsString == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">longueur</span><span style="color:#710">'</span></span> &amp;&amp;
            getType(pexp.objectExpression) == STRING_TYPE) {
        storeType(pexp, int_TYPE)
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allows the developer to handle "dynamic" properties</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedAttribute" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>unresolvedAttribute</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker cannot
  find an attribute on the receiver</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>AttributeExpression aexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">unresolvedAttribute { AttributeExpression aexp -&gt;
    <span style="color:#080;font-weight:bold">if</span> (getType(aexp.objectExpression) == STRING_TYPE) {
        storeType(aexp, STRING_TYPE)
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allows the developer to handle missing attributes</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeMethodCall" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>beforeMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called before the type checker starts type
  checking a method call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>MethodCall call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">beforeMethodCall { call -&gt;
    <span style="color:#080;font-weight:bold">if</span> (isMethodCallExpression(call)
            &amp;&amp; call.methodAsString==<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">toUpperCase</span><span style="color:#710">'</span></span>) {
        addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Not allowed</span><span style="color:#710">'</span></span>,call)
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allows you to intercept method calls before the
type checker performs its own checks. This is useful if you want to
replace the default type checking with a custom one for a limited scope.
In that case, you must set the handled flag to true, so that the type
checker skips its own checks.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterMethodCall" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>afterMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called once the type checker has finished
  type checking a method call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>MethodCall call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">afterMethodCall { call -&gt;
    <span style="color:#080;font-weight:bold">if</span> (getTargetMethod(call).name==<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">toUpperCase</span><span style="color:#710">'</span></span>) {
        addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Not allowed</span><span style="color:#710">'</span></span>,call)
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allow you to perform additional checks after the type
checker has done its own checks. This is in particular useful if you
want to perform the standard type checking tests but also want to ensure
additional type safety, for example checking the arguments against each
other.Note that <code>afterMethodCall</code> is called even if you did
<code>beforeMethodCall</code> and set the handled flag to true.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-onMethodSelection" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>onMethodSelection</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker when it finds
  a method appropriate for a method call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Expression expr, MethodNode node</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">onMethodSelection { expr, node -&gt;
    <span style="color:#080;font-weight:bold">if</span> (node.declaringClass.name == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">java.lang.String</span><span style="color:#710">'</span></span>) {
        <span style="color:#777">// calling a method on 'String'</span>
        <span style="color:#777">// let’s perform additional checks!</span>
        <span style="color:#080;font-weight:bold">if</span> (++count&gt;<span style="color:#00D">2</span>) {
            addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You can use only 2 calls on String in your source code</span><span style="color:#710">&quot;</span></span>,expr)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type checker works by inferring
argument types of a method call, then chooses a target method. If it
finds one that corresponds, then it triggers this event. It is for
example interesting if you want to react on a specific method call, such
as entering the scope of a method that takes a closure as argument (as
in builders).Please note that this event may be thrown for various types
of expressions, not only method calls (binary expressions for example).</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-methodNotFound" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>methodNotFound</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker when it fails to
  find an appropriate method for a method call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ClassNode receiver, String name, ArgumentListExpression argList, ClassNode[] argTypes,MethodCall call</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    <span style="color:#777">// receiver is the inferred type of the receiver</span>
    <span style="color:#777">// name is the name of the called method</span>
    <span style="color:#777">// argList is the list of arguments the method was called with</span>
    <span style="color:#777">// argTypes is the array of inferred types for each argument</span>
    <span style="color:#777">// call is the method call for which we couldn’t find a target method</span>
    <span style="color:#080;font-weight:bold">if</span> (receiver==classNodeFor(<span style="color:#0a8;font-weight:bold">String</span>)
            &amp;&amp; name==<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">longueur</span><span style="color:#710">'</span></span>
            &amp;&amp; argList.size()==<span style="color:#00D">0</span>) {
        handled = <span style="color:#069">true</span>
        <span style="color:#080;font-weight:bold">return</span> newMethod(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">longueur</span><span style="color:#710">'</span></span>, classNodeFor(<span style="color:#0a8;font-weight:bold">String</span>))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike <code>onMethodSelection</code>, this event is
sent when the type checker cannot find a target method for a method call
(instance or static). It gives you the chance to intercept the error
before it is sent to the user, but also set the target method.For this,
you need to return a list of <code>MethodNode</code>. In most situations, you would
either return: an empty list, meaning that you didn’t find a
corresponding method, a list with exactly one element, saying that there’s
no doubt about the target methodIf you return more than one MethodNode,
then the compiler would throw an error to the user stating that the
method call is ambiguous, listing the possible methods.For convenience,
if you want to return only one method, you are allowed to return it
directly instead of wrapping it into a list.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitMethod" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>beforeVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker before type
  checking a method body</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>MethodNode node</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">beforeVisitMethod { methodNode -&gt;
    <span style="color:#777">// tell the type checker we will handle the body by ourselves</span>
    handled = methodNode.name.startsWith(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">skip</span><span style="color:#710">'</span></span>)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type checker will call this method before
starting to type check a method body. If you want, for example, to
perform type checking by yourself instead of letting the type checker do
it, you have to set the handled flag to true. This event can also be used
to help define the scope of your extension (for example, applying it
only if you are inside method foo).</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitMethod" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>afterVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker after type
  checking a method body</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>MethodNode node</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">afterVisitMethod { methodNode -&gt;
    scopeExit {
        <span style="color:#080;font-weight:bold">if</span> (methods&gt;<span style="color:#00D">2</span>) {
            addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Method </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>methodNode.name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> contains more than 2 method calls</span><span style="color:#710">&quot;</span></span>, methodNode)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gives you the opportunity to perform additional
checks after a method body is visited by the type checker. This is
useful if you collect information, for example, and want to perform
additional checks once everything has been collected.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitClass" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>beforeVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker before type checking a class</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ClassNode node</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">beforeVisitClass { ClassNode classNode -&gt;
    <span style="color:#080;font-weight:bold">def</span> name = classNode.nameWithoutPackage
    <span style="color:#080;font-weight:bold">if</span> (!(name[<span style="color:#00D">0</span>] <span style="color:#080;font-weight:bold">in</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>..<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Z</span><span style="color:#710">'</span></span>)) {
        addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Class '</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">' doesn't start with an uppercase letter</span><span style="color:#710">&quot;</span></span>,classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a class is type checked, then
before visiting the class, this event will be sent. It is also the case
for inner classes defined inside a class annotated with <code>@TypeChecked</code>. It
can help you define the scope of your extension, or you can even totally
replace the visit of the type checker with a custom type checking
implementation. For that, you would have to set the <code>handled</code> flag to
<code>true</code>. </p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitClass" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>afterVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called by the type checker after having finished the visit of a type checked class</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ClassNode node</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">afterVisitClass { ClassNode classNode -&gt;
    <span style="color:#080;font-weight:bold">def</span> name = classNode.nameWithoutPackage
    <span style="color:#080;font-weight:bold">if</span> (!(name[<span style="color:#00D">0</span>] <span style="color:#080;font-weight:bold">in</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">A</span><span style="color:#710">'</span></span>..<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Z</span><span style="color:#710">'</span></span>)) {
        addStaticTypeError(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Class '</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">${</span>name<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">' doesn't start with an uppercase letter</span><span style="color:#710">&quot;</span></span>,classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Called
for every class being type checked after the type checker finished its
work. This includes classes annotated with <code>@TypeChecked</code> and any
inner/anonymous class defined in the same class with is not skipped.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-incompatibleAssignment" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>incompatibleAssignment</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker thinks
    that an assignment is incorrect, meaning that the right-hand side of an
    assignment is incompatible with the left-hand side</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ClassNode lhsType, ClassNode rhsType, Expression assignment</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">incompatibleAssignment { lhsType, rhsType, expr -&gt;
    <span style="color:#080;font-weight:bold">if</span> (isBinaryExpression(expr) &amp;&amp; isAssignment(expr.operation.type)) {
        <span style="color:#080;font-weight:bold">if</span> (lhsType==classNodeFor(<span style="color:#339;font-weight:bold">int</span>) &amp;&amp; rhsType==classNodeFor(Closure)) {
            handled = <span style="color:#069">true</span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gives the
developer the ability to handle incorrect assignments. This is for
example useful if a class overrides <code>setProperty</code>, because in that case it
is possible that assigning a variable of one type to a property of
another type is handled through that runtime mechanism. In that case, you
can help the type checker just by telling it that the assignment is
valid (using <code>handled</code> set to <code>true</code>).</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-incompatibleReturnType" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>incompatibleReturnType</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker thinks that a return value is incompatibe with
    the return type of the enclosing closure or method</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ReturnStatement statement, ClassNode valueType</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">incompatibleReturnType { stmt, type -&gt;
    <span style="color:#080;font-weight:bold">if</span> (type == STRING_TYPE) {
        handled = <span style="color:#069">true</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gives the developer the ability to handle incorrect return values. This is for
example useful when the return value will undergo implicit conversion or the
enclosing closure&#8217;s target type is difficult to infer properly. In that case,
you can help the type checker just by telling it that the assignment is valid
(by setting the <code>handled</code> property).</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-ambiguousMethods" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event name</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>ambiguousMethods</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Called When</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called when the type checker cannot choose between several candidate methods</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Arguments</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>List&lt;MethodNode&gt; methods,  Expression origin</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Usage</strong></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ambiguousMethods { methods, origin -&gt;
    <span style="color:#777">// choose the method which has an Integer as parameter type</span>
    methods.find { <span style="color:#950">it</span>.parameters.any { <span style="color:#950">it</span>.type == classNodeFor(<span style="color:#0a8;font-weight:bold">Integer</span>) } }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gives the
developer the ability to handle incorrect assignments. This is for
example useful if a class overrides <code>setProperty</code>, because in that case it
is possible that assigning a variable of one type to a property of
another type is handled through that runtime mechanism. In that case, you
can help the type checker just by telling it that the assignment is
valid (using <code>handled</code> set to <code>true</code>).</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Of course, an extension script may consist of several blocks, and you
can have multiple blocks responding to the same event. This makes the
DSL look nicer and easier to write. However, reacting to events is far
from sufficient. If you know you can react to events, you also need to
deal with the errors, which implies several <em>helper</em> methods that will
make things easier.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Workingwithextensions"><a class="link" href="#Typecheckingextensions-Workingwithextensions">6.7.1.5. Working with extensions</a></h5>
<div class="sect5">
<h6 id="Typecheckingextensions-Supportclasses"><a class="link" href="#Typecheckingextensions-Supportclasses">Support classes</a></h6>
<div class="paragraph">
<p>The DSL relies on a support class called gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport[] .
This class itself extends gapi:org.codehaus.groovy.transform.stc.TypeCheckingExtension[] .
Those two classes define a number of <em>helper</em> methods that will make working
with the AST easier, especially regarding type checking. One interesting
thing to know is that you <strong>have access to the type checker</strong>. This means
that you can programmatically call methods of the type checker,
including those that allow you to <strong>throw compilation errors</strong>.</p>
</div>
<div class="paragraph">
<p>The extension script delegates to the gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport[] class,
meaning that you have direct access to the following variables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>context</em>: the type checker context, of type gapi:org.codehaus.groovy.transform.stc.TypeCheckingContext[]</p>
</li>
<li>
<p><em>typeCheckingVisitor</em>: the type checker itself, a gapi:org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor[] instance</p>
</li>
<li>
<p><em>generatedMethods</em>: a list of "generated methods", which is in fact the list of "dummy" methods that you can create
inside a type checking extension using the <code>newMethod</code> calls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The type checking context contains a lot of information that is useful
in context for the type checker. For example, the current stack of
enclosing method calls, binary expressions, closures, … This information
is in particular important if you have to know <em>where</em> you are when an
error occurs and that you want to handle it.</p>
</div>
<div class="paragraph">
<p>In addition to facilities provided by <code>GroovyTypeCheckingExtensionSupport</code> and <code>StaticTypeCheckingVisitor</code>,
a type-checking DSL script imports static members from gapi:org.codehaus.groovy.ast.ClassHelper[] and
gapi:org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport[] granting access to common types via
<code>OBJECT_TYPE</code>, <code>STRING_TYPE</code>, <code>THROWABLE_TYPE</code>, etc. and checks like <code>missesGenericsTypes(ClassNode)</code>,
<code>isClassClassNodeWrappingConcreteType(ClassNode)</code> and so on.</p>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Classnodes"><a class="link" href="#Typecheckingextensions-Classnodes">Class nodes</a></h6>
<div class="paragraph">
<p>Handling class nodes is something that needs particular attention when
you work with a type checking extension. Compilation works with an
abstract syntax tree (AST) and the tree may not be complete when you are
type checking a class. This also means that when you refer to types, you
must not use class literals such as <code>String</code> or <code>HashSet</code>, but to class
nodes representing those types. This requires a certain level of
abstraction and understanding how Groovy deals with class nodes. To make
things easier, Groovy supplies several helper methods to deal with class
nodes. For example, if you want to say "the type for String", you can
write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> classNodeFor(<span style="color:#0a8;font-weight:bold">String</span>) <span style="color:#080;font-weight:bold">instanceof</span> ClassNode</code></pre>
</div>
</div>
<div class="paragraph">
<p>You would also note that there is a variant of <em>classNodeFor</em> that takes
a <code>String</code> as an argument, instead of a <code>Class</code>. In general, you
should <strong>not</strong> use that one, because it would create a class node for
which the name is <code>String</code>, but without any method, any property, …
defined on it. The first version returns a class node that is <em>resolved</em>
but the second one returns one that is <em>not</em>. So the latter should be
reserved for very special cases.</p>
</div>
<div class="paragraph">
<p>The second problem that you might encounter is referencing a type which
is not yet compiled. This may happen more often than you think. For
example, when you compile a set of files together. In that case, if you
want to say "that variable is of type Foo" but <code>Foo</code> is not yet
compiled, you can still refer to the <code>Foo</code> class node
using <code>lookupClassNodeFor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">assert</span> lookupClassNodeFor(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Foo</span><span style="color:#710">'</span></span>) <span style="color:#080;font-weight:bold">instanceof</span> ClassNode</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Helpingthetypechecker"><a class="link" href="#Typecheckingextensions-Helpingthetypechecker">Helping the type checker</a></h6>
<div class="paragraph">
<p>Say that you know that variable <code>foo</code> is of type <code>Foo</code> and you want to
tell the type checker about it. Then you can use the <code>storeType</code> method,
which takes two arguments: the first one is the node for which you want
to store the type and the second one is the type of the node. If you
look at the implementation of <code>storeType</code>, you would see that it
delegates to the type checker equivalent method, which itself does a lot
of work to store node metadata. You would also see that storing the type
is not limited to variables: you can set the type of any expression.</p>
</div>
<div class="paragraph">
<p>Likewise, getting the type of an AST node is just a matter of
calling <code>getType</code> on that node. This would in general be what you want,
but there’s something that you must understand:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getType</code> returns the <strong>inferred type</strong> of an expression. This means
that it will not return, for a variable declared of type <code>Object</code> the
class node for <code>Object</code>, but the inferred type of this variable <strong>at this
point of the code</strong> (flow typing)</p>
</li>
<li>
<p>if you want to access the origin type of a variable (or
field/parameter), then you must call the appropriate method on the AST
node</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Throwinganerror"><a class="link" href="#Typecheckingextensions-Throwinganerror">Throwing an error</a></h6>
<div class="paragraph">
<p>To throw a type checking error, you only have to call the
<code>addStaticTypeError</code> method which takes two arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <em>message</em> which is a string that will be displayed to the end user</p>
</li>
<li>
<p>an <em>AST node</em> responsible for the error. It’s better to provide the best
suiting AST node because it will be used to retrieve the line and column
numbers</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-isXXXExpression"><a class="link" href="#Typecheckingextensions-isXXXExpression">isXXXExpression</a></h6>
<div class="paragraph">
<p>It is often required to know the type of an AST node. For readability,
the DSL provides a special isXXXExpression method that will delegate to
<code>x instance of XXXExpression</code>. For example, instead of writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">if</span> (node <span style="color:#080;font-weight:bold">instanceof</span> BinaryExpression) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you can just write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">if</span> (isBinaryExpression(node)) {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Virtualmethods"><a class="link" href="#Typecheckingextensions-Virtualmethods">Virtual methods</a></h6>
<div class="paragraph">
<p>When you perform type checking of dynamic code, you may often face the
case when you know that a method call is valid but there is no "real"
method behind it. As an example, take the Grails dynamic finders. You
can have a method call consisting of a method named <em>findByName(…)</em>. As
there’s no <em>findByName</em> method defined in the bean, the type checker
would complain. Yet, you would know that this method wouldn’t fail at
runtime, and you can even tell what is the return type of this method.
For this case, the DSL supports two special constructs that consist of
<em>phantom methods</em>. This means that you will return a method node that
doesn’t really exist but is defined in the context of type checking.
Three methods exist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newMethod(String name, Class returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, ClassNode returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, Callable&lt;ClassNode&gt; return Type)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All three variants do the same: they create a new method node which name
is the supplied name and define the return type of this method.
Moreover, the type checker would add those methods in
the <code>generatedMethods</code> list (see <code>isGenerated</code> below). The reason why we
only set a name and a return type is that it is only what you need in
90% of the cases. For example, in the <code>findByName</code> example upper, the
only thing you need to know is that <code>findByName</code> wouldn’t fail at
runtime, and that it returns a domain class. The <code>Callable</code> version of
return type is interesting because it defers the computation of the
return type when the type checker actually needs it. This is interesting
because in some circumstances, you may not know the actual return type
when the type checker demands it, so you can use a closure that will be
called each time <code>getReturnType</code> is called by the type checker on this
method node. If you combine this with deferred checks, you can achieve
pretty complex type checking including handling of forward references.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">newMethod(name) {
    <span style="color:#777">// each time getReturnType on this method node will be called, this closure will be called!</span>
    println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Type checker called me!</span><span style="color:#710">'</span></span>
    lookupClassNodeFor(Foo) <span style="color:#777">// return type</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Should you need more than the name and return type, you can always
create a new <code>MethodNode</code> by yourself.</p>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Scoping"><a class="link" href="#Typecheckingextensions-Scoping">Scoping</a></h6>
<div class="paragraph">
<p>Scoping is very important in DSL type checking and is one of the reasons
why we couldn’t use a <em>pointcut</em> based approach to DSL type checking.
Basically, you must be able to define very precisely when your extension
applies and when it does not. Moreover, you must be able to handle
situations that a regular type checker would not be able to handle, such
as forward references:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">point a(<span style="color:#00D">1</span>,<span style="color:#00D">1</span>)
line a,b <span style="color:#777">// b is referenced afterwards!</span>
point b(<span style="color:#00D">5</span>,<span style="color:#00D">2</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Say for example that you want to handle a builder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">builder.foo {
   bar
   baz(bar)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your extension, then, should only be active once you’ve entered
the <code>foo</code> method, and inactive outside this scope. But you could have
complex situations like multiple builders in the same file or embedded
builders (builders in builders). While you should not try to fix all
this from start (you must accept limitations to type checking), the type
checker does offer a nice mechanism to handle this: a scoping stack,
using the <code>newScope</code> and <code>scopeExit</code> methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newScope</code> creates a new scope and puts it on top of the stack</p>
</li>
<li>
<p><code>scopeExits</code> pops a scope from the stack</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A scope consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a parent scope</p>
</li>
<li>
<p>a map of custom data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to look at the implementation, it’s simply a <code>LinkedHashMap</code>
(gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport.TypeCheckingScope[]),
but it’s quite powerful. For example, you can use such a scope to store
a list of closures to be executed when you exit the scope. This is how
you would handle forward references: </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> scope = newScope()
scope.secondPassChecks = <span style="color:#339;font-weight:bold">[]</span>
<span style="color:#777">//...</span>
scope.secondPassChecks &lt;&lt; { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">executed later</span><span style="color:#710">'</span></span> }
<span style="color:#777">// ...</span>
scopeExit {
    secondPassChecks*.run() <span style="color:#777">// execute deferred checks</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is to say, that if at some point you are not able to determine the
type of an expression, or that you are not able to check at this point
that an assignment is valid or not, you can still make the check later…
This is a very powerful feature. Now, <code>newScope</code> and <code>scopeExit</code>
provide some interesting syntactic sugar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">newScope {
    secondPassChecks = <span style="color:#339;font-weight:bold">[]</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At anytime in the DSL, you can access the current scope
using <code>getCurrentScope()</code> or more simply <code>currentScope</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#777">//...</span>
currentScope.secondPassChecks &lt;&lt; { println <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">executed later</span><span style="color:#710">'</span></span> }
<span style="color:#777">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The general schema would then be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>determine a <em>pointcut</em> where you push a new scope on stack and
initialize custom variables within this scope</p>
</li>
<li>
<p>using the various events, you can use the information stored in your
custom scope to perform checks, defer checks,…</p>
</li>
<li>
<p>determine a <em>pointcut</em> where you exit the scope, call <code>scopeExit</code>
and eventually perform additional checks</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Otherusefulmethods"><a class="link" href="#Typecheckingextensions-Otherusefulmethods">Other useful methods</a></h6>
<div class="paragraph">
<p>For the complete list of helper methods, please refer to
the gapi:org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport[] and 
gapi:org.codehaus.groovy.transform.stc.TypeCheckingExtension[] classes. However,
take special attention to those methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isDynamic</code>: takes a VariableExpression as argument and returns true
if the variable is a DynamicExpression, which means, in a script, that
it wasn’t defined using a type or <code>def</code>.</p>
</li>
<li>
<p><code>isGenerated</code>: takes a MethodNode as an argument and tells if the
method is one that was generated by the type checker extension using
the <code>newMethod</code> method</p>
</li>
<li>
<p><code>isAnnotatedBy</code>: takes an AST node and a Class (or ClassNode), and
tells if the node is annotated with this class. For example:
<code>isAnnotatedBy(node, NotNull)</code></p>
</li>
<li>
<p><code>getTargetMethod</code>: takes a method call as argument and returns
the <code>MethodNode</code> that the type checker has determined for it</p>
</li>
<li>
<p><code>delegatesTo</code>: emulates the behaviour of the <code>@DelegatesTo</code>
annotation. It allows you to tell that the argument will delegate to a
specific type (you can also specify the delegation strategy)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_type_checking_extensions"><a class="link" href="#_advanced_type_checking_extensions">6.7.2. Advanced type checking extensions</a></h4>
<div class="sect4">
<h5 id="_precompiled_type_checking_extensions"><a class="link" href="#_precompiled_type_checking_extensions">6.7.2.1. Precompiled type checking extensions</a></h5>
<div class="paragraph">
<p>All the examples above use type checking scripts. They are found in source form in classpath, meaning that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a Groovy source file, corresponding to the type checking extension, is available on compilation classpath</p>
</li>
<li>
<p>this file is compiled by the Groovy compiler for each source unit being compiled (often, a source unit corresponds
to a single file)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is a very convenient way to develop type checking extensions, however it implies a slower compilation phase, because
of the compilation of the extension itself for each file being compiled. For those reasons, it can be practical to rely
on a precompiled extension. You have two options to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>write the extension in Groovy, compile it, then use a reference to the extension class instead of the source</p>
</li>
<li>
<p>write the extension in Java, compile it, then use a reference to the extension class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Writing a type checking extension in Groovy is the easiest path. Basically, the idea is that the type checking extension
script becomes the body of the main method of a type checking extension class, as illustrated here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport</span>

<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">PrecompiledExtension</span> <span style="color:#088;font-weight:bold">extends</span> GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     // <b class="conum">(1)</b>
    <span style="color:#007">@Override</span>
    <span style="color:#0a8;font-weight:bold">Object</span> run() {                                                                          // <b class="conum">(2)</b>
        unresolvedVariable { <span style="color:#339;font-weight:bold">var</span> -&gt;
            <span style="color:#080;font-weight:bold">if</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robot</span><span style="color:#710">'</span></span>==<span style="color:#339;font-weight:bold">var</span>.name) {
                storeType(<span style="color:#339;font-weight:bold">var</span>, classNodeFor(<span style="color:#0a8;font-weight:bold">Robot</span>))                                         // <b class="conum">(3)</b>
                handled = <span style="color:#069">true</span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>extending the <code>TypeCheckingDSL</code> class is the easiest</p>
</li>
<li>
<p>then the extension code needs to go inside the <code>run</code> method</p>
</li>
<li>
<p>and you can use the very same events as an extension written in source form</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Setting up the extension is very similar to using a source form extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">config.addCompilationCustomizers(
    <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(
        TypeChecked,
        <span style="color:#606">extensions</span>:[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">typing.PrecompiledExtension</span><span style="color:#710">'</span></span>])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference is that instead of using a path in classpath, you just specify the fully qualified class name of the
precompiled extension.</p>
</div>
<div class="paragraph">
<p>In case you really want to write an extension in Java, then you will not benefit from the type checking extension DSL.
The extension above can be rewritten in Java this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.ast.ClassHelper</span>;
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.ast.expr.VariableExpression</span>;
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension</span>;


<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor</span>;

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">PrecompiledJavaExtension</span> <span style="color:#088;font-weight:bold">extends</span> AbstractTypeCheckingExtension {                   // <b class="conum">(1)</b>

    <span style="color:#088;font-weight:bold">public</span> PrecompiledJavaExtension(<span style="color:#088;font-weight:bold">final</span> StaticTypeCheckingVisitor typeCheckingVisitor) {
        <span style="color:#950">super</span>(typeCheckingVisitor);
    }

    <span style="color:#007">@Override</span>
    <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">boolean</span> handleUnresolvedVariableExpression(<span style="color:#088;font-weight:bold">final</span> VariableExpression vexp) {          // <b class="conum">(2)</b>
        <span style="color:#080;font-weight:bold">if</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">robot</span><span style="color:#710">&quot;</span></span>.equals(vexp.getName())) {
            storeType(vexp, ClassHelper.make(<span style="color:#0a8;font-weight:bold">Robot</span>.class));
            setHandled(<span style="color:#069">true</span>);
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span>;
        }
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">false</span>;
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>extend the <code>AbstractTypeCheckingExtension</code> class</p>
</li>
<li>
<p>then override the <code>handleXXX</code> methods as required</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_using_grab_in_a_type_checking_extension"><a class="link" href="#_using_grab_in_a_type_checking_extension">6.7.2.2. Using @Grab in a type checking extension</a></h5>
<div class="paragraph">
<p>It is totally possible to use the <code>@Grab</code> annotation in a type checking extension.
This means you can include libraries that would only be
available at compile time. In that case, you must understand that you
would increase the time of compilation significantly (at least, the
first time it grabs the dependencies).</p>
</div>
</div>
<div class="sect4">
<h5 id="_sharing_or_packaging_type_checking_extensions"><a class="link" href="#_sharing_or_packaging_type_checking_extensions">6.7.2.3. Sharing or packaging type checking extensions</a></h5>
<div class="paragraph">
<p>A type checking extension is just a script that need to be on classpath. As such,
you can share it as is, or bundle it in a jar file that would be added to classpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="_global_type_checking_extensions"><a class="link" href="#_global_type_checking_extensions">6.7.2.4. Global type checking extensions</a></h5>
<div class="paragraph">
<p>While you can configure the compiler to transparently add type checking extensions to your
script, there is currently no way to apply an extension transparently just by having it on
classpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="_type_checking_extensions_and_compilestatic"><a class="link" href="#_type_checking_extensions_and_compilestatic">6.7.2.5. Type checking extensions and @CompileStatic</a></h5>
<div class="paragraph">
<p>Type checking extensions are used with <code>@TypeChecked</code> but can also be used with <code>@CompileStatic</code>. However, you must
be aware that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a type checking extension used with <code>@CompileStatic</code> will in general not be sufficient to let the compiler know how
to generate statically compilable code from "unsafe" code</p>
</li>
<li>
<p>it is possible to use a type checking extension with <code>@CompileStatic</code> just to enhance type checking, that is to say
introduce <strong>more</strong> compilation errors, without actually dealing with dynamic code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s explain the first point, which is that even if you use an extension, the compiler will not know how to compile
your code statically: technically, even if you tell the type checker what is the type of a dynamic
variable, for example, it would not know how to compile it. Is it <code>getBinding('foo')</code>, <code>getProperty('foo')</code>,
<code>delegate.getFoo()</code>,…? There&#8217;s absolutely no direct way to tell the static compiler how to compile such
code even if you use a type checking extension (that would, again, only give hints about the type).</p>
</div>
<div class="paragraph">
<p>One possible solution for this particular example is to instruct the compiler to use <a href="#mixed-mode">mixed mode compilation</a>.
The more advanced one is to use <a href="#ast-xform-as-extension">AST transformations during type checking</a> but it is far more
complex.</p>
</div>
<div class="paragraph">
<p>Type checking extensions allow you to help the type checker where it
fails, but it also allows you to fail where it doesn’t. In that context,
it makes sense to support extensions for <code>@CompileStatic</code> too. Imagine
an extension that is capable of type checking SQL queries. In that case,
the extension would be valid in both dynamic and static context, because
without the extension, the code would still pass.</p>
</div>
</div>
<div class="sect4">
<h5 id="mixed-mode"><a class="link" href="#mixed-mode">6.7.2.6. Mixed mode compilation</a></h5>
<div class="paragraph">
<p>In the previous section, we highlighted the fact that you can activate type checking extensions with
<code>@CompileStatic</code>. In that context, the type checker would not complain anymore about some unresolved variables or
unknown method calls, but it would still wouldn&#8217;t know how to compile them statically.</p>
</div>
<div class="paragraph">
<p>Mixed mode compilation offers a third way, which is to instruct the compiler that whenever an unresolved variable
or method call is found, then it should fall back to a dynamic mode. This is possible thanks to type checking extensions
and a special <code>makeDynamic</code> call.</p>
</div>
<div class="paragraph">
<p>To illustrate this, let&#8217;s come back to the <code>Robot</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">robot.move <span style="color:#00D">100</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s try to activate our type checking extension using <code>@CompileStatic</code> instead of <code>@TypeChecked</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
config.addCompilationCustomizers(
    <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(
        CompileStatic,                                      // <b class="conum">(1)</b>
        <span style="color:#606">extensions</span>:[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robotextension.groovy</span><span style="color:#710">'</span></span>])               // <b class="conum">(2)</b>
)
<span style="color:#080;font-weight:bold">def</span> shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
<span style="color:#080;font-weight:bold">def</span> robot = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Robot</span>()
shell.setVariable(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robot</span><span style="color:#710">'</span></span>, robot)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Apply <code>@CompileStatic</code> transparently</p>
</li>
<li>
<p>Activate the type checking extension</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The script will run fine because the static compiler is told about the type of the <code>robot</code> variable, so it is capable
of making a direct call to <code>move</code>. But before that, how did the compiler know how to get the <code>robot</code> variable? In fact
by default, in a type checking extension, setting <code>handled=true</code> on an unresolved variable will automatically trigger
a dynamic resolution, so in this case you don&#8217;t have anything special to make the compiler use a mixed mode. However,
let&#8217;s slightly update our example, starting from the robot script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">move <span style="color:#00D">100</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here you can notice that there is no reference to <code>robot</code> anymore. Our extension will not help then because we will not
be able to instruct the compiler that <code>move</code> is done on a <code>Robot</code> instance. This example of code can be executed in a
totally dynamic way thanks to the help of a gapi:groovy.util.DelegatingScript[]:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span style="color:#080;font-weight:bold">def</span> config = <span style="color:#080;font-weight:bold">new</span> CompilerConfiguration()
config.scriptBaseClass = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">groovy.util.DelegatingScript</span><span style="color:#710">'</span></span>     // <b class="conum">(1)</b>
<span style="color:#080;font-weight:bold">def</span> shell = <span style="color:#080;font-weight:bold">new</span> GroovyShell(config)
<span style="color:#080;font-weight:bold">def</span> runner = shell.parse(script)                            // <b class="conum">(2)</b>
runner.setDelegate(<span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">Robot</span>())                             // <b class="conum">(3)</b>
runner.run()                                                // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>we configure the compiler to use a <code>DelegatingScript</code> as the base class</p>
</li>
<li>
<p>the script source needs to be parsed and will return an instance of <code>DelegatingScript</code></p>
</li>
<li>
<p>we can then call <code>setDelegate</code> to use a <code>Robot</code> as the delegate of the script</p>
</li>
<li>
<p>then execute the script. <code>move</code> will be directly executed on the delegate</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If we want this to pass with <code>@CompileStatic</code>, we have to use a type checking extension, so let&#8217;s update our configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">config.addCompilationCustomizers(
    <span style="color:#080;font-weight:bold">new</span> ASTTransformationCustomizer(
        CompileStatic,                                      // <b class="conum">(1)</b>
        <span style="color:#606">extensions</span>:[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">robotextension2.groovy</span><span style="color:#710">'</span></span>])              // <b class="conum">(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>apply <code>@CompileStatic</code> transparently</p>
</li>
<li>
<p>use an alternate type checking extension meant to recognize the call to <code>move</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then in the previous section we have learnt how to deal with unrecognized method calls, so we are able to write this
extension:</p>
</div>
<div class="listingblock">
<div class="title">robotextension2.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    <span style="color:#080;font-weight:bold">if</span> (isMethodCallExpression(call)                        // <b class="conum">(1)</b>
        &amp;&amp; call.implicitThis                                // <b class="conum">(2)</b>
        &amp;&amp; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">move</span><span style="color:#710">'</span></span>==name                                     // <b class="conum">(3)</b>
        &amp;&amp; argTypes.length==<span style="color:#00D">1</span>                               // <b class="conum">(4)</b>
        &amp;&amp; argTypes[<span style="color:#00D">0</span>] == classNodeFor(<span style="color:#339;font-weight:bold">int</span>)                 // <b class="conum">(5)</b>
    ) {
        handled = <span style="color:#069">true</span>                                      // <b class="conum">(6)</b>
        newMethod(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">move</span><span style="color:#710">'</span></span>, classNodeFor(<span style="color:#0a8;font-weight:bold">Robot</span>))              // <b class="conum">(7)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>if the call is a method call (not a static method call)</p>
</li>
<li>
<p>that this call is made on "implicit this" (no explicit <code>this.</code>)</p>
</li>
<li>
<p>that the method being called is <code>move</code></p>
</li>
<li>
<p>and that the call is done with a single argument</p>
</li>
<li>
<p>and that argument is of type <code>int</code></p>
</li>
<li>
<p>then tell the type checker that the call is valid</p>
</li>
<li>
<p>and that the return type of the call is <code>Robot</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you try to execute this code, then you could be surprised that it actually fails at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;</pre>
</div>
</div>
<div class="paragraph">
<p>The reason is very simple: while the type checking extension is sufficient for <code>@TypeChecked</code>, which does not involve
static compilation, it is not enough for <code>@CompileStatic</code> which requires additional information. In this case, you told
the compiler that the method existed, but you didn&#8217;t explain to it <strong>what</strong> method it is in reality, and what is the
receiver of the message (the delegate).</p>
</div>
<div class="paragraph">
<p>Fixing this is very easy and just implies replacing the <code>newMethod</code> call with something else:</p>
</div>
<div class="listingblock">
<div class="title">robotextension3.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    <span style="color:#080;font-weight:bold">if</span> (isMethodCallExpression(call)
        &amp;&amp; call.implicitThis
        &amp;&amp; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">move</span><span style="color:#710">'</span></span>==name
        &amp;&amp; argTypes.length==<span style="color:#00D">1</span>
        &amp;&amp; argTypes[<span style="color:#00D">0</span>] == classNodeFor(<span style="color:#339;font-weight:bold">int</span>)
    ) {
        makeDynamic(call, classNodeFor(<span style="color:#0a8;font-weight:bold">Robot</span>))              // <b class="conum">(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>tell the compiler that the call should be make dynamic</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>makeDynamic</code> call does 3 things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it returns a virtual method just like <code>newMethod</code></p>
</li>
<li>
<p>automatically sets the <code>handled</code> flag to <code>true</code> for you</p>
</li>
<li>
<p>but also marks the <code>call</code> to be done dynamically</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So when the compiler will have to generate bytecode for the call to <code>move</code>, since it is now marked as a dynamic call,
it will fall back to the dynamic compiler and let it handle the call. And since the extension tells us that the return
type of the dynamic call is a <code>Robot</code>, subsequent calls will be done statically!</p>
</div>
<div class="paragraph">
<p>Some would wonder why the static compiler doesn&#8217;t do this by default without an extension. It is a design decision:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the code is statically compiled, we normally want type safety and best performance</p>
</li>
<li>
<p>so if unrecognized variables/method calls are made dynamic, you loose type safety, but also all support for typos at
compile time!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In short, if you want to have mixed mode compilation, it <strong>has</strong> to be explicit, through a type checking extension, so
that the compiler, and the designer of the DSL, are totally aware of what they are doing.</p>
</div>
<div class="paragraph">
<p><code>makeDynamic</code> can be used on 3 kind of AST nodes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a method node (<code>MethodNode</code>)</p>
</li>
<li>
<p>a variable (<code>VariableExpression</code>)</p>
</li>
<li>
<p>a property expression (<code>PropertyExpression</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If that is not enough, then it means that static compilation cannot be done directly and that you have to rely on AST
transformations.</p>
</div>
</div>
<div class="sect4">
<h5 id="ast-xform-as-extension"><a class="link" href="#ast-xform-as-extension">6.7.2.7. Transforming the AST in an extension</a></h5>
<div class="paragraph">
<p>Type checking extensions look very attractive from an AST transformation design point of view: extensions have access
to context like inferred types, which is often nice to have. And an extension has a direct access to the abstract
syntax tree. Since you have access to the AST, there is nothing in theory that prevents
you from modifying the AST. However, we do not recommend you to do so, unless you are an advanced AST transformation
designer and well aware of the compiler internals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First of all, you would explicitly break the contract of type checking, which is to annotate,
and only annotate the AST. Type checking should <strong>not</strong> modify the AST tree because you wouldn’t be able to
guarantee anymore that code without the <em>@TypeChecked</em> annotation
behaves the same without the annotation.</p>
</li>
<li>
<p>If your extension is meant to work with <em>@CompileStatic</em>, then you <strong>can</strong> modify the AST because
this is indeed what <em>@CompileStatic</em> will eventually do. Static compilation doesn’t guarantee the same semantics at
dynamic Groovy so there is effectively a difference between code compiled with <em>@CompileStatic</em> and code compiled
with <em>@TypeChecked</em>. It’s up to you to choose whatever strategy you want to update the AST, but probably
using an AST transformation that runs before type checking is easier.</p>
</li>
<li>
<p>if you cannot rely on a transformation that kicks in before the type checker, then you must be <strong>very</strong> careful</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The type checking phase is the last phase running in the compiler before bytecode generation. All other AST
transformations run before that and the compiler does a very good job at "fixing" incorrect AST generated before the
type checking phase. As soon as you perform a transformation during type checking, for example directly in a type
checking extension, then you have to do all this work of generating a 100% compiler compliant abstract syntax tree by
yourself, which can easily become complex. That&#8217;s why we do not recommend to go that way if you are beginning with
type checking extensions and AST transformations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_examples"><a class="link" href="#_examples">6.7.2.8. Examples</a></h5>
<div class="paragraph">
<p>Examples of real life type checking extensions are easy to find. You can download the source code for Groovy and
take a look at the
<a href="https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy">TypeCheckingExtensionsTest</a>
class which is linked to
<a href="https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc">various extension scripts</a>.</p>
</div>
<div class="paragraph">
<p>An example of a complex type checking extension can be found in the <a href="../markup-template-engine.html">Markup Template Engine</a>
source code: this template engine relies on a type checking extension and AST transformations to transform templates into
fully statically compiled code. Sources for this can be found
<a href="https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup">here</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-01-31 16:49:50 +0800
</div>
</div>
</body>
</html>